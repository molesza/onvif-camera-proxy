This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
memory-bank/
  activeContext.md
  productContext.md
  progress.md
  projectbrief.md
  systemPatterns.md
  techContext.md
src/
  config-builder.js
  onvif-server.js
wsdl/
  vendor/
    b-2.xsd
    common.xsd
    devicemgmt.wsdl
    include.xsd
    media.wsdl
    onvif.xsd
    soap-envelope.xsd
    xmlmime.xsd
  device_service.wsdl
  media_service.wsdl
.clinerules
.gitignore
config-192.168.6.201.yaml
config-192.168.6.202.yaml
config-192.168.6.204.yaml
config-combined.yaml
create-test-config.js
Dockerfile
extract_resolutions.js
extract-test-config.js
generate-dynamic-config.js
LICENSE
mac_to_interface.txt
main.js
ONVIF-SERVER-GUIDE.md
package.json
README.md
SETUP-GUIDE.md
setup-network-192.168.6.201.sh
setup-network-192.168.6.202.sh
setup-network-192.168.6.204.sh
setup-network-combined.sh
test-camera-ips.sh
todo.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="config-192.168.6.202.yaml">
onvif:
  - mac: 02:cc:00:d2:a6:c3
    ports:
      server: 8081
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel1
    uuid: 5779cecc-dd86-43b6-8b25-9916a8dded40
    highQuality:
      rtsp: /cam/realmonitor?channel=1&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=1&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=1&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=1&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:c9:54:34:84:df
    ports:
      server: 8082
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel2
    uuid: 1f680743-9e3c-42eb-975c-38b9ffcb4230
    highQuality:
      rtsp: /cam/realmonitor?channel=2&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=2&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=2&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=2&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 320
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:90:67:6b:60:43
    ports:
      server: 8083
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel3
    uuid: 681edc98-1f8b-4213-90da-725225636dee
    highQuality:
      rtsp: /cam/realmonitor?channel=3&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=3&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=3&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=3&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:6f:ea:dc:25:89
    ports:
      server: 8084
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel4
    uuid: 6d92b379-61b4-49a5-b541-a08adc984bc2
    highQuality:
      rtsp: /cam/realmonitor?channel=4&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=4&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=4&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=4&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:27:2b:64:d0:20
    ports:
      server: 8085
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel5
    uuid: 1911088c-ef2d-4d48-9a5b-e08a1b880ac3
    highQuality:
      rtsp: /cam/realmonitor?channel=5&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=5&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=5&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=5&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:92:d2:00:e6:ae
    ports:
      server: 8086
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel6
    uuid: 307b9e4b-bcac-441b-93ab-206ebd3dda0e
    highQuality:
      rtsp: /cam/realmonitor?channel=6&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=6&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=6&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=6&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:37:e5:a8:a6:04
    ports:
      server: 8087
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel7
    uuid: bd269196-5ad0-4992-be35-e31ab20b05a4
    highQuality:
      rtsp: /cam/realmonitor?channel=7&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=7&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=7&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=7&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:bc:83:1a:dc:a0
    ports:
      server: 8088
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel8
    uuid: b4d2e399-86d7-4af8-ab65-8556e985cd89
    highQuality:
      rtsp: /cam/realmonitor?channel=8&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=8&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=8&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=8&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:eb:6c:a6:68:8a
    ports:
      server: 8089
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel9
    uuid: 19601084-4c00-4f16-967e-eec10f06bf44
    highQuality:
      rtsp: /cam/realmonitor?channel=9&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=9&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=9&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=9&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:39:b8:15:6a:af
    ports:
      server: 8090
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel10
    uuid: df6591c0-fb4a-4344-9c0a-9a6206707493
    highQuality:
      rtsp: /cam/realmonitor?channel=10&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=10&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=10&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=10&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:c8:5b:d2:94:9e
    ports:
      server: 8091
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel11
    uuid: f06c73a7-c8b4-4cc9-a5b5-76b506b7242c
    highQuality:
      rtsp: /cam/realmonitor?channel=11&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=11&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=11&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=11&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:ff:43:d3:a5:6d
    ports:
      server: 8092
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel12
    uuid: a869daac-da7e-4aa7-a95b-38050bd2e0ec
    highQuality:
      rtsp: /cam/realmonitor?channel=12&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=12&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=12&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=12&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:50:e1:ff:17:7e
    ports:
      server: 8093
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel13
    uuid: bea1335f-4ef4-45bf-96ce-9f9f74e5facb
    highQuality:
      rtsp: /cam/realmonitor?channel=13&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=13&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=13&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=13&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:6e:97:6b:39:e3
    ports:
      server: 8094
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel14
    uuid: 1cfb9503-f728-4450-be27-00c67c5ef557
    highQuality:
      rtsp: /cam/realmonitor?channel=14&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=14&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=14&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=14&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:f8:26:39:03:d0
    ports:
      server: 8095
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel15
    uuid: 7ef24481-4624-4ac5-bed8-764a12a1c7d0
    highQuality:
      rtsp: /cam/realmonitor?channel=15&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=15&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=15&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=15&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:80:c4:d4:58:00
    ports:
      server: 8096
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel16
    uuid: 6f761f5f-d99d-4b0d-8d9c-b62bc34dc87f
    highQuality:
      rtsp: /cam/realmonitor?channel=16&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=16&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 512
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=16&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=16&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 80
      quality: 1
    target:
      hostname: 192.168.6.202
      ports:
        rtsp: 554
        snapshot: 80
</file>

<file path="config-192.168.6.204.yaml">
onvif:
  - mac: 02:6c:7c:51:4a:6c
    ports:
      server: 8081
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel1
    uuid: f535a453-4db4-43c2-87ce-e7970ba8bcbd
    highQuality:
      rtsp: /cam/realmonitor?channel=1&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=1&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=1&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=1&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:b5:d3:59:6d:bd
    ports:
      server: 8082
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel2
    uuid: 72e9cc1f-64de-4cee-bc94-e9bf532e205d
    highQuality:
      rtsp: /cam/realmonitor?channel=2&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=2&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=2&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=2&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:4c:f8:89:fa:84
    ports:
      server: 8083
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel3
    uuid: bddb6382-9d7c-43ae-ab66-741b99d95241
    highQuality:
      rtsp: /cam/realmonitor?channel=3&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=3&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=3&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=3&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:82:f7:19:d6:f1
    ports:
      server: 8084
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel4
    uuid: 41d20ad8-6283-411c-a45f-07f8c1858d8b
    highQuality:
      rtsp: /cam/realmonitor?channel=4&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=4&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=4&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=4&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:7e:89:ae:44:e8
    ports:
      server: 8085
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel5
    uuid: 8405ca73-91cb-4a19-9c41-dc58041ffff4
    highQuality:
      rtsp: /cam/realmonitor?channel=5&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=5&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=5&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=5&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:a0:63:ad:b1:b3
    ports:
      server: 8086
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel6
    uuid: ef41b2f6-f7d2-40fe-acc6-5901b041a0d0
    highQuality:
      rtsp: /cam/realmonitor?channel=6&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=6&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=6&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=6&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:e1:6c:9f:03:bc
    ports:
      server: 8087
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel7
    uuid: 652d8283-74a9-4d71-a71b-ce5b4619fad3
    highQuality:
      rtsp: /cam/realmonitor?channel=7&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=7&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=7&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=7&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:8e:6d:14:07:3c
    ports:
      server: 8088
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel8
    uuid: d50c1f65-5c05-4b92-9ef9-84d4301f1f5c
    highQuality:
      rtsp: /cam/realmonitor?channel=8&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=8&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=8&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=8&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:b0:6e:26:a2:e4
    ports:
      server: 8089
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel9
    uuid: d3327c5e-4a72-4eec-9c4f-87bda7b70879
    highQuality:
      rtsp: /cam/realmonitor?channel=9&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=9&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=9&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=9&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:46:2f:98:d7:54
    ports:
      server: 8090
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel10
    uuid: 23e34ae0-9734-426f-ac61-4102abdfc4d3
    highQuality:
      rtsp: /cam/realmonitor?channel=10&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=10&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=10&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=10&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:3a:1e:84:f3:c2
    ports:
      server: 8091
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel11
    uuid: 66609c4c-057a-4157-b93c-4142b6065f99
    highQuality:
      rtsp: /cam/realmonitor?channel=11&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=11&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=11&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=11&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:a3:bc:f6:98:a9
    ports:
      server: 8092
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel12
    uuid: 6ca19a28-c90e-407a-816f-17d21ca1663f
    highQuality:
      rtsp: /cam/realmonitor?channel=12&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=12&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=12&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=12&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:24:14:61:07:0d
    ports:
      server: 8093
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel13
    uuid: 57910599-764c-4d3d-affe-2c8c6c28bc1e
    highQuality:
      rtsp: /cam/realmonitor?channel=13&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=13&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=13&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=13&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:a3:ae:c0:be:3c
    ports:
      server: 8094
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel14
    uuid: 976bf6f0-86e0-43af-8aef-535690277db4
    highQuality:
      rtsp: /cam/realmonitor?channel=14&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=14&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=14&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=14&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:b0:46:fe:30:9d
    ports:
      server: 8095
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel15
    uuid: 56048be6-da81-44e7-84e4-de88268ecf8d
    highQuality:
      rtsp: /cam/realmonitor?channel=15&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=15&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=15&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=15&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:b6:10:34:57:93
    ports:
      server: 8096
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel16
    uuid: 649254c0-023f-486d-a806-4b197f29bf62
    highQuality:
      rtsp: /cam/realmonitor?channel=16&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=16&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=16&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=16&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:bb:98:b9:82:19
    ports:
      server: 8097
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel17
    uuid: 29ec27e9-d42f-47e3-a043-f1ba182cc5ee
    highQuality:
      rtsp: /cam/realmonitor?channel=17&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=17&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=17&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=17&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:24:71:07:ae:ac
    ports:
      server: 8098
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel18
    uuid: 52d1856f-3ccb-4784-bb75-803ff5b8aa99
    highQuality:
      rtsp: /cam/realmonitor?channel=18&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=18&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=18&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=18&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:90:98:73:cd:28
    ports:
      server: 8099
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel19
    uuid: d1b9fd5e-87d3-42c5-95b9-f4218c178d9d
    highQuality:
      rtsp: /cam/realmonitor?channel=19&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=19&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=19&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=19&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:6a:9d:c1:d5:73
    ports:
      server: 8100
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel20
    uuid: c1f51aa0-dec8-48b5-a8d4-9a4247322e16
    highQuality:
      rtsp: /cam/realmonitor?channel=20&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=20&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=20&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=20&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:e2:45:72:05:71
    ports:
      server: 8101
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel21
    uuid: fe5587ed-23f9-4636-b933-278632fb106a
    highQuality:
      rtsp: /cam/realmonitor?channel=21&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=21&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=21&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=21&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:50:e8:40:c0:87
    ports:
      server: 8102
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel22
    uuid: d6c9dbc3-6968-486d-9481-3aa625daeca0
    highQuality:
      rtsp: /cam/realmonitor?channel=22&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=22&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=22&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=22&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:98:a9:71:83:b6
    ports:
      server: 8103
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel23
    uuid: 2665e90c-0b45-4ae9-af96-af1f3c045a2e
    highQuality:
      rtsp: /cam/realmonitor?channel=23&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=23&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=23&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=23&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:3b:8a:2e:56:ea
    ports:
      server: 8104
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel24
    uuid: bb68063e-6d5e-4d9d-995e-5a14abd8a47e
    highQuality:
      rtsp: /cam/realmonitor?channel=24&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=24&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=24&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=24&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:c1:b2:86:21:71
    ports:
      server: 8105
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel25
    uuid: a1d9d559-9fff-41b4-8004-4bbfc7506f30
    highQuality:
      rtsp: /cam/realmonitor?channel=25&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=25&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=25&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=25&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:02:f6:54:16:69
    ports:
      server: 8106
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel26
    uuid: b3d79dcf-f8f4-4773-9234-30e7ada51fb8
    highQuality:
      rtsp: /cam/realmonitor?channel=26&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=26&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=26&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=26&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:bd:6c:9e:96:16
    ports:
      server: 8107
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel27
    uuid: 559c3777-08df-46b9-b0a4-cce67eeca340
    highQuality:
      rtsp: /cam/realmonitor?channel=27&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=27&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=27&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=27&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:0f:b3:45:69:5c
    ports:
      server: 8108
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel28
    uuid: 072c1321-08a9-4501-82b8-4c7aa656a10f
    highQuality:
      rtsp: /cam/realmonitor?channel=28&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=28&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=28&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=28&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:8a:8f:f6:b8:34
    ports:
      server: 8109
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel29
    uuid: ef528b37-f3b3-438b-aa8a-bcef44a2d53e
    highQuality:
      rtsp: /cam/realmonitor?channel=29&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=29&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=29&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=29&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:fb:78:8e:91:ee
    ports:
      server: 8110
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel30
    uuid: 8eb5eeec-4a5e-47bb-8410-67ed86b3d26e
    highQuality:
      rtsp: /cam/realmonitor?channel=30&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=30&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=30&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=30&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:0d:ba:c1:63:b2
    ports:
      server: 8111
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel31
    uuid: b1891b24-9802-494a-bbc6-cffbb33c7e6c
    highQuality:
      rtsp: /cam/realmonitor?channel=31&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=31&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=31&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=31&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:91:59:0f:42:45
    ports:
      server: 8112
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel32
    uuid: 69df9b02-a9fa-4aef-8ea9-6eb57b451812
    highQuality:
      rtsp: /cam/realmonitor?channel=32&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=32&subtype=1
      width: 704
      height: 480
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=32&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=32&subtype=0
      width: 0
      height: 0
      framerate: 0
      bitrate: 0
      quality: 1
    target:
      hostname: 192.168.6.204
      ports:
        rtsp: 554
        snapshot: 80
</file>

<file path="setup-network-192.168.6.202.sh">
#!/bin/bash

# Network setup script for ONVIF virtual interfaces
# Generated for NVR: 192.168.6.202
# Generated on: 2025-04-17T14:25:21.159Z

# Get the physical interface name (look for the interface with the host IP)
HOST_IP=$(hostname -I | awk '{print $1}')
PHYS_IFACE=$(ip -o addr show | grep "$HOST_IP" | grep -v macvlan | awk '{print $2}' | cut -d':' -f1)
if [ -z "$PHYS_IFACE" ]; then
    echo "Error: Could not determine physical interface"
    exit 1
fi
echo "Using physical interface: $PHYS_IFACE"
# Configure ARP settings for physical interface
echo "Configuring ARP settings for physical interface $PHYS_IFACE..."
echo 1 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_announce

# Parse command line arguments
USE_DHCP=false # Default to static IPs
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --dhcp) USE_DHCP=true ;;
        *) echo "Unknown parameter: $1"; exit 1 ;;
    esac
    shift
done

# Check if dhclient is installed when using DHCP
if [ "$USE_DHCP" = true ] && ! command -v dhclient &> /dev/null; then
    echo "dhclient not found. Please install it with:"
    echo "  sudo apt-get install isc-dhcp-client    (for Debian/Ubuntu)"
    echo "  sudo yum install dhcp-client            (for CentOS/RHEL)"
    echo "Or use --static to assign static IPs instead."
    exit 1
fi

# Create a mapping file for MAC to interface name and IP
cat > mac_to_interface.txt << EOF
02:cc:00:d2:a6:c3 onv1_a6c3 192.168.6.3
02:c9:54:34:84:df onv2_84df 192.168.6.4
02:90:67:6b:60:43 onv3_6043 192.168.6.5
02:6f:ea:dc:25:89 onv4_2589 192.168.6.6
02:27:2b:64:d0:20 onv5_d020 192.168.6.7
02:92:d2:00:e6:ae onv6_e6ae 192.168.6.8
02:37:e5:a8:a6:04 onv7_a604 192.168.6.9
02:bc:83:1a:dc:a0 onv8_dca0 192.168.6.10
02:eb:6c:a6:68:8a onv9_688a 192.168.6.11
02:39:b8:15:6a:af onv10_6aaf 192.168.6.12
02:c8:5b:d2:94:9e onv11_949e 192.168.6.13
02:ff:43:d3:a5:6d onv12_a56d 192.168.6.14
02:50:e1:ff:17:7e onv13_177e 192.168.6.15
02:6e:97:6b:39:e3 onv14_39e3 192.168.6.16
02:f8:26:39:03:d0 onv15_03d0 192.168.6.17
02:80:c4:d4:58:00 onv16_5800 192.168.6.18
EOF

# Remove any existing interfaces first
ip link show onv1_a6c3 > /dev/null 2>&1 && ip link delete onv1_a6c3
ip link show onv2_84df > /dev/null 2>&1 && ip link delete onv2_84df
ip link show onv3_6043 > /dev/null 2>&1 && ip link delete onv3_6043
ip link show onv4_2589 > /dev/null 2>&1 && ip link delete onv4_2589
ip link show onv5_d020 > /dev/null 2>&1 && ip link delete onv5_d020
ip link show onv6_e6ae > /dev/null 2>&1 && ip link delete onv6_e6ae
ip link show onv7_a604 > /dev/null 2>&1 && ip link delete onv7_a604
ip link show onv8_dca0 > /dev/null 2>&1 && ip link delete onv8_dca0
ip link show onv9_688a > /dev/null 2>&1 && ip link delete onv9_688a
ip link show onv10_6aaf > /dev/null 2>&1 && ip link delete onv10_6aaf
ip link show onv11_949e > /dev/null 2>&1 && ip link delete onv11_949e
ip link show onv12_a56d > /dev/null 2>&1 && ip link delete onv12_a56d
ip link show onv13_177e > /dev/null 2>&1 && ip link delete onv13_177e
ip link show onv14_39e3 > /dev/null 2>&1 && ip link delete onv14_39e3
ip link show onv15_03d0 > /dev/null 2>&1 && ip link delete onv15_03d0
ip link show onv16_5800 > /dev/null 2>&1 && ip link delete onv16_5800

# Create new virtual interfaces
echo "Creating macvlan interface onv1_a6c3..."
ip link add onv1_a6c3 link $PHYS_IFACE address 02:cc:00:d2:a6:c3 type macvlan mode bridge
ip link set onv1_a6c3 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv1_a6c3 via DHCP..."
    dhclient -v onv1_a6c3 &
else
    echo "Assigning static IP 192.168.6.3/24 to onv1_a6c3..."
    ip addr add 192.168.6.3/24 dev onv1_a6c3
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv1_a6c3/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv1_a6c3/arp_announce

echo "Creating macvlan interface onv2_84df..."
ip link add onv2_84df link $PHYS_IFACE address 02:c9:54:34:84:df type macvlan mode bridge
ip link set onv2_84df up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv2_84df via DHCP..."
    dhclient -v onv2_84df &
else
    echo "Assigning static IP 192.168.6.4/24 to onv2_84df..."
    ip addr add 192.168.6.4/24 dev onv2_84df
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv2_84df/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv2_84df/arp_announce

echo "Creating macvlan interface onv3_6043..."
ip link add onv3_6043 link $PHYS_IFACE address 02:90:67:6b:60:43 type macvlan mode bridge
ip link set onv3_6043 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv3_6043 via DHCP..."
    dhclient -v onv3_6043 &
else
    echo "Assigning static IP 192.168.6.5/24 to onv3_6043..."
    ip addr add 192.168.6.5/24 dev onv3_6043
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv3_6043/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv3_6043/arp_announce

echo "Creating macvlan interface onv4_2589..."
ip link add onv4_2589 link $PHYS_IFACE address 02:6f:ea:dc:25:89 type macvlan mode bridge
ip link set onv4_2589 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv4_2589 via DHCP..."
    dhclient -v onv4_2589 &
else
    echo "Assigning static IP 192.168.6.6/24 to onv4_2589..."
    ip addr add 192.168.6.6/24 dev onv4_2589
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv4_2589/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv4_2589/arp_announce

echo "Creating macvlan interface onv5_d020..."
ip link add onv5_d020 link $PHYS_IFACE address 02:27:2b:64:d0:20 type macvlan mode bridge
ip link set onv5_d020 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv5_d020 via DHCP..."
    dhclient -v onv5_d020 &
else
    echo "Assigning static IP 192.168.6.7/24 to onv5_d020..."
    ip addr add 192.168.6.7/24 dev onv5_d020
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv5_d020/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv5_d020/arp_announce

echo "Creating macvlan interface onv6_e6ae..."
ip link add onv6_e6ae link $PHYS_IFACE address 02:92:d2:00:e6:ae type macvlan mode bridge
ip link set onv6_e6ae up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv6_e6ae via DHCP..."
    dhclient -v onv6_e6ae &
else
    echo "Assigning static IP 192.168.6.8/24 to onv6_e6ae..."
    ip addr add 192.168.6.8/24 dev onv6_e6ae
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv6_e6ae/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv6_e6ae/arp_announce

echo "Creating macvlan interface onv7_a604..."
ip link add onv7_a604 link $PHYS_IFACE address 02:37:e5:a8:a6:04 type macvlan mode bridge
ip link set onv7_a604 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv7_a604 via DHCP..."
    dhclient -v onv7_a604 &
else
    echo "Assigning static IP 192.168.6.9/24 to onv7_a604..."
    ip addr add 192.168.6.9/24 dev onv7_a604
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv7_a604/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv7_a604/arp_announce

echo "Creating macvlan interface onv8_dca0..."
ip link add onv8_dca0 link $PHYS_IFACE address 02:bc:83:1a:dc:a0 type macvlan mode bridge
ip link set onv8_dca0 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv8_dca0 via DHCP..."
    dhclient -v onv8_dca0 &
else
    echo "Assigning static IP 192.168.6.10/24 to onv8_dca0..."
    ip addr add 192.168.6.10/24 dev onv8_dca0
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv8_dca0/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv8_dca0/arp_announce

echo "Creating macvlan interface onv9_688a..."
ip link add onv9_688a link $PHYS_IFACE address 02:eb:6c:a6:68:8a type macvlan mode bridge
ip link set onv9_688a up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv9_688a via DHCP..."
    dhclient -v onv9_688a &
else
    echo "Assigning static IP 192.168.6.11/24 to onv9_688a..."
    ip addr add 192.168.6.11/24 dev onv9_688a
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv9_688a/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv9_688a/arp_announce

echo "Creating macvlan interface onv10_6aaf..."
ip link add onv10_6aaf link $PHYS_IFACE address 02:39:b8:15:6a:af type macvlan mode bridge
ip link set onv10_6aaf up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv10_6aaf via DHCP..."
    dhclient -v onv10_6aaf &
else
    echo "Assigning static IP 192.168.6.12/24 to onv10_6aaf..."
    ip addr add 192.168.6.12/24 dev onv10_6aaf
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv10_6aaf/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv10_6aaf/arp_announce

echo "Creating macvlan interface onv11_949e..."
ip link add onv11_949e link $PHYS_IFACE address 02:c8:5b:d2:94:9e type macvlan mode bridge
ip link set onv11_949e up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv11_949e via DHCP..."
    dhclient -v onv11_949e &
else
    echo "Assigning static IP 192.168.6.13/24 to onv11_949e..."
    ip addr add 192.168.6.13/24 dev onv11_949e
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv11_949e/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv11_949e/arp_announce

echo "Creating macvlan interface onv12_a56d..."
ip link add onv12_a56d link $PHYS_IFACE address 02:ff:43:d3:a5:6d type macvlan mode bridge
ip link set onv12_a56d up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv12_a56d via DHCP..."
    dhclient -v onv12_a56d &
else
    echo "Assigning static IP 192.168.6.14/24 to onv12_a56d..."
    ip addr add 192.168.6.14/24 dev onv12_a56d
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv12_a56d/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv12_a56d/arp_announce

echo "Creating macvlan interface onv13_177e..."
ip link add onv13_177e link $PHYS_IFACE address 02:50:e1:ff:17:7e type macvlan mode bridge
ip link set onv13_177e up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv13_177e via DHCP..."
    dhclient -v onv13_177e &
else
    echo "Assigning static IP 192.168.6.15/24 to onv13_177e..."
    ip addr add 192.168.6.15/24 dev onv13_177e
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv13_177e/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv13_177e/arp_announce

echo "Creating macvlan interface onv14_39e3..."
ip link add onv14_39e3 link $PHYS_IFACE address 02:6e:97:6b:39:e3 type macvlan mode bridge
ip link set onv14_39e3 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv14_39e3 via DHCP..."
    dhclient -v onv14_39e3 &
else
    echo "Assigning static IP 192.168.6.16/24 to onv14_39e3..."
    ip addr add 192.168.6.16/24 dev onv14_39e3
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv14_39e3/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv14_39e3/arp_announce

echo "Creating macvlan interface onv15_03d0..."
ip link add onv15_03d0 link $PHYS_IFACE address 02:f8:26:39:03:d0 type macvlan mode bridge
ip link set onv15_03d0 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv15_03d0 via DHCP..."
    dhclient -v onv15_03d0 &
else
    echo "Assigning static IP 192.168.6.17/24 to onv15_03d0..."
    ip addr add 192.168.6.17/24 dev onv15_03d0
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv15_03d0/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv15_03d0/arp_announce

echo "Creating macvlan interface onv16_5800..."
ip link add onv16_5800 link $PHYS_IFACE address 02:80:c4:d4:58:00 type macvlan mode bridge
ip link set onv16_5800 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv16_5800 via DHCP..."
    dhclient -v onv16_5800 &
else
    echo "Assigning static IP 192.168.6.18/24 to onv16_5800..."
    ip addr add 192.168.6.18/24 dev onv16_5800
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv16_5800/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv16_5800/arp_announce

# Wait for IP assignment to complete and display IP addresses
sleep 3
echo "Virtual interface IP addresses:"
ip -4 addr show | grep -A 2 "onv" | grep -v "valid_lft"

echo "Static IP assignment is the default. To use DHCP instead, run: sudo $0 --dhcp"
</file>

<file path="setup-network-192.168.6.204.sh">
#!/bin/bash

# Network setup script for ONVIF virtual interfaces
# Generated for NVR: 192.168.6.204
# Generated on: 2025-04-17T14:25:39.619Z

# Get the physical interface name (look for the interface with the host IP)
HOST_IP=$(hostname -I | awk '{print $1}')
PHYS_IFACE=$(ip -o addr show | grep "$HOST_IP" | grep -v macvlan | awk '{print $2}' | cut -d':' -f1)
if [ -z "$PHYS_IFACE" ]; then
    echo "Error: Could not determine physical interface"
    exit 1
fi
echo "Using physical interface: $PHYS_IFACE"
# Configure ARP settings for physical interface
echo "Configuring ARP settings for physical interface $PHYS_IFACE..."
echo 1 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_announce

# Parse command line arguments
USE_DHCP=false # Default to static IPs
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --dhcp) USE_DHCP=true ;;
        *) echo "Unknown parameter: $1"; exit 1 ;;
    esac
    shift
done

# Check if dhclient is installed when using DHCP
if [ "$USE_DHCP" = true ] && ! command -v dhclient &> /dev/null; then
    echo "dhclient not found. Please install it with:"
    echo "  sudo apt-get install isc-dhcp-client    (for Debian/Ubuntu)"
    echo "  sudo yum install dhcp-client            (for CentOS/RHEL)"
    echo "Or use --static to assign static IPs instead."
    exit 1
fi

# Create a mapping file for MAC to interface name and IP
cat > mac_to_interface.txt << EOF
02:6c:7c:51:4a:6c onv1_4a6c 192.168.6.3
02:b5:d3:59:6d:bd onv2_6dbd 192.168.6.4
02:4c:f8:89:fa:84 onv3_fa84 192.168.6.5
02:82:f7:19:d6:f1 onv4_d6f1 192.168.6.6
02:7e:89:ae:44:e8 onv5_44e8 192.168.6.7
02:a0:63:ad:b1:b3 onv6_b1b3 192.168.6.8
02:e1:6c:9f:03:bc onv7_03bc 192.168.6.9
02:8e:6d:14:07:3c onv8_073c 192.168.6.10
02:b0:6e:26:a2:e4 onv9_a2e4 192.168.6.11
02:46:2f:98:d7:54 onv10_d754 192.168.6.12
02:3a:1e:84:f3:c2 onv11_f3c2 192.168.6.13
02:a3:bc:f6:98:a9 onv12_98a9 192.168.6.14
02:24:14:61:07:0d onv13_070d 192.168.6.15
02:a3:ae:c0:be:3c onv14_be3c 192.168.6.16
02:b0:46:fe:30:9d onv15_309d 192.168.6.17
02:b6:10:34:57:93 onv16_5793 192.168.6.18
02:bb:98:b9:82:19 onv17_8219 192.168.6.19
02:24:71:07:ae:ac onv18_aeac 192.168.6.20
02:90:98:73:cd:28 onv19_cd28 192.168.6.21
02:6a:9d:c1:d5:73 onv20_d573 192.168.6.22
02:e2:45:72:05:71 onv21_0571 192.168.6.23
02:50:e8:40:c0:87 onv22_c087 192.168.6.24
02:98:a9:71:83:b6 onv23_83b6 192.168.6.25
02:3b:8a:2e:56:ea onv24_56ea 192.168.6.26
02:c1:b2:86:21:71 onv25_2171 192.168.6.27
02:02:f6:54:16:69 onv26_1669 192.168.6.28
02:bd:6c:9e:96:16 onv27_9616 192.168.6.29
02:0f:b3:45:69:5c onv28_695c 192.168.6.30
02:8a:8f:f6:b8:34 onv29_b834 192.168.6.31
02:fb:78:8e:91:ee onv30_91ee 192.168.6.32
02:0d:ba:c1:63:b2 onv31_63b2 192.168.6.33
02:91:59:0f:42:45 onv32_4245 192.168.6.34
EOF

# Remove any existing interfaces first
ip link show onv1_4a6c > /dev/null 2>&1 && ip link delete onv1_4a6c
ip link show onv2_6dbd > /dev/null 2>&1 && ip link delete onv2_6dbd
ip link show onv3_fa84 > /dev/null 2>&1 && ip link delete onv3_fa84
ip link show onv4_d6f1 > /dev/null 2>&1 && ip link delete onv4_d6f1
ip link show onv5_44e8 > /dev/null 2>&1 && ip link delete onv5_44e8
ip link show onv6_b1b3 > /dev/null 2>&1 && ip link delete onv6_b1b3
ip link show onv7_03bc > /dev/null 2>&1 && ip link delete onv7_03bc
ip link show onv8_073c > /dev/null 2>&1 && ip link delete onv8_073c
ip link show onv9_a2e4 > /dev/null 2>&1 && ip link delete onv9_a2e4
ip link show onv10_d754 > /dev/null 2>&1 && ip link delete onv10_d754
ip link show onv11_f3c2 > /dev/null 2>&1 && ip link delete onv11_f3c2
ip link show onv12_98a9 > /dev/null 2>&1 && ip link delete onv12_98a9
ip link show onv13_070d > /dev/null 2>&1 && ip link delete onv13_070d
ip link show onv14_be3c > /dev/null 2>&1 && ip link delete onv14_be3c
ip link show onv15_309d > /dev/null 2>&1 && ip link delete onv15_309d
ip link show onv16_5793 > /dev/null 2>&1 && ip link delete onv16_5793
ip link show onv17_8219 > /dev/null 2>&1 && ip link delete onv17_8219
ip link show onv18_aeac > /dev/null 2>&1 && ip link delete onv18_aeac
ip link show onv19_cd28 > /dev/null 2>&1 && ip link delete onv19_cd28
ip link show onv20_d573 > /dev/null 2>&1 && ip link delete onv20_d573
ip link show onv21_0571 > /dev/null 2>&1 && ip link delete onv21_0571
ip link show onv22_c087 > /dev/null 2>&1 && ip link delete onv22_c087
ip link show onv23_83b6 > /dev/null 2>&1 && ip link delete onv23_83b6
ip link show onv24_56ea > /dev/null 2>&1 && ip link delete onv24_56ea
ip link show onv25_2171 > /dev/null 2>&1 && ip link delete onv25_2171
ip link show onv26_1669 > /dev/null 2>&1 && ip link delete onv26_1669
ip link show onv27_9616 > /dev/null 2>&1 && ip link delete onv27_9616
ip link show onv28_695c > /dev/null 2>&1 && ip link delete onv28_695c
ip link show onv29_b834 > /dev/null 2>&1 && ip link delete onv29_b834
ip link show onv30_91ee > /dev/null 2>&1 && ip link delete onv30_91ee
ip link show onv31_63b2 > /dev/null 2>&1 && ip link delete onv31_63b2
ip link show onv32_4245 > /dev/null 2>&1 && ip link delete onv32_4245

# Create new virtual interfaces
echo "Creating macvlan interface onv1_4a6c..."
ip link add onv1_4a6c link $PHYS_IFACE address 02:6c:7c:51:4a:6c type macvlan mode bridge
ip link set onv1_4a6c up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv1_4a6c via DHCP..."
    dhclient -v onv1_4a6c &
else
    echo "Assigning static IP 192.168.6.3/24 to onv1_4a6c..."
    ip addr add 192.168.6.3/24 dev onv1_4a6c
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv1_4a6c/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv1_4a6c/arp_announce

echo "Creating macvlan interface onv2_6dbd..."
ip link add onv2_6dbd link $PHYS_IFACE address 02:b5:d3:59:6d:bd type macvlan mode bridge
ip link set onv2_6dbd up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv2_6dbd via DHCP..."
    dhclient -v onv2_6dbd &
else
    echo "Assigning static IP 192.168.6.4/24 to onv2_6dbd..."
    ip addr add 192.168.6.4/24 dev onv2_6dbd
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv2_6dbd/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv2_6dbd/arp_announce

echo "Creating macvlan interface onv3_fa84..."
ip link add onv3_fa84 link $PHYS_IFACE address 02:4c:f8:89:fa:84 type macvlan mode bridge
ip link set onv3_fa84 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv3_fa84 via DHCP..."
    dhclient -v onv3_fa84 &
else
    echo "Assigning static IP 192.168.6.5/24 to onv3_fa84..."
    ip addr add 192.168.6.5/24 dev onv3_fa84
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv3_fa84/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv3_fa84/arp_announce

echo "Creating macvlan interface onv4_d6f1..."
ip link add onv4_d6f1 link $PHYS_IFACE address 02:82:f7:19:d6:f1 type macvlan mode bridge
ip link set onv4_d6f1 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv4_d6f1 via DHCP..."
    dhclient -v onv4_d6f1 &
else
    echo "Assigning static IP 192.168.6.6/24 to onv4_d6f1..."
    ip addr add 192.168.6.6/24 dev onv4_d6f1
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv4_d6f1/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv4_d6f1/arp_announce

echo "Creating macvlan interface onv5_44e8..."
ip link add onv5_44e8 link $PHYS_IFACE address 02:7e:89:ae:44:e8 type macvlan mode bridge
ip link set onv5_44e8 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv5_44e8 via DHCP..."
    dhclient -v onv5_44e8 &
else
    echo "Assigning static IP 192.168.6.7/24 to onv5_44e8..."
    ip addr add 192.168.6.7/24 dev onv5_44e8
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv5_44e8/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv5_44e8/arp_announce

echo "Creating macvlan interface onv6_b1b3..."
ip link add onv6_b1b3 link $PHYS_IFACE address 02:a0:63:ad:b1:b3 type macvlan mode bridge
ip link set onv6_b1b3 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv6_b1b3 via DHCP..."
    dhclient -v onv6_b1b3 &
else
    echo "Assigning static IP 192.168.6.8/24 to onv6_b1b3..."
    ip addr add 192.168.6.8/24 dev onv6_b1b3
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv6_b1b3/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv6_b1b3/arp_announce

echo "Creating macvlan interface onv7_03bc..."
ip link add onv7_03bc link $PHYS_IFACE address 02:e1:6c:9f:03:bc type macvlan mode bridge
ip link set onv7_03bc up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv7_03bc via DHCP..."
    dhclient -v onv7_03bc &
else
    echo "Assigning static IP 192.168.6.9/24 to onv7_03bc..."
    ip addr add 192.168.6.9/24 dev onv7_03bc
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv7_03bc/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv7_03bc/arp_announce

echo "Creating macvlan interface onv8_073c..."
ip link add onv8_073c link $PHYS_IFACE address 02:8e:6d:14:07:3c type macvlan mode bridge
ip link set onv8_073c up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv8_073c via DHCP..."
    dhclient -v onv8_073c &
else
    echo "Assigning static IP 192.168.6.10/24 to onv8_073c..."
    ip addr add 192.168.6.10/24 dev onv8_073c
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv8_073c/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv8_073c/arp_announce

echo "Creating macvlan interface onv9_a2e4..."
ip link add onv9_a2e4 link $PHYS_IFACE address 02:b0:6e:26:a2:e4 type macvlan mode bridge
ip link set onv9_a2e4 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv9_a2e4 via DHCP..."
    dhclient -v onv9_a2e4 &
else
    echo "Assigning static IP 192.168.6.11/24 to onv9_a2e4..."
    ip addr add 192.168.6.11/24 dev onv9_a2e4
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv9_a2e4/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv9_a2e4/arp_announce

echo "Creating macvlan interface onv10_d754..."
ip link add onv10_d754 link $PHYS_IFACE address 02:46:2f:98:d7:54 type macvlan mode bridge
ip link set onv10_d754 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv10_d754 via DHCP..."
    dhclient -v onv10_d754 &
else
    echo "Assigning static IP 192.168.6.12/24 to onv10_d754..."
    ip addr add 192.168.6.12/24 dev onv10_d754
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv10_d754/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv10_d754/arp_announce

echo "Creating macvlan interface onv11_f3c2..."
ip link add onv11_f3c2 link $PHYS_IFACE address 02:3a:1e:84:f3:c2 type macvlan mode bridge
ip link set onv11_f3c2 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv11_f3c2 via DHCP..."
    dhclient -v onv11_f3c2 &
else
    echo "Assigning static IP 192.168.6.13/24 to onv11_f3c2..."
    ip addr add 192.168.6.13/24 dev onv11_f3c2
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv11_f3c2/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv11_f3c2/arp_announce

echo "Creating macvlan interface onv12_98a9..."
ip link add onv12_98a9 link $PHYS_IFACE address 02:a3:bc:f6:98:a9 type macvlan mode bridge
ip link set onv12_98a9 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv12_98a9 via DHCP..."
    dhclient -v onv12_98a9 &
else
    echo "Assigning static IP 192.168.6.14/24 to onv12_98a9..."
    ip addr add 192.168.6.14/24 dev onv12_98a9
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv12_98a9/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv12_98a9/arp_announce

echo "Creating macvlan interface onv13_070d..."
ip link add onv13_070d link $PHYS_IFACE address 02:24:14:61:07:0d type macvlan mode bridge
ip link set onv13_070d up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv13_070d via DHCP..."
    dhclient -v onv13_070d &
else
    echo "Assigning static IP 192.168.6.15/24 to onv13_070d..."
    ip addr add 192.168.6.15/24 dev onv13_070d
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv13_070d/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv13_070d/arp_announce

echo "Creating macvlan interface onv14_be3c..."
ip link add onv14_be3c link $PHYS_IFACE address 02:a3:ae:c0:be:3c type macvlan mode bridge
ip link set onv14_be3c up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv14_be3c via DHCP..."
    dhclient -v onv14_be3c &
else
    echo "Assigning static IP 192.168.6.16/24 to onv14_be3c..."
    ip addr add 192.168.6.16/24 dev onv14_be3c
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv14_be3c/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv14_be3c/arp_announce

echo "Creating macvlan interface onv15_309d..."
ip link add onv15_309d link $PHYS_IFACE address 02:b0:46:fe:30:9d type macvlan mode bridge
ip link set onv15_309d up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv15_309d via DHCP..."
    dhclient -v onv15_309d &
else
    echo "Assigning static IP 192.168.6.17/24 to onv15_309d..."
    ip addr add 192.168.6.17/24 dev onv15_309d
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv15_309d/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv15_309d/arp_announce

echo "Creating macvlan interface onv16_5793..."
ip link add onv16_5793 link $PHYS_IFACE address 02:b6:10:34:57:93 type macvlan mode bridge
ip link set onv16_5793 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv16_5793 via DHCP..."
    dhclient -v onv16_5793 &
else
    echo "Assigning static IP 192.168.6.18/24 to onv16_5793..."
    ip addr add 192.168.6.18/24 dev onv16_5793
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv16_5793/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv16_5793/arp_announce

echo "Creating macvlan interface onv17_8219..."
ip link add onv17_8219 link $PHYS_IFACE address 02:bb:98:b9:82:19 type macvlan mode bridge
ip link set onv17_8219 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv17_8219 via DHCP..."
    dhclient -v onv17_8219 &
else
    echo "Assigning static IP 192.168.6.19/24 to onv17_8219..."
    ip addr add 192.168.6.19/24 dev onv17_8219
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv17_8219/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv17_8219/arp_announce

echo "Creating macvlan interface onv18_aeac..."
ip link add onv18_aeac link $PHYS_IFACE address 02:24:71:07:ae:ac type macvlan mode bridge
ip link set onv18_aeac up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv18_aeac via DHCP..."
    dhclient -v onv18_aeac &
else
    echo "Assigning static IP 192.168.6.20/24 to onv18_aeac..."
    ip addr add 192.168.6.20/24 dev onv18_aeac
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv18_aeac/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv18_aeac/arp_announce

echo "Creating macvlan interface onv19_cd28..."
ip link add onv19_cd28 link $PHYS_IFACE address 02:90:98:73:cd:28 type macvlan mode bridge
ip link set onv19_cd28 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv19_cd28 via DHCP..."
    dhclient -v onv19_cd28 &
else
    echo "Assigning static IP 192.168.6.21/24 to onv19_cd28..."
    ip addr add 192.168.6.21/24 dev onv19_cd28
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv19_cd28/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv19_cd28/arp_announce

echo "Creating macvlan interface onv20_d573..."
ip link add onv20_d573 link $PHYS_IFACE address 02:6a:9d:c1:d5:73 type macvlan mode bridge
ip link set onv20_d573 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv20_d573 via DHCP..."
    dhclient -v onv20_d573 &
else
    echo "Assigning static IP 192.168.6.22/24 to onv20_d573..."
    ip addr add 192.168.6.22/24 dev onv20_d573
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv20_d573/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv20_d573/arp_announce

echo "Creating macvlan interface onv21_0571..."
ip link add onv21_0571 link $PHYS_IFACE address 02:e2:45:72:05:71 type macvlan mode bridge
ip link set onv21_0571 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv21_0571 via DHCP..."
    dhclient -v onv21_0571 &
else
    echo "Assigning static IP 192.168.6.23/24 to onv21_0571..."
    ip addr add 192.168.6.23/24 dev onv21_0571
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv21_0571/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv21_0571/arp_announce

echo "Creating macvlan interface onv22_c087..."
ip link add onv22_c087 link $PHYS_IFACE address 02:50:e8:40:c0:87 type macvlan mode bridge
ip link set onv22_c087 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv22_c087 via DHCP..."
    dhclient -v onv22_c087 &
else
    echo "Assigning static IP 192.168.6.24/24 to onv22_c087..."
    ip addr add 192.168.6.24/24 dev onv22_c087
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv22_c087/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv22_c087/arp_announce

echo "Creating macvlan interface onv23_83b6..."
ip link add onv23_83b6 link $PHYS_IFACE address 02:98:a9:71:83:b6 type macvlan mode bridge
ip link set onv23_83b6 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv23_83b6 via DHCP..."
    dhclient -v onv23_83b6 &
else
    echo "Assigning static IP 192.168.6.25/24 to onv23_83b6..."
    ip addr add 192.168.6.25/24 dev onv23_83b6
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv23_83b6/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv23_83b6/arp_announce

echo "Creating macvlan interface onv24_56ea..."
ip link add onv24_56ea link $PHYS_IFACE address 02:3b:8a:2e:56:ea type macvlan mode bridge
ip link set onv24_56ea up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv24_56ea via DHCP..."
    dhclient -v onv24_56ea &
else
    echo "Assigning static IP 192.168.6.26/24 to onv24_56ea..."
    ip addr add 192.168.6.26/24 dev onv24_56ea
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv24_56ea/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv24_56ea/arp_announce

echo "Creating macvlan interface onv25_2171..."
ip link add onv25_2171 link $PHYS_IFACE address 02:c1:b2:86:21:71 type macvlan mode bridge
ip link set onv25_2171 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv25_2171 via DHCP..."
    dhclient -v onv25_2171 &
else
    echo "Assigning static IP 192.168.6.27/24 to onv25_2171..."
    ip addr add 192.168.6.27/24 dev onv25_2171
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv25_2171/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv25_2171/arp_announce

echo "Creating macvlan interface onv26_1669..."
ip link add onv26_1669 link $PHYS_IFACE address 02:02:f6:54:16:69 type macvlan mode bridge
ip link set onv26_1669 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv26_1669 via DHCP..."
    dhclient -v onv26_1669 &
else
    echo "Assigning static IP 192.168.6.28/24 to onv26_1669..."
    ip addr add 192.168.6.28/24 dev onv26_1669
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv26_1669/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv26_1669/arp_announce

echo "Creating macvlan interface onv27_9616..."
ip link add onv27_9616 link $PHYS_IFACE address 02:bd:6c:9e:96:16 type macvlan mode bridge
ip link set onv27_9616 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv27_9616 via DHCP..."
    dhclient -v onv27_9616 &
else
    echo "Assigning static IP 192.168.6.29/24 to onv27_9616..."
    ip addr add 192.168.6.29/24 dev onv27_9616
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv27_9616/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv27_9616/arp_announce

echo "Creating macvlan interface onv28_695c..."
ip link add onv28_695c link $PHYS_IFACE address 02:0f:b3:45:69:5c type macvlan mode bridge
ip link set onv28_695c up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv28_695c via DHCP..."
    dhclient -v onv28_695c &
else
    echo "Assigning static IP 192.168.6.30/24 to onv28_695c..."
    ip addr add 192.168.6.30/24 dev onv28_695c
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv28_695c/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv28_695c/arp_announce

echo "Creating macvlan interface onv29_b834..."
ip link add onv29_b834 link $PHYS_IFACE address 02:8a:8f:f6:b8:34 type macvlan mode bridge
ip link set onv29_b834 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv29_b834 via DHCP..."
    dhclient -v onv29_b834 &
else
    echo "Assigning static IP 192.168.6.31/24 to onv29_b834..."
    ip addr add 192.168.6.31/24 dev onv29_b834
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv29_b834/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv29_b834/arp_announce

echo "Creating macvlan interface onv30_91ee..."
ip link add onv30_91ee link $PHYS_IFACE address 02:fb:78:8e:91:ee type macvlan mode bridge
ip link set onv30_91ee up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv30_91ee via DHCP..."
    dhclient -v onv30_91ee &
else
    echo "Assigning static IP 192.168.6.32/24 to onv30_91ee..."
    ip addr add 192.168.6.32/24 dev onv30_91ee
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv30_91ee/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv30_91ee/arp_announce

echo "Creating macvlan interface onv31_63b2..."
ip link add onv31_63b2 link $PHYS_IFACE address 02:0d:ba:c1:63:b2 type macvlan mode bridge
ip link set onv31_63b2 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv31_63b2 via DHCP..."
    dhclient -v onv31_63b2 &
else
    echo "Assigning static IP 192.168.6.33/24 to onv31_63b2..."
    ip addr add 192.168.6.33/24 dev onv31_63b2
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv31_63b2/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv31_63b2/arp_announce

echo "Creating macvlan interface onv32_4245..."
ip link add onv32_4245 link $PHYS_IFACE address 02:91:59:0f:42:45 type macvlan mode bridge
ip link set onv32_4245 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv32_4245 via DHCP..."
    dhclient -v onv32_4245 &
else
    echo "Assigning static IP 192.168.6.34/24 to onv32_4245..."
    ip addr add 192.168.6.34/24 dev onv32_4245
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv32_4245/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv32_4245/arp_announce

# Wait for IP assignment to complete and display IP addresses
sleep 3
echo "Virtual interface IP addresses:"
ip -4 addr show | grep -A 2 "onv" | grep -v "valid_lft"

echo "Static IP assignment is the default. To use DHCP instead, run: sudo $0 --dhcp"
</file>

<file path="memory-bank/activeContext.md">
# ONVIF Server Active Context

## Current Focus
The project is fully operational after fixing both the critical startup issues:

1. First issue (resolved): `ReferenceError: OnvifServer is not defined`
2. Second issue (resolved): `Error: listen EADDRNOTAVAIL: address not available 192.168.6.48:8094`

The successful workflow sequence is:
1. Run enhanced network setup script (`setup-network-combined.sh`)
2. Start the ONVIF server (`node main.js config-combined.yaml`)

The server now starts without errors and all virtual cameras are operational.

## Recent Code Changes

### 1. WS-Discovery Disabling
- Modified `main.js` to disable WS-Discovery entirely
- Added error handling to UDP socket code in `src/onvif-server.js`
- Reason: Server crashed due to multiple instances binding to UDP port 3702

### 2. WSDL/XSD Vendoring
- Vendored WSDL/XSD files into `wsdl/vendor/`
- Corrected `schemaLocation` and `location` attributes in WSDL/XSD files
- Added `uri` option to `soap.listen` calls
- Corrected file extensions for schemas
- Reason: Cloudflare was blocking WSDL/XSD downloads

### 3. Dynamic Proxy Port Assignment
- Modified `main.js` to assign unique proxy ports per NVR
- Starts from base ports (8554/8580) and increments
- Reason: Port conflicts when running with multiple NVRs

### 4. IP Address Assignment Changes
- Modified code to use pre-calculated static IPs instead of MAC lookup
- Modified `OnvifServer` constructor to accept IP directly
- Removed `getIpAddressFromMac` function
- Reason: `os.networkInterfaces()` didn't report IPs immediately after script execution

### 5. Network Script Improvements
- Modified `generateNetworkScript` and `generateCombinedNetworkScript` to default to static IPs
- Removed `--dhcp` option from combined script
- Reason: Static IPs are more reliable for this use case

## Issues Resolved

### 1. ReferenceError in OnvifServer
The `ReferenceError: OnvifServer is not defined` has been fixed with the following changes:

1. **Fixed Class Definition**: Completely rewrote the `src/onvif-server.js` file to properly define the `OnvifServer` class with correct syntax.

2. **Updated Module Export Pattern**: Changed the export to properly export both the class and the factory function:
   ```javascript
   module.exports = {
       OnvifServer: OnvifServer,
       createServer: createServer
   };
   ```

3. **Cleaned up Code Structure**: Fixed issues with semicolons, missing function bodies, and incorrect nesting of code blocks that were causing syntax errors.

### 2. Network Interface Address Availability
The `Error: listen EADDRNOTAVAIL: address not available 192.168.6.48:8094` has been fixed with the following changes:

1. **Enhanced Network Script Generation**: Modified the `generateCombinedNetworkScript` function in `src/config-builder.js` to include robust verification steps:
   ```javascript
   // Helper function for interface verification
   script += `# Helper function to verify interface creation and IP assignment\n`;
   script += `verify_interface() {\n`;
   // ... verification logic with retries and status reporting
   ```

2. **Sequential Creation with Verification**: Each interface is now created and verified before moving to the next one:
   ```javascript
   // Verify interface creation and IP assignment
   script += `verify_interface ${interfaceName} ${staticIp}\n`;
   script += `if [ $? -ne 0 ]; then\n`;
   script += `    echo "WARNING: Interface ${interfaceName} or IP ${staticIp} verification failed. Manual check recommended."\n`;
   script += `fi\n\n`;
   ```

3. **Added Delays and Retry Logic**: To prevent race conditions in network configuration:
   ```javascript
   // Add a small delay between interface creations to prevent race conditions
   script += `sleep 0.1\n\n`;
   ```

## Next Steps

1. Deployment is now straightforward with the correct sequence:
   - Run the enhanced network setup script with root privileges:
     ```
     sudo ./setup-network-combined.sh
     ```
   - Start the ONVIF server:
     ```
     node main.js config-combined.yaml --debug
     ```

2. Port assignments for both NVRs are now working correctly:
   - NVR 192.168.6.201: RTSP=8554, Snapshot=8580
   - NVR 192.168.6.202: RTSP=8556, Snapshot=8581

3. Next steps for production use:
   - Create a systemd service for auto-startup
   - Attempt manual adoption of all cameras in UniFi Protect
   - Consider further error handling improvements

## Completed Tasks
- [x] Fix the `ReferenceError: OnvifServer is not defined` error
- [x] Verify server code starts (attempts to create virtual cameras)
- [x] Enhance network interface setup script with verification
- [x] Fix the `EADDRNOTAVAIL` error for interface 192.168.6.48
- [x] Document network interface setup requirements in SETUP-GUIDE.md
- [x] Create README.md with project overview
- [x] Create comprehensive memory bank documentation
</file>

<file path="memory-bank/productContext.md">
# ONVIF Server Product Context

## Purpose
The ONVIF server proxy exists to solve compatibility issues between Network Video Recorders (NVRs) like UniFi Protect and IP cameras that:
1. Don't support the ONVIF protocol natively
2. Have incomplete ONVIF implementations that prevent proper discovery/adoption
3. Need specific configuration to work with particular NVR systems

## Problem Space
- Many IP cameras use proprietary protocols instead of standard ONVIF
- NVRs like UniFi Protect expect standards-compliant ONVIF protocol support
- Direct camera-to-NVR communication often fails due to protocol mismatches
- Manual camera configuration is complex and time-consuming
- Multiple NVRs can cause port conflicts when trying to adopt cameras

## Solution Approach
The server acts as a middleware that:
1. Presents itself to the NVR as an ONVIF-compliant camera
2. Creates virtual network interfaces (macvlan) with unique MAC addresses for each camera
3. Handles ONVIF discovery, authentication, and service requests
4. Proxies RTSP video streams and snapshot requests to the actual cameras
5. Dynamically assigns ports to avoid conflicts when supporting multiple NVRs

## User Experience Goals
- Seamless camera adoption in UniFi Protect without manual configuration
- Reliable video streaming through the proxy
- Simple configuration generation through command-line tools
- Support for both high and low-quality video streams
- Multi-NVR support with a single server instance

## Limitations & Constraints
- Requires root access to create network interfaces
- Static IP assignment needed for reliable operation
- Network configuration must be re-applied after each system reboot
- Limited to cameras that support RTSP streaming
</file>

<file path="memory-bank/progress.md">
# ONVIF Server Progress

## Implemented & Working
1.  Basic ONVIF protocol implementation
   - Device service endpoints
   - Media service endpoints
   - Stream URI generation

2.  Configuration generation
   - Camera discovery and configuration extraction
   - YAML configuration file creation
   - Network setup script generation

3.  Network interface handling
   - MAC address generation
   - Virtual interface creation (macvlan)
   - Static IP assignment

4.  Multi-NVR support
   - Unique proxy port assignment
   - Combined configuration handling
   - Conflict avoidance mechanisms

5.  Error handling
   - Added error handling for UDP socket errors
   - Improved robustness against Cloudflare blocking
   - Better logging for troubleshooting

## Fixed Issues
1.  **EADDRINUSE Crash (WS-Discovery)**
   - Modified `main.js` to disable WS-Discovery entirely
   - Added error handling to UDP socket code

2.  **WSDL Fetching Errors**
   - Vendored required WSDL/XSD files locally
   - Corrected schema locations to use relative paths
   - Added URI context option to SOAP services
   - Fixed file extensions for schemas

3.  **Multi-NVR Proxy Port Conflicts**
   - Implemented dynamic port assignment
   - Track assigned ports per NVR
   - Incrementing from base ports to avoid conflicts

4.  **Static IP Assignment**
   - Modified network scripts to default to static IPs
   - Removed DHCP option from combined scripts
   - Improved interface naming for better identification

5.  **MAC Address IP Lookup Failure**
   - Changed to calculating expected IPs based on camera index
   - Modified constructor to accept IP directly
   - Removed dependency on `os.networkInterfaces()`

## Fixed Issues (Recent)
1.  **OnvifServer Reference Error**
   - Fixed class definition and export in `src/onvif-server.js`
   - Properly exported both class and factory function
   - Updated syntax and code structure to eliminate errors

2.  **Network Interface IP Assignment**
   - Enhanced `setup-network-combined.sh` with IP verification
   - Added robust retry logic for interface creation
   - Implemented sequential creation with status checking
   - Fixed IP assignment issue for interface 192.168.6.48

## Working & Verified
1.  **Server Startup** - FIXED!
   - Server now starts successfully with all interfaces
   - Properly assigns ports to different NVRs
   - All virtual interfaces created with correct IPs
   - No more EADDRNOTAVAIL errors

2.  **Camera Adoption in UniFi Protect**
   - Ready for testing with both NVRs
   - All virtual interfaces are properly configured
   - Required manual addition using IP addresses

## Ready for Production
1.  Fix the OnvifServer reference error - DONE!
2.  Verify server startup with combined configuration - DONE!
3.  Enhance network interface setup script - DONE!
4.  Fix EADDRNOTAVAIL errors - DONE!
5.  Create comprehensive documentation - DONE!
6.  Test camera adoption in UniFi Protect - READY FOR TESTING
7.  Consider creating a systemd service for auto-startup
8.  Add more verbose logging options for troubleshooting

## Known Limitations
1. Requires root access for network interface creation
2. Network setup must be run after each system reboot
3. No automatic camera discovery mechanism
4. Limited to cameras with RTSP streaming capability
</file>

<file path="memory-bank/projectbrief.md">
# ONVIF Server Project Brief

## Project Overview
This project implements a virtual ONVIF server that acts as a proxy between Network Video Recorders (NVRs) like UniFi Protect and IP cameras. The server simulates ONVIF protocol support for cameras that may not natively have it, allowing NVRs to discover and adopt these cameras.

## Core Objectives
1. Enable UniFi Protect and other NVRs to discover and adopt IP cameras through ONVIF protocol
2. Support multiple NVRs with unique configurations
3. Provide a reliable proxy mechanism for video streams (RTSP)
4. Enable consistent camera access through static IP configuration

## Key Components
- ONVIF protocol implementation using SOAP/WSDL
- Network interface configuration management (macvlan interfaces)
- Configuration generation for camera and server settings
- RTSP and snapshot stream proxying

## Success Criteria
- Successful camera discovery and adoption by UniFi Protect
- Stable video streaming through the proxy server
- Support for multiple NVRs without conflicts
- Proper static IP assignment and network interface setup

## Current Status
The server has been through multiple troubleshooting phases and many issues have been resolved, but there is a current critical issue preventing startup (ReferenceError with OnvifServer class).
</file>

<file path="memory-bank/systemPatterns.md">
# ONVIF Server System Patterns

## Architecture Patterns

### 1. Proxy Design Pattern
The entire system implements a proxy pattern where the ONVIF server acts as an intermediary between:
- **Client**: Network Video Recorder (NVR) like UniFi Protect
- **Service**: IP Camera with RTSP stream capability

The proxy intercepts ONVIF protocol requests, handles them appropriately, and forwards video stream requests.

### 2. Service-Oriented Architecture (SOA)
The system exposes SOAP web services that implement ONVIF protocols:
- **Device Service**: Handles device management functionality
- **Media Service**: Manages media streaming configuration

Each service exposes specific endpoints defined by the ONVIF WSDL specifications.

### 3. Factory Pattern
The `createServer` function in `onvif-server.js` acts as a factory, creating and configuring `OnvifServer` instances based on configuration parameters.

### 4. Configuration Builder Pattern
The `config-builder.js` implements a builder pattern that:
1. Queries actual cameras for their capabilities
2. Transforms this information into a structured configuration
3. Generates both individual and combined configurations

## Data Flow Patterns

### 1. Configuration Flow
```mermaid
graph TD
    A[User Input] --> B[createConfig]
    B --> C[Query Camera]
    C --> D[Generate Config]
    D --> E[Write YAML]
    D --> F[Generate Network Scripts]
```

### 2. Server Startup Flow
```mermaid
graph TD
    A[Read Config] --> B[Parse YAML]
    B --> C[Calculate Static IPs]
    C --> D[Assign Proxy Ports]
    D --> E[Create Server Instances]
    E --> F[Start SOAP Services]
    F --> G[Start TCP Proxies]
```

### 3. Request Handling Flow
```mermaid
graph TD
    A[NVR Request] --> B[SOAP Server]
    B --> C{Request Type}
    C -->|Device Info| D[Return Device Info]
    C -->|Media Info| E[Return Media Info]
    C -->|Stream URI| F[Return Proxied URI]
    NVR[NVR] --> |Connect to Stream| G[TCP Proxy]
    G --> |Forward Stream| H[Camera]
```

## Key Technical Decisions

### 1. Static IP Assignment
- Decision: Use static IP addresses for virtual interfaces
- Rationale: Ensures consistent addressing for NVR to connect to
- Implementation: Generated shell scripts with static IP calculations

### 2. Dynamic Port Assignment
- Decision: Dynamically assign proxy ports to avoid conflicts
- Rationale: Enables multiple NVRs to connect without port collisions
- Implementation: Port tracking in main.js with incremental assignment

### 3. MAC Address Generation
- Decision: Generate consistent MAC addresses based on NVR IP and camera ID
- Rationale: Ensures virtual interfaces have unique but deterministic MAC addresses
- Implementation: Hash-based generation in config-builder.js

### 4. WSDL Vendoring
- Decision: Vendor/include WSDL/XSD files locally instead of fetching remotely
- Rationale: Avoids dependency on external resources, prevents blocking by Cloudflare
- Implementation: Local copies in wsdl/vendor/ with corrected relative paths

## Error Handling Patterns

### 1. Graceful Degradation
- System attempts to continue operation when parts fail
- Example: UDP discovery errors don't prevent core ONVIF functionality

### 2. Structured Logging
- Consistent logging pattern for troubleshooting
- Debug mode toggles verbose logging

## Current Implementation Challenges

### 1. OnvifServer Reference Issue
- The current critical issue stems from a reference problem with the OnvifServer class
- Likely related to class definition or module export pattern

### 2. Network Interface Management
- Network interfaces require root access and may need recreation after system restart
- Current pattern requires manual intervention to run setup scripts
</file>

<file path="memory-bank/techContext.md">
# ONVIF Server Technical Context

## Technology Stack
- **Node.js**: Core runtime environment
- **SOAP/WSDL**: Protocol implementation for ONVIF
- **node-tcp-proxy**: For proxying TCP streams (RTSP)
- **YAML**: Configuration file format
- **Linux networking**: For virtual network interface creation (macvlan)

## Core Dependencies
- `soap`: SOAP protocol implementation
- `node-tcp-proxy`: TCP proxying
- `argparse`: Command-line argument parsing
- `yaml`: YAML parsing and generation
- `simple-node-logger`: Logging functionality
- `node-uuid`: UUID generation for device identifiers
- `xml2js`: XML parsing for ONVIF messages

## System Requirements
- Linux operating system (macvlan support)
- Root privileges for network interface creation
- Node.js runtime
- Network connectivity between proxy server, cameras, and NVRs

## Development Setup
- Standard Node.js development environment
- Access to ONVIF WSDL/XSD specifications (vendored in project)
- Testing requires actual camera and NVR hardware

## Technical Constraints
- ONVIF compatibility limited to core features (Device and Media services)
- Requires static IP addressing for reliable operation
- Network interface creation requires root access
- TCP proxy connections may experience higher latency than direct connections

## Architecture Overview
1. **Configuration Layer**: Handles config file generation and parsing
   - `src/config-builder.js`: Creates configuration from ONVIF camera responses
   - YAML files store configuration for cameras and NVRs

2. **Network Layer**: Manages virtual network interfaces
   - Generated shell scripts create macvlan interfaces
   - Static IP assignment for predictable addressing

3. **ONVIF Protocol Layer**: Implements camera simulation
   - `src/onvif-server.js`: Core ONVIF protocol implementation
   - Handles device service and media service SOAP requests

4. **Proxy Layer**: Routes video traffic
   - TCP proxy for RTSP and HTTP (snapshot) traffic
   - Dynamic port assignment to avoid conflicts

## External Integration Points
- **UniFi Protect NVR**: Primary consumer of ONVIF services
- **IP Cameras**: Source of RTSP streams being proxied
- **Network Infrastructure**: Required for routing between components
</file>

<file path="wsdl/vendor/b-2.xsd">
<?xml version="1.0" encoding="UTF-8"?>
<!-- 

OASIS takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on OASIS's procedures with respect to rights in OASIS specifications can be found at the OASIS website. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementors or users of this specification, can be obtained from the OASIS Executive Director.

OASIS invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights which may cover technology that may be required to implement this specification. Please address the information to the OASIS Executive Director.

Copyright (C) OASIS Open (2004-2006). All Rights Reserved.

This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to OASIS, except as needed for the purpose of developing OASIS specifications, in which case the procedures for copyrights defined in the OASIS Intellectual Property Rights document must be followed, or as required to translate it into languages other than English. 

The limited permissions granted above are perpetual and will not be revoked by OASIS or its successors or assigns. 

This document and the information contained herein is provided on an "AS IS" basis and OASIS DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

-->

<xsd:schema 
  targetNamespace="http://docs.oasis-open.org/wsn/b-2"   
  xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2"
  xmlns:wsa="http://www.w3.org/2005/08/addressing"
  xmlns:wsrf-bf="http://docs.oasis-open.org/wsrf/bf-2"
  xmlns:wstop="http://docs.oasis-open.org/wsn/t-1"
  xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  elementFormDefault="qualified"  attributeFormDefault="unqualified">

<!-- ======================== Imports  ============================ -->
  
  <xsd:import namespace="http://www.w3.org/2005/08/addressing"
              schemaLocation="http://www.w3.org/2005/08/addressing/ws-addr.xsd" 
  />

  <xsd:import namespace="http://docs.oasis-open.org/wsrf/bf-2"
              schemaLocation="http://docs.oasis-open.org/wsrf/bf-2.xsd" 
  />
  <xsd:import namespace="http://docs.oasis-open.org/wsn/t-1"
              schemaLocation="http://docs.oasis-open.org/wsn/t-1.xsd" 
  />
  
<!-- ===================== Misc. Helper Types ===================== -->

  <xsd:complexType name="QueryExpressionType" mixed="true">
    <xsd:sequence>
      <xsd:any minOccurs="0" maxOccurs="1" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="Dialect" type="xsd:anyURI" use="required"/>
  </xsd:complexType>

  <xsd:complexType name="TopicExpressionType" mixed="true">
    <xsd:sequence>
      <xsd:any minOccurs="0" maxOccurs="1" processContents="lax" />
    </xsd:sequence>
    <xsd:attribute name="Dialect" type="xsd:anyURI" use="required" />
    <xsd:anyAttribute/>
  </xsd:complexType>

  <xsd:complexType name="FilterType">
    <xsd:sequence>
      <xsd:any minOccurs="0" maxOccurs="unbounded"/>
    </xsd:sequence>
  </xsd:complexType>

  <xsd:complexType name="SubscriptionPolicyType">
    <xsd:sequence>
      <xsd:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
    </xsd:sequence>
  </xsd:complexType>

<!-- =============== Resource Property Related  =================== -->
<!-- ======== Resource Properties for NotificationProducer ======== -->
  <xsd:element name="TopicExpression" type="wsnt:TopicExpressionType"/>
  <xsd:element name="FixedTopicSet" type="xsd:boolean" default="true"/>
  <xsd:element name="TopicExpressionDialect" type="xsd:anyURI"/>
              
  <xsd:element name="NotificationProducerRP">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref="wsnt:TopicExpression"        
                     minOccurs="0" maxOccurs="unbounded" />
        <xsd:element ref="wsnt:FixedTopicSet"        
                     minOccurs="0" maxOccurs="1" />
        <xsd:element ref="wsnt:TopicExpressionDialect"
                     minOccurs="0" maxOccurs="unbounded" />
        <xsd:element ref="wstop:TopicSet"
                     minOccurs="0" maxOccurs="1" />
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

<!-- ======== Resource Properties for SubscriptionManager ========= -->       
  <xsd:element name="ConsumerReference" 
               type="wsa:EndpointReferenceType" />
  <xsd:element name="Filter" type="wsnt:FilterType" />
  <xsd:element name="SubscriptionPolicy"                                                                                                                                                                   		      type="wsnt:SubscriptionPolicyType" />


  <xsd:element name="CreationTime" type="xsd:dateTime" />
  
  <xsd:element name="SubscriptionManagerRP" >
    <xsd:complexType>
      <xsd:sequence>
         <xsd:element ref="wsnt:ConsumerReference"        
                      minOccurs="1" maxOccurs="1" />
         <xsd:element ref="wsnt:Filter"
                      minOccurs="0" maxOccurs="1" />
         <xsd:element ref="wsnt:SubscriptionPolicy" 
                      minOccurs="0" maxOccurs="1" />
         <xsd:element ref="wsnt:CreationTime" 
                      minOccurs="0" maxOccurs="1" />
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

<!-- ================= Notification Metadata  ===================== -->
  <xsd:element name="SubscriptionReference" 
               type="wsa:EndpointReferenceType" />
  <xsd:element name="Topic" 
               type="wsnt:TopicExpressionType" />
  <xsd:element name="ProducerReference" 
               type="wsa:EndpointReferenceType" />

<!-- ================== Message Helper Types  ===================== -->
  <xsd:complexType name="NotificationMessageHolderType" >
    <xsd:sequence>
      <xsd:element ref="wsnt:SubscriptionReference" 
                   minOccurs="0" maxOccurs="1" />
      <xsd:element ref="wsnt:Topic" 
                   minOccurs="0" maxOccurs="1" />
      <xsd:element ref="wsnt:ProducerReference" 
                   minOccurs="0" maxOccurs="1" />
      <xsd:element name="Message">
        <xsd:complexType>
          <xsd:sequence>
            <xsd:any namespace="##any" processContents="lax"
                     minOccurs="1" maxOccurs="1"/>
          </xsd:sequence>
        </xsd:complexType>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
  <xsd:element name="NotificationMessage"
               type="wsnt:NotificationMessageHolderType"/>

<!-- ========== Message Types for NotificationConsumer  =========== -->
  <xsd:element name="Notify" >
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref="wsnt:NotificationMessage"
                     minOccurs="1" maxOccurs="unbounded" />
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

<!-- ========== Message Types for NotificationProducer  =========== -->

  <xsd:simpleType name="AbsoluteOrRelativeTimeType">
    <xsd:union memberTypes="xsd:dateTime xsd:duration" />
  </xsd:simpleType>

  <xsd:element name="CurrentTime" type="xsd:dateTime" />

  <xsd:element name="TerminationTime" 
               nillable="true" type="xsd:dateTime" />

  <xsd:element name="ProducerProperties"
               type="wsnt:QueryExpressionType" />

  <xsd:element name="MessageContent"
               type="wsnt:QueryExpressionType" />

  <xsd:element name="UseRaw"><xsd:complexType/></xsd:element>

  <xsd:element name="Subscribe" >
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="ConsumerReference" 
                     type="wsa:EndpointReferenceType"
                     minOccurs="1" maxOccurs="1" />
        <xsd:element name="Filter" 
                     type="wsnt:FilterType" 
                     minOccurs="0" maxOccurs="1" />
        <xsd:element name="InitialTerminationTime" 
                     type="wsnt:AbsoluteOrRelativeTimeType"
                     nillable="true"
                     minOccurs="0" maxOccurs="1" />
        <xsd:element name="SubscriptionPolicy"
                     minOccurs="0" maxOccurs="1">
          <xsd:complexType>
            <xsd:sequence>
              <xsd:any namespace="##any" processContents="lax"
                       minOccurs="0" maxOccurs="unbounded"/>
            </xsd:sequence>
          </xsd:complexType>
        </xsd:element>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
        
  <xsd:element name="SubscribeResponse">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="SubscriptionReference" 
                     type="wsa:EndpointReferenceType"
                     minOccurs="1" maxOccurs="1" />
        <xsd:element ref="wsnt:CurrentTime"
                     minOccurs="0" maxOccurs="1" />
        <xsd:element ref="wsnt:TerminationTime"
                     minOccurs="0" maxOccurs="1" />
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>
                  
  <xsd:element name="GetCurrentMessage">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="Topic" 
                     type="wsnt:TopicExpressionType" />
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="GetCurrentMessageResponse">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:complexType name="SubscribeCreationFailedFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="SubscribeCreationFailedFault" 
               type="wsnt:SubscribeCreationFailedFaultType"/>

  <xsd:complexType name="InvalidFilterFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType">
        <xsd:sequence>
          <xsd:element name="UnknownFilter" type="xsd:QName"
                       minOccurs="1" maxOccurs="unbounded"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="InvalidFilterFault"
               type="wsnt:InvalidFilterFaultType"/>

  <xsd:complexType name="TopicExpressionDialectUnknownFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="TopicExpressionDialectUnknownFault" 
               type="wsnt:TopicExpressionDialectUnknownFaultType"/>

  <xsd:complexType name="InvalidTopicExpressionFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="InvalidTopicExpressionFault" 
               type="wsnt:InvalidTopicExpressionFaultType"/>

  <xsd:complexType name="TopicNotSupportedFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="TopicNotSupportedFault" 
               type="wsnt:TopicNotSupportedFaultType"/>

  <xsd:complexType name="MultipleTopicsSpecifiedFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="MultipleTopicsSpecifiedFault" 
               type="wsnt:MultipleTopicsSpecifiedFaultType"/>

  <xsd:complexType name="InvalidProducerPropertiesExpressionFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="InvalidProducerPropertiesExpressionFault" 
             type="wsnt:InvalidProducerPropertiesExpressionFaultType"/>

  <xsd:complexType name="InvalidMessageContentExpressionFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="InvalidMessageContentExpressionFault" 
             type="wsnt:InvalidMessageContentExpressionFaultType"/>

  <xsd:complexType name="UnrecognizedPolicyRequestFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType">
		<xsd:sequence>
             <xsd:element name="UnrecognizedPolicy" type="xsd:QName"
                           minOccurs="0" maxOccurs="unbounded"/>
         </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="UnrecognizedPolicyRequestFault" 
             type="wsnt:UnrecognizedPolicyRequestFaultType"/>

  <xsd:complexType name="UnsupportedPolicyRequestFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType">
		<xsd:sequence>
             <xsd:element name="UnsupportedPolicy" type="xsd:QName"
                           minOccurs="0" maxOccurs="unbounded"/>
         </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="UnsupportedPolicyRequestFault" 
             type="wsnt:UnsupportedPolicyRequestFaultType"/>

  <xsd:complexType name="NotifyMessageNotSupportedFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="NotifyMessageNotSupportedFault" 
             type="wsnt:NotifyMessageNotSupportedFaultType"/>

  <xsd:complexType name="UnacceptableInitialTerminationTimeFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType">
        <xsd:sequence>
          <xsd:element name="MinimumTime" type="xsd:dateTime"/>
          <xsd:element name="MaximumTime" type="xsd:dateTime"
              minOccurs="0"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="UnacceptableInitialTerminationTimeFault"
              type="wsnt:UnacceptableInitialTerminationTimeFaultType"/>

  <xsd:complexType name="NoCurrentMessageOnTopicFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="NoCurrentMessageOnTopicFault" 
               type="wsnt:NoCurrentMessageOnTopicFaultType"/>

<!-- ======== Message Types for PullPoint  ======================== -->
  <xsd:element name="GetMessages">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="MaximumNumber" 
                     type="xsd:nonNegativeInteger"
                     minOccurs="0"/>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
      <xsd:anyAttribute/>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="GetMessagesResponse">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref="wsnt:NotificationMessage" 
                     minOccurs="0" maxOccurs="unbounded" />
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
      <xsd:anyAttribute/>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="DestroyPullPoint">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
      <xsd:anyAttribute/>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="DestroyPullPointResponse">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
      <xsd:anyAttribute/>
    </xsd:complexType>
  </xsd:element>

  <xsd:complexType name="UnableToGetMessagesFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="UnableToGetMessagesFault" 
               type="wsnt:UnableToGetMessagesFaultType"/>

<xsd:complexType name="UnableToDestroyPullPointFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>

  <xsd:element name="UnableToDestroyPullPointFault" 
               type="wsnt:UnableToDestroyPullPointFaultType"/>

<!-- ======== Message Types for Create PullPoint  ================= -->
  <xsd:element name="CreatePullPoint">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
      <xsd:anyAttribute/>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="CreatePullPointResponse">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="PullPoint"
                     type="wsa:EndpointReferenceType"/>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
      <xsd:anyAttribute/>
    </xsd:complexType>
  </xsd:element>

  <xsd:complexType name="UnableToCreatePullPointFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="UnableToCreatePullPointFault" 
               type="wsnt:UnableToCreatePullPointFaultType"/>

<!-- ======== Message Types for Base SubscriptionManager  ========= -->
  <xsd:element name="Renew">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element name="TerminationTime" 
                     type="wsnt:AbsoluteOrRelativeTimeType"
                     nillable="true"
                     minOccurs="1" maxOccurs="1" />
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="RenewResponse">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:element ref="wsnt:TerminationTime" 
                      minOccurs="1" maxOccurs="1" />
        <xsd:element ref="wsnt:CurrentTime" 
                      minOccurs="0" maxOccurs="1" />
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:complexType name="UnacceptableTerminationTimeFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType">
        <xsd:sequence>
          <xsd:element name="MinimumTime" type="xsd:dateTime"/>
          <xsd:element name="MaximumTime" type="xsd:dateTime"
              minOccurs="0"/>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="UnacceptableTerminationTimeFault"
              type="wsnt:UnacceptableTerminationTimeFaultType"/>

  <xsd:element name="Unsubscribe">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="UnsubscribeResponse">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:complexType name="UnableToDestroySubscriptionFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="UnableToDestroySubscriptionFault" 
               type="wsnt:UnableToDestroySubscriptionFaultType"/>

<!-- ====== Message Types for Pausable SubscriptionManager  ======= -->

  <xsd:element name="PauseSubscription">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="PauseSubscriptionResponse" >
    <xsd:complexType>
      <xsd:sequence>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="ResumeSubscription">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:element name="ResumeSubscriptionResponse">
    <xsd:complexType>
      <xsd:sequence>
        <xsd:any namespace="##other" processContents="lax"
                 minOccurs="0" maxOccurs="unbounded"/>
      </xsd:sequence>
    </xsd:complexType>
  </xsd:element>

  <xsd:complexType name="PauseFailedFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="PauseFailedFault" 
               type="wsnt:PauseFailedFaultType"/>

  <xsd:complexType name="ResumeFailedFaultType">
    <xsd:complexContent>
      <xsd:extension base="wsrf-bf:BaseFaultType"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="ResumeFailedFault" 
               type="wsnt:ResumeFailedFaultType"/>

</xsd:schema>
</file>

<file path="wsdl/vendor/common.xsd">
<?xml version="1.0" encoding="UTF-8"?>
<!--W3C XML Schema generated by XMLSpy v2017 (x64) (http://www.altova.com)-->
<!--
Copyright (c) 2008-2024 by ONVIF: Open Network Video Interface Forum. All rights reserved.

Recipients of this document may copy, distribute, publish, or display this document so long as this copyright notice, license and disclaimer are retained with all copies of the document. No license is granted to modify this document.

THIS DOCUMENT IS PROVIDED "AS IS," AND THE CORPORATION AND ITS MEMBERS AND THEIR AFFILIATES, MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THIS DOCUMENT ARE SUITABLE FOR ANY PURPOSE; OR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.
IN NO EVENT WILL THE CORPORATION OR ITS MEMBERS OR THEIR AFFILIATES BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE OR CONSEQUENTIAL DAMAGES, ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT, WHETHER OR NOT (1) THE CORPORATION, MEMBERS OR THEIR AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR (2) SUCH DAMAGES WERE REASONABLY FORESEEABLE, AND ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT.  THE FOREGOING DISCLAIMER AND LIMITATION ON LIABILITY DO NOT APPLY TO, INVALIDATE, OR LIMIT REPRESENTATIONS AND WARRANTIES MADE BY THE MEMBERS AND THEIR RESPECTIVE AFFILIATES TO THE CORPORATION AND OTHER MEMBERS IN CERTAIN WRITTEN POLICIES OF THE CORPORATION.
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" targetNamespace="http://www.onvif.org/ver10/schema" elementFormDefault="qualified" version="24.12">
	<!--===============================-->
	<!--         Generic Types         -->
	<!--===============================-->
	<xs:simpleType name="ReferenceToken">
		<xs:annotation>
			<xs:documentation>Unique identifier for a physical or logical resource.
			Tokens should be assigned such that they are unique within a device. Tokens must be at least unique within its class.
			Length up to 64 characters. Token may be extended by intermediate terminal with adding prefix to make it global unique.
			The length should be within 36 characters for generating at local device. See "Remote Token" section in Resource Query specification.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:maxLength value="64"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="IntRange">
		<xs:annotation>
			<xs:documentation>Range of values greater equal Min value and less equal Max value.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Min" type="xs:int"/>
			<xs:element name="Max" type="xs:int"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
    <!--    Start PTZ Related Types    -->
    <!--===============================-->
	<xs:complexType name="Vector2D">
		<xs:attribute name="x" type="xs:float" use="required"/>
		<xs:attribute name="y" type="xs:float" use="required"/>
		<xs:attribute name="space" type="xs:anyURI" use="optional">
			<xs:annotation>
				<xs:documentation>
  				Pan/tilt coordinate space selector. The following options are defined:<ul>
						<li> http://www.onvif.org/ver10/tptz/PanTiltSpaces/PositionGenericSpace</li>
						<li> http://www.onvif.org/ver10/tptz/PanTiltSpaces/TranslationGenericSpace</li>
						<li> http://www.onvif.org/ver10/tptz/PanTiltSpaces/VelocityGenericSpace</li>
						<li> http://www.onvif.org/ver10/tptz/PanTiltSpaces/GenericSpeedSpace</li>
					</ul>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="Vector1D">
		<xs:attribute name="x" type="xs:float" use="required"/>
		<xs:attribute name="space" type="xs:anyURI" use="optional">
			<xs:annotation>
				<xs:documentation>
				Zoom coordinate space selector. The following options are defined:<ul style="">
						<li> http://www.onvif.org/ver10/tptz/ZoomSpaces/PositionGenericSpace</li>
						<li> http://www.onvif.org/ver10/tptz/ZoomSpaces/TranslationGenericSpace</li>
						<li> http://www.onvif.org/ver10/tptz/ZoomSpaces/VelocityGenericSpace</li>
						<li> http://www.onvif.org/ver10/tptz/ZoomSpaces/ZoomGenericSpeedSpace</li>
					</ul>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="PTZVector">
		<xs:sequence>
			<xs:element name="PanTilt" type="tt:Vector2D" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Pan and tilt position. The x component corresponds to pan and the y component to tilt.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Zoom" type="tt:Vector1D" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
            A zoom position.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="FieldOfView">
		<xs:attribute name="hfov" type="xs:float" use="required">
			<xs:annotation>
				<xs:documentation>Horizontal field-of-view in degrees.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="vfov" type="xs:float" use="required">
			<xs:annotation>
				<xs:documentation>Vertical field-of-view in degrees.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="PTZStatus">
		<xs:sequence>
			<xs:element name="Position" type="tt:PTZVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
            Specifies the absolute position of the PTZ unit together with the Space references. The default absolute spaces of the corresponding PTZ configuration MUST be referenced within the Position element.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MoveStatus" type="tt:PTZMoveStatus" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
            Indicates if the Pan/Tilt/Zoom device unit is currently moving, idle or in an unknown state.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Error" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
            States a current PTZ error.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UtcTime" type="xs:dateTime">
				<xs:annotation>
					<xs:documentation>
            Specifies the UTC time when this status was generated.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FieldOfView" type="tt:FieldOfView" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						States the current field of view of the video stream.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	<!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<xs:complexType name="PTZMoveStatus">
		<xs:sequence>
			<xs:element name="PanTilt" type="tt:MoveStatus" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Zoom" type="tt:MoveStatus" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
          </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:simpleType name="MoveStatus">
		<xs:restriction base="xs:string">
			<xs:enumeration value="IDLE"/>
			<xs:enumeration value="MOVING"/>
			<xs:enumeration value="UNKNOWN"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<!--  Event and Analytics Types    -->
	<!--===============================-->
	<xs:complexType name="Vector">
		<xs:attribute name="x" type="xs:float"/>
		<xs:attribute name="y" type="xs:float"/>
	</xs:complexType>
	<xs:complexType name="Rectangle">
		<xs:attribute name="bottom" type="xs:float"/>
		<xs:attribute name="top" type="xs:float"/>
		<xs:attribute name="right" type="xs:float"/>
		<xs:attribute name="left" type="xs:float"/>
	</xs:complexType>
	<xs:complexType name="Polygon">
		<xs:sequence>
			<xs:element name="Point" type="tt:Vector" minOccurs="3" maxOccurs="unbounded"/>
		</xs:sequence>
<!--		<xs:attribute name='dummy'/> uncomment for compilation with Visual Studio --> 
	</xs:complexType>
	<xs:element name="Polygon" type="tt:Polygon"/>
	<xs:complexType name="Color">
		<xs:attribute name="X" type="xs:float" use="required"/>
		<xs:attribute name="Y" type="xs:float" use="required"/>
		<xs:attribute name="Z" type="xs:float" use="required"/>
		<xs:attribute name="Colorspace" type="xs:anyURI">
			<xs:annotation>
				<xs:documentation>
					Acceptable values:
					<ul>
						<li>http://www.onvif.org/ver10/colorspace/YCbCr - YCbCr
							<ul><li>X attribute = Y value</li>
								<li>Y attribute = Cb value</li>
								<li>Z attribute = Cr value</li></ul>
						</li>
						<li>http://www.onvif.org/ver10/colorspace/RGB - RGB
							<ul><li>X attribute = R value</li>
								<li>Y attribute = G value</li>
								<li>Z attribute = B value</li></ul>
						</li>
					</ul>
					If the Colorspace attribute is absent and not defined on higher level, YCbCr is implied.

					Deprecated values:
					<ul>
						<li>http://www.onvif.org/ver10/colorspace/CIELUV - CIE LUV</li>
						<li>http://www.onvif.org/ver10/colorspace/CIELAB - CIE 1976 (L*a*b*)</li>
						<li>http://www.onvif.org/ver10/colorspace/HSV - HSV</li>
					</ul>
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Likelihood" type="xs:float">
			<xs:annotation>
				<xs:documentation>Likelihood that the color is correct.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<xs:complexType name="ColorCovariance">
		<xs:attribute name="XX" type="xs:float" use="required"/>
		<xs:attribute name="YY" type="xs:float" use="required"/>
		<xs:attribute name="ZZ" type="xs:float" use="required"/>
		<xs:attribute name="XY" type="xs:float"/>
		<xs:attribute name="XZ" type="xs:float"/>
		<xs:attribute name="YZ" type="xs:float"/>
		<xs:attribute name="Colorspace" type="xs:anyURI">
			<xs:annotation>
				<xs:documentation>
					Acceptable values are the same as in tt:Color.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<xs:complexType name="ColorDescriptor">
		<xs:sequence>
			<xs:element name="ColorCluster" minOccurs="0" maxOccurs="unbounded">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Color" type="tt:Color"/>
						<xs:element name="Weight" type="xs:float" minOccurs="0"/>
						<xs:element name="Covariance" type="tt:ColorCovariance" minOccurs="0"/>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	<!-- reserved for ONVIF -->
					</xs:sequence>
					<xs:anyAttribute processContents="lax"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Extension" type="xs:anyType" minOccurs="0"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	<!-- reserved for ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--       Scene Description Types -->
	<!--===============================-->
	<xs:complexType name="Transformation">
		<xs:sequence>
			<xs:element name="Translate" type="tt:Vector" minOccurs="0"/>
			<xs:element name="Scale" type="tt:Vector" minOccurs="0"/>
			<xs:element name="Extension" type="tt:TransformationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<xs:complexType name="TransformationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	<!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--  Location/Orientation Types   -->
	<!--===============================-->
	<xs:complexType name="GeoLocation">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:attribute name="lon" type="xs:double">
			<xs:annotation>
				<xs:documentation>East west location as angle.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="lat" type="xs:double">
			<xs:annotation>
				<xs:documentation>North south location as angle.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="elevation" type="xs:float">
			<xs:annotation>
				<xs:documentation>Hight in meters above sea level.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="GeoOrientation">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:attribute name="roll" type="xs:float">
			<xs:annotation>
				<xs:documentation>Rotation around the x axis.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pitch" type="xs:float">
			<xs:annotation>
				<xs:documentation>Rotation around the y axis.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="yaw" type="xs:float">
			<xs:annotation>
				<xs:documentation>Rotation around the z axis.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="LocalLocation">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:attribute name="x" type="xs:float">
			<xs:annotation>
				<xs:documentation>East west location as angle.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="y" type="xs:float">
			<xs:annotation>
				<xs:documentation>North south location as angle.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="z" type="xs:float">
			<xs:annotation>
				<xs:documentation>Offset in meters from the sea level.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="LocalOrientation">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:attribute name="pan" type="xs:float">
			<xs:annotation>
				<xs:documentation>Rotation around the y axis.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="tilt" type="xs:float">
			<xs:annotation>
				<xs:documentation>Rotation around the z axis.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="roll" type="xs:float">
			<xs:annotation>
				<xs:documentation>Rotation around the x axis.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SphericalCoordinate">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:attribute name="Distance" type="xs:float">
			<xs:annotation>
				<xs:documentation>Distance in meters to the object.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ElevationAngle" type="xs:float">
			<xs:annotation>
				<xs:documentation>Elevation angle in the range -90 to 90 degrees, where 0 is in level with the x-y plane.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="AzimuthAngle" type="xs:float">
			<xs:annotation>
				<xs:documentation>Azimuth angle in the range -180 to 180 degrees counter clockwise, where 0 is rightwards.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="Entity">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Device"/>
			<xs:enumeration value="VideoSource"/>
			<xs:enumeration value="AudioSource"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="LocationEntity">
		<xs:sequence>
			<xs:element name="GeoLocation" type="tt:GeoLocation" minOccurs="0">
				<xs:annotation><xs:documentation>Location on earth.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:element name="GeoOrientation" type="tt:GeoOrientation" minOccurs="0">
				<xs:annotation><xs:documentation>Orientation relative to earth.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:element name="LocalLocation" type="tt:LocalLocation" minOccurs="0">
				<xs:annotation><xs:documentation>Indoor location offset.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:element name="LocalOrientation" type="tt:LocalOrientation" minOccurs="0">
				<xs:annotation><xs:documentation>Indoor orientation offset.</xs:documentation></xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="Entity" type="xs:string">
			<xs:annotation><xs:documentation>Entity type the entry refers to, use a value from the tt:Entity enumeration.</xs:documentation></xs:annotation>
		</xs:attribute>
		<xs:attribute name="Token" type="tt:ReferenceToken">
			<xs:annotation><xs:documentation>Optional entity token.</xs:documentation></xs:annotation>
		</xs:attribute>
		<xs:attribute name="Fixed" type="xs:boolean">
			<xs:annotation><xs:documentation>If this value is true the entity cannot be deleted.</xs:documentation></xs:annotation>
		</xs:attribute>
		<xs:attribute name="GeoSource" type="xs:anyURI">
			<xs:annotation><xs:documentation>Optional reference to the XAddr of another devices DeviceManagement service.</xs:documentation></xs:annotation>
		</xs:attribute>
		<xs:attribute name="AutoGeo" type="xs:boolean">
			<xs:annotation><xs:documentation>If set the geo location is obtained internally.</xs:documentation></xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--===============================-->
</xs:schema>
</file>

<file path="wsdl/vendor/devicemgmt.wsdl">
<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../../../ver20/util/onvif-wsdl-viewer.xsl"?>
<!--
Copyright (c) 2008-2024 by ONVIF: Open Network Video Interface Forum. All rights reserved.

Recipients of this document may copy, distribute, publish, or display this document so long as this copyright notice, license and disclaimer are retained with all copies of the document. No license is granted to modify this document.

THIS DOCUMENT IS PROVIDED "AS IS," AND THE CORPORATION AND ITS MEMBERS AND THEIR AFFILIATES, MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THIS DOCUMENT ARE SUITABLE FOR ANY PURPOSE; OR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.
IN NO EVENT WILL THE CORPORATION OR ITS MEMBERS OR THEIR AFFILIATES BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE OR CONSEQUENTIAL DAMAGES, ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT, WHETHER OR NOT (1) THE CORPORATION, MEMBERS OR THEIR AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR (2) SUCH DAMAGES WERE REASONABLY FORESEEABLE, AND ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT.  THE FOREGOING DISCLAIMER AND LIMITATION ON LIABILITY DO NOT APPLY TO, INVALIDATE, OR LIMIT REPRESENTATIONS AND WARRANTIES MADE BY THE MEMBERS AND THEIR RESPECTIVE AFFILIATES TO THE CORPORATION AND OTHER MEMBERS IN CERTAIN WRITTEN POLICIES OF THE CORPORATION.
-->
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap12/" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" targetNamespace="http://www.onvif.org/ver10/device/wsdl">
	<wsdl:types>
		<xs:schema targetNamespace="http://www.onvif.org/ver10/device/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:tds="http://www.onvif.org/ver10/device/wsdl" elementFormDefault="qualified" version="24.12">
			<xs:import namespace="http://www.onvif.org/ver10/schema" schemaLocation="./onvif.xsd"/>
			<!--===============================-->
			<xs:element name="GetServices">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="IncludeCapability" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>Indicates if the service capabilities (untyped) should be included in the response.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetServicesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Service" type="tds:Service" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Each Service element contains information about one service.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:complexType name="Service">
				<xs:sequence>
					<xs:element name="Namespace" type="xs:anyURI">
						<xs:annotation>
							<xs:documentation>Namespace of the service being described. This parameter allows to match the service capabilities to the service. Note that only one set of capabilities is supported per namespace.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="XAddr" type="xs:anyURI">
						<xs:annotation>
							<xs:documentation>The transport addresses where the service can be reached. The scheme and IP part shall match the one used in the request (i.e. the GetServices request).</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Capabilities" minOccurs="0">
						<xs:complexType>
							<xs:sequence>
								<xs:any namespace="##any" processContents="lax">
									<xs:annotation>
										<xs:documentation>The placeholder for the service capabilities. The service capability element shall be returned here. For example for the device service that would be the tds:DeviceServiceCapabilities element (not complextype).</xs:documentation>
									</xs:annotation>
								</xs:any>
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="Version" type="tt:OnvifVersion">
						<xs:annotation>
							<xs:documentation>The version of the service (not the ONVIF core spec version).</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:complexType>
			<!--===============================-->
			<xs:element name="GetServiceCapabilities">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetServiceCapabilitiesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Capabilities" type="tds:DeviceServiceCapabilities">
							<xs:annotation>
								<xs:documentation>The capabilities for the device service is returned in the Capabilities element.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:complexType name="DeviceServiceCapabilities">
				<xs:sequence>
					<xs:element name="Network" type="tds:NetworkCapabilities">
						<xs:annotation>
							<xs:documentation>Network capabilities.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Security" type="tds:SecurityCapabilities">
						<xs:annotation>
							<xs:documentation>Security capabilities.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="System" type="tds:SystemCapabilities">
						<xs:annotation>
							<xs:documentation>System capabilities.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Misc" type="tds:MiscCapabilities" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Capabilities that do not fit in any of the other categories.</xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
			</xs:complexType>
			<xs:element name="Capabilities" type="tds:DeviceServiceCapabilities"/>
			<!--===============================-->
			<xs:complexType name="NetworkCapabilities">
				<xs:attribute name="IPFilter" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for IP filtering.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="ZeroConfiguration" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for zeroconf.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="IPVersion6" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for IPv6.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="DynDNS" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for dynamic DNS configuration.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Dot11Configuration" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for IEEE 802.11 configuration.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Dot1XConfigurations" type="xs:int">
					<xs:annotation>
						<xs:documentation>Indicates the maximum number of Dot1X configurations supported by the device</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="HostnameFromDHCP" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for retrieval of hostname from DHCP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="NTP" type="xs:int">
					<xs:annotation>
						<xs:documentation>Maximum number of NTP servers supported by the devices SetNTP command.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="DHCPv6" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for Stateful IPv6 DHCP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:complexType>
			<!--===============================-->
			<xs:complexType name="SecurityCapabilities">
				<xs:attribute name="TLS1.0" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for TLS 1.0.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="TLS1.1" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for TLS 1.1.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="TLS1.2" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for TLS 1.2.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="OnboardKeyGeneration" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for onboard key generation.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="AccessPolicyConfig" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for access policy configuration.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="DefaultAccessPolicy" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for the ONVIF default access policy.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Dot1X" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for IEEE 802.1X configuration.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="RemoteUserHandling" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for remote user configuration. Used when accessing another device.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="X.509Token" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for WS-Security X.509 token.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="SAMLToken" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for WS-Security SAML token.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="KerberosToken" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for WS-Security Kerberos token.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="UsernameToken" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for WS-Security Username token.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="HttpDigest" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for WS over HTTP digest authenticated communication layer.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="RELToken" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for WS-Security REL token.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="JsonWebToken" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for JWT-based authentication with WS-Security Binary Security token.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="SupportedEAPMethods" type="tt:IntList">
					<xs:annotation>
						<xs:documentation>EAP Methods supported by the device. The int values refer to the <a href="http://www.iana.org/assignments/eap-numbers/eap-numbers.xhtml">IANA EAP Registry</a>.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="MaxUsers" type="xs:int">
					<xs:annotation>
						<xs:documentation>The maximum number of users that the device supports.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="MaxUserNameLength" type="xs:int">
					<xs:annotation>
						<xs:documentation>Maximum number of characters supported for the username by CreateUsers.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="MaxPasswordLength" type="xs:int">
					<xs:annotation>
						<xs:documentation>Maximum number of characters supported for the password by CreateUsers and SetUser.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="SecurityPolicies" type="tt:StringList">
					<xs:annotation>
                    				<xs:documentation>Indicates which security policies are supported. Options are: ModifyPassword, PasswordComplexity, AuthFailureWarnings</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="MaxPasswordHistory" type="xs:int">
					<xs:annotation>
                    				<xs:documentation>Maximum number of passwords that the device can remember for each user</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="HashingAlgorithms" type="tt:StringList">
					<xs:annotation>
                    				<xs:documentation>Supported hashing algorithms as part of HTTP and RTSP Digest authentication.Example: MD5,SHA-256</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:complexType>
			<!--===============================-->
			<xs:complexType name="SystemCapabilities">
				<xs:attribute name="DiscoveryResolve" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for WS Discovery resolve requests.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="DiscoveryBye" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for WS-Discovery Bye.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="RemoteDiscovery" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for remote discovery.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="SystemBackup" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for system backup through MTOM.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="SystemLogging" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for retrieval of system logging through MTOM.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="FirmwareUpgrade" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for firmware upgrade through MTOM.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="HttpFirmwareUpgrade" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for firmware upgrade through HTTP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="HttpSystemBackup" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for system backup through HTTP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="HttpSystemLogging" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for retrieval of system logging through HTTP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="HttpSupportInformation" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for retrieving support information through HTTP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="StorageConfiguration" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for storage configuration interfaces.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="MaxStorageConfigurations" type="xs:int">
					<xs:annotation>
						<xs:documentation>Indicates maximum number of storage configurations supported.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="GeoLocationEntries" type="xs:int">
					<xs:annotation>
						<xs:documentation>If present signals support for geo location. The value signals the supported number of entries.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="AutoGeo" type="tt:StringAttrList">
					<xs:annotation>
						<xs:documentation>List of supported automatic GeoLocation adjustment supported by the device. Valid items are defined by tds:AutoGeoMode.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="StorageTypesSupported" type="tt:StringAttrList">
					<xs:annotation>
						<xs:documentation>Enumerates the supported StorageTypes, see tds:StorageType.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="DiscoveryNotSupported" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates no support for network discovery.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="NetworkConfigNotSupported" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates no support for network configuration.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="UserConfigNotSupported" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates no support for user configuration.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Addons" type="tt:StringAttrList">
					<xs:annotation>
						<xs:documentation>List of supported Addons by the device.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="HardwareType" type="xs:string">
					<xs:annotation>
						<xs:documentation>Indicates what type of device this is. See tt:HardwareTypes for available options.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:complexType>
			<!--===============================-->
			<xs:simpleType name="AutoGeoModes">
				<xs:restriction base="xs:string">
					<xs:enumeration value="Location">
						<xs:annotation>	
							<xs:documentation>Automatic adjustment of the device location.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Heading">
						<xs:annotation>	
							<xs:documentation>Automatic adjustment of the device orientation relative to the compass also called yaw.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Leveling">
						<xs:annotation>	
							<xs:documentation>Automatic adjustment of the deviation from the horizon also called pitch and roll.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
			<!--===============================-->
			<xs:simpleType name="HardwareTypes">
				<xs:annotation>
					All hardware types specified are related to network devices supporting ONVIF specification.
				</xs:annotation>
				<xs:restriction base="xs:string">
					<xs:enumeration value="Camera">
						<xs:annotation>
							<xs:documentation>Single sensor camera. Ex. bullet, PTZ or fisheye camera.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="MultiSensorCamera">
						<xs:annotation>
							<xs:documentation>Multiple sensors device.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Encoder">
						<xs:annotation>
							<xs:documentation>Analog encoder. Can have 1 or more encoders.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Intercom">
						<xs:annotation>
							<xs:documentation>Intercom device, which has both a microphone and a speaker.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="AccessControl">
						<xs:annotation>
							<xs:documentation>Access control device.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Speaker">
						<xs:annotation>
							<xs:documentation>A speaker which is not an intercom.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Recorder">
						<xs:annotation>
							<xs:documentation>Network video recorder (NVR/DVR)</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Microphone">
						<xs:annotation>
							<xs:documentation>A microphone which is not an intercom.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="Display">
						<xs:annotation>
							<xs:documentation>A display for a device mainly supporting the Display service.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="IO-Device">
						<xs:annotation>
							<xs:documentation>A device which only has DigitalInputs and RelayOutputs.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
			<!--===============================-->
			<xs:complexType name="MiscCapabilities">
				<xs:attribute name="AuxiliaryCommands" type="tt:StringAttrList">
					<xs:annotation>
						<xs:documentation>Lists of commands supported by SendAuxiliaryCommand.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:complexType>
			<!--===============================-->
			<xs:element name="GetDeviceInformation">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetDeviceInformationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Manufacturer" type="xs:string">
							<xs:annotation>
								<xs:documentation>The manufactor of the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Model" type="xs:string">
							<xs:annotation>
								<xs:documentation>The device model.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="FirmwareVersion" type="xs:string">
							<xs:annotation>
								<xs:documentation>The firmware version in the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SerialNumber" type="xs:string">
							<xs:annotation>
								<xs:documentation>The serial number of the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="HardwareId" type="xs:string">
							<xs:annotation>
								<xs:documentation>The hardware ID of the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetSystemDateAndTime">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="DateTimeType" type="tt:SetDateTimeType">
							<xs:annotation>
								<xs:documentation>Defines if the date and time is set via NTP or manually.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DaylightSavings" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>Automatically adjust Daylight savings if defined in TimeZone.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="TimeZone" type="tt:TimeZone" minOccurs="0">
							<xs:annotation>
								<xs:documentation>The time zone in POSIX 1003.1 format</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="UTCDateTime" type="tt:DateTime" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Date and time in UTC. If time is obtained via NTP, UTCDateTime has no meaning</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetSystemDateAndTimeResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetSystemDateAndTime">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetSystemDateAndTimeResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="SystemDateAndTime" type="tt:SystemDateTime">
							<xs:annotation>
								<xs:documentation>Contains information whether system date and time are set manually or by NTP, daylight savings is on or off, time zone in POSIX 1003.1 format and system date and time in UTC and also local system date and time.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetSystemFactoryDefault">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="FactoryDefault" type="tt:FactoryDefaultType">
							<xs:annotation>
								<xs:documentation>Specifies the factory default action type.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetSystemFactoryDefaultResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="UpgradeSystemFirmware">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Firmware" type="tt:AttachmentData"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="UpgradeSystemFirmwareResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Message" type="xs:string" minOccurs="0" maxOccurs="1"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SystemReboot">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="SystemRebootResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Message" type="xs:string">
							<xs:annotation>
								<xs:documentation>Contains the reboot message sent by the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RestoreSystem">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="BackupFiles" type="tt:BackupFile" minOccurs="1" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RestoreSystemResponse">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetSystemBackup">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetSystemBackupResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="BackupFiles" type="tt:BackupFile" minOccurs="1" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetSystemSupportInformation">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetSystemSupportInformationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="SupportInformation" type="tt:SupportInformation">
							<xs:annotation>
								<xs:documentation>Contains the arbitary device diagnostics information.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetSystemLog">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="LogType" type="tt:SystemLogType">
							<xs:annotation>
								<xs:documentation>Specifies the type of system log to get.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetSystemLogResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="SystemLog" type="tt:SystemLog">
							<xs:annotation>
								<xs:documentation>Contains the system log information.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetScopes">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetScopesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Scopes" type="tt:Scope" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of URI definining the device scopes. Scope parameters can be of two types: fixed and configurable. Fixed parameters can not be altered.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetScopes">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Scopes" type="xs:anyURI" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of scope parameters that will replace all existing configurable scope parameters.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetScopesResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddScopes">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ScopeItem" type="xs:anyURI" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of new configurable scope parameters that will be added to the existing configurable scope.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddScopesResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemoveScopes">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ScopeItem" type="xs:anyURI" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of URIs that should be removed from the device scope.<br/>
									Note that the response message always will match the request or an error will be returned. The use of the response is for that reason deprecated.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemoveScopesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ScopeItem" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of URIs that has been removed from the device scope</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetDiscoveryMode">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetDiscoveryModeResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="DiscoveryMode" type="tt:DiscoveryMode">
							<xs:annotation>
								<xs:documentation>
									Indicator of discovery mode: Discoverable, NonDiscoverable.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetDiscoveryMode">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="DiscoveryMode" type="tt:DiscoveryMode">
							<xs:annotation>
								<xs:documentation>
									Indicator of discovery mode: Discoverable, NonDiscoverable.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetDiscoveryModeResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetRemoteDiscoveryMode">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetRemoteDiscoveryModeResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RemoteDiscoveryMode" type="tt:DiscoveryMode">
							<xs:annotation>
								<xs:documentation>
									Indicator of discovery mode: Discoverable, NonDiscoverable.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetRemoteDiscoveryMode">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RemoteDiscoveryMode" type="tt:DiscoveryMode">
							<xs:annotation>
								<xs:documentation>
									Indicator of discovery mode: Discoverable, NonDiscoverable.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetRemoteDiscoveryModeResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetDPAddresses">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetDPAddressesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="DPAddress" type="tt:NetworkHost" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetDPAddresses">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="DPAddress" type="tt:NetworkHost" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetDPAddressesResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetEndpointReference">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetEndpointReferenceResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="GUID" type="xs:string"/>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetRemoteUser">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetRemoteUserResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RemoteUser" type="tt:RemoteUser" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetRemoteUser">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RemoteUser" type="tt:RemoteUser" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetRemoteUserResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetUsers">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetUsersResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="User" type="tt:User" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of the onvif users and following information is included in each entry: username and user level.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="CreateUsers">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="User" type="tt:User" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Creates new device users and corresponding credentials. Each user entry includes: username, password and user level. Either all users are created successfully or a fault message MUST be returned without creating any user. If trying to create several users with exactly the same username the request is rejected and no users are created. If password is missing, then fault message Too weak password is returned.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="CreateUsersResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="DeleteUsers">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Username" type="xs:string" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Deletes users on an device and there may exist users that cannot be deleted to ensure access to the unit. Either all users are deleted successfully or a fault message MUST be returned and no users be deleted. If a username exists multiple times in the request, then a fault message is returned.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="DeleteUsersResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetUser">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="User" type="tt:User" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Updates the credentials for one or several users on an device. Either all change requests are processed successfully or a fault message MUST be returned. If the request contains the same username multiple times, a fault message is returned. </xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetUserResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetWsdlUrl">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetWsdlUrlResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="WsdlUrl" type="xs:anyURI"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetPasswordComplexityOptions">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetPasswordComplexityOptionsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="MinLenRange" type="tt:IntRange" minOccurs="0"/>
						<xs:element name="UppercaseRange" type="tt:IntRange" minOccurs="0"/>
						<xs:element name="NumberRange" type="tt:IntRange" minOccurs="0"/>
						<xs:element name="SpecialCharsRange" type="tt:IntRange" minOccurs="0"/>
						<xs:element name="BlockUsernameOccurrenceSupported" type="xs:boolean" minOccurs="0"/>
						<xs:element name="PolicyConfigurationLockSupported" type="xs:boolean" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetPasswordComplexityConfiguration">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetPasswordComplexityConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="MinLen" type="xs:int" minOccurs="0"/>
						<xs:element name="Uppercase" type="xs:int" minOccurs="0"/>
						<xs:element name="Number" type="xs:int" minOccurs="0"/>
						<xs:element name="SpecialChars" type="xs:int" minOccurs="0"/>
						<xs:element name="BlockUsernameOccurrence" type="xs:boolean" minOccurs="0"/>
						<xs:element name="PolicyConfigurationLocked" type="xs:boolean" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetPasswordComplexityConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="MinLen" type="xs:int" minOccurs="0"/>
						<xs:element name="Uppercase" type="xs:int" minOccurs="0"/>
						<xs:element name="Number" type="xs:int" minOccurs="0"/>
						<xs:element name="SpecialChars" type="xs:int" minOccurs="0"/>
						<xs:element name="BlockUsernameOccurrence" type="xs:boolean" minOccurs="0"/>
						<xs:element name="PolicyConfigurationLocked" type="xs:boolean" minOccurs="0"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetPasswordComplexityConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetPasswordHistoryConfiguration">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetPasswordHistoryConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean"/>
						<xs:element name="Length" type="xs:int"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetPasswordHistoryConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean"/>
						<xs:element name="Length" type="xs:int"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetPasswordHistoryConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAuthFailureWarningOptions">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAuthFailureWarningOptionsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="MonitorPeriodRange" type="tt:IntRange"/>
						<xs:element name="AuthFailureRange" type="tt:IntRange"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAuthFailureWarningConfiguration">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAuthFailureWarningConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean"/>
						<xs:element name="MonitorPeriod" type="xs:int"/>
						<xs:element name="MaxAuthFailures" type="xs:int"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetAuthFailureWarningConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean"/>
						<xs:element name="MonitorPeriod" type="xs:int"/>
						<xs:element name="MaxAuthFailures" type="xs:int"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetAuthFailureWarningConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCapabilities">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Category" type="tt:CapabilityCategory" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									List of categories to retrieve capability information on.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCapabilitiesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Capabilities" type="tt:Capabilities">
							<xs:annotation>
								<xs:documentation>
									Capability information.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetHostname">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetHostnameResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="HostnameInformation" type="tt:HostnameInformation">
							<xs:annotation>
								<xs:documentation>Contains the hostname information.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetHostname">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Name" type="xs:token">
							<xs:annotation>
								<xs:documentation>The hostname to set.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetHostnameResponse">
				<xs:complexType>
					<xs:sequence>
				    </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetHostnameFromDHCP">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="FromDHCP" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>True if the hostname shall be obtained via DHCP.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetHostnameFromDHCPResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RebootNeeded" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>
									Indicates whether or not a reboot is required after configuration updates.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetDNS">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetDNSResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="DNSInformation" type="tt:DNSInformation">
							<xs:annotation>
								<xs:documentation>
									DNS information.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetDNS">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="FromDHCP" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>
									Indicate if the DNS address is to be retrieved using DHCP.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="SearchDomain" type="xs:token" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									DNS search domain.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="DNSManual" type="tt:IPAddress" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									DNS address(es) set manually.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetDNSResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetNTP">
				<xs:complexType>
					<xs:sequence>
				    </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetNTPResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="NTPInformation" type="tt:NTPInformation">
							<xs:annotation>
								<xs:documentation>
									NTP information.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetNTP">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="FromDHCP" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>
									Indicate if NTP address information is to be retrieved using DHCP.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="NTPManual" type="tt:NetworkHost" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									Manual NTP settings.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetNTPResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetDynamicDNS">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetDynamicDNSResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="DynamicDNSInformation" type="tt:DynamicDNSInformation">
							<xs:annotation>
								<xs:documentation>
									Dynamic DNS information.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetDynamicDNS">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Type" type="tt:DynamicDNSType">
							<xs:annotation>
								<xs:documentation>
									Dynamic DNS type.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Name" type="tt:DNSName" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
									DNS name.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="TTL" type="xs:duration" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
									DNS record time to live.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetDynamicDNSResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetNetworkInterfaces">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetNetworkInterfacesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="NetworkInterfaces" type="tt:NetworkInterface" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									List of network interfaces.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetNetworkInterfaces">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="InterfaceToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>
									Symbolic network interface name.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="NetworkInterface" type="tt:NetworkInterfaceSetConfiguration">
							<xs:annotation>
								<xs:documentation>
									Network interface name.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetNetworkInterfacesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RebootNeeded" type="xs:boolean" minOccurs="1" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>
									Indicates whether or not a reboot is required after configuration updates.
									If a device responds with RebootNeeded set to false, the device can be reached
									via the new IP address without further action. A client should be aware that a device
									may not be responsive for a short period of time until it signals availability at
									the new address via the discovery Hello messages.
									If a device responds with RebootNeeded set to true, it will be further available under
									its previous IP address. The settings will only be activated when the device is
									rebooted via the SystemReboot command.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetNetworkProtocols">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetNetworkProtocolsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="NetworkProtocols" type="tt:NetworkProtocol" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains an array of defined protocols supported by the device. There are three protocols defined; HTTP, HTTPS and RTSP. The following parameters can be retrieved for each protocol: port and enable/disable.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetNetworkProtocols">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="NetworkProtocols" type="tt:NetworkProtocol" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Configures one or more defined network protocols supported by the device. There are currently three protocols defined; HTTP, HTTPS and RTSP. The following parameters can be set for each protocol: port and enable/disable.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetNetworkProtocolsResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetNetworkDefaultGateway">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetNetworkDefaultGatewayResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="NetworkGateway" type="tt:NetworkGateway">
							<xs:annotation>
								<xs:documentation>Gets the default IPv4 and IPv6 gateway settings from the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetNetworkDefaultGateway">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="IPv4Address" type="tt:IPv4Address" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Sets IPv4 gateway address used as default setting.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="IPv6Address" type="tt:IPv6Address" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Sets IPv6 gateway address used as default setting.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetNetworkDefaultGatewayResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetZeroConfiguration">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetZeroConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ZeroConfiguration" type="tt:NetworkZeroConfiguration">
							<xs:annotation>
								<xs:documentation>Contains the zero-configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetZeroConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="InterfaceToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Unique identifier referencing the physical interface.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Enabled" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>Specifies if the zero-configuration should be enabled or not.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetZeroConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetIPAddressFilter">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetIPAddressFilterResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="IPAddressFilter" type="tt:IPAddressFilter"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetIPAddressFilter">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="IPAddressFilter" type="tt:IPAddressFilter"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetIPAddressFilterResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddIPAddressFilter">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="IPAddressFilter" type="tt:IPAddressFilter"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddIPAddressFilterResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemoveIPAddressFilter">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="IPAddressFilter" type="tt:IPAddressFilter"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemoveIPAddressFilterResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAccessPolicy">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAccessPolicyResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="PolicyFile" type="tt:BinaryData"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetAccessPolicy">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="PolicyFile" type="tt:BinaryData"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetAccessPolicyResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="CreateCertificate">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CertificateID" type="xs:token" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Certificate id.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Subject" type="xs:string" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Identification of the entity associated with the public-key.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ValidNotBefore" type="xs:dateTime" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Certificate validity start date.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ValidNotAfter" type="xs:dateTime" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Certificate expiry start date.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="CreateCertificateResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="NvtCertificate" type="tt:Certificate">
							<xs:annotation>
								<xs:documentation>
									base64 encoded DER representation of certificate.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCertificates">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCertificatesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="NvtCertificate" type="tt:Certificate" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									Id and base64 encoded DER representation of all available certificates.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCertificatesStatus">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCertificatesStatusResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CertificateStatus" type="tt:CertificateStatus" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									Indicates if a certificate is used in an optional HTTPS configuration of the device.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetCertificatesStatus">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CertificateStatus" type="tt:CertificateStatus" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									Indicates if a certificate is to be used in an optional HTTPS configuration of the device.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetCertificatesStatusResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="DeleteCertificates">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CertificateID" type="xs:token" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									List of ids of certificates to delete.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="DeleteCertificatesResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetPkcs10Request">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CertificateID" type="xs:token">
							<xs:annotation>
								<xs:documentation>
									List of ids of certificates to delete.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Subject" type="xs:string" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
									Relative Dinstinguished Name(RDN) CommonName(CN).
								</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Attributes" type="tt:BinaryData" minOccurs="0">
							<xs:annotation>
								<xs:documentation>
									Optional base64 encoded DER attributes.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetPkcs10RequestResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Pkcs10Request" type="tt:BinaryData">
							<xs:annotation>
								<xs:documentation>
									base64 encoded DER representation of certificate.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="LoadCertificates">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="NVTCertificate" type="tt:Certificate" minOccurs="1" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>
									Optional id and base64 encoded DER representation of certificate.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="LoadCertificatesResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetClientCertificateMode">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetClientCertificateModeResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>
									Indicates whether or not client certificates are required by device.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetClientCertificateMode">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Enabled" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>
									Indicates whether or not client certificates are required by device.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetClientCertificateModeResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCACertificates">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCACertificatesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CACertificate" type="tt:Certificate" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="LoadCertificateWithPrivateKey">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CertificateWithPrivateKey" type="tt:CertificateWithPrivateKey" minOccurs="1" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="LoadCertificateWithPrivateKeyResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCertificateInformation">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CertificateID" type="xs:token" minOccurs="1" maxOccurs="1"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCertificateInformationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CertificateInformation" type="tt:CertificateInformation" minOccurs="1" maxOccurs="1"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="LoadCACertificates">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="CACertificate" type="tt:Certificate" minOccurs="1" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="LoadCACertificatesResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="CreateDot1XConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Dot1XConfiguration" type="tt:Dot1XConfiguration" minOccurs="1" maxOccurs="1"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="CreateDot1XConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetDot1XConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Dot1XConfiguration" type="tt:Dot1XConfiguration" minOccurs="1" maxOccurs="1"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetDot1XConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetDot1XConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Dot1XConfigurationToken" type="tt:ReferenceToken" minOccurs="1" maxOccurs="1"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetDot1XConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Dot1XConfiguration" type="tt:Dot1XConfiguration" minOccurs="1" maxOccurs="1"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetDot1XConfigurations">
				<xs:complexType>
					<xs:sequence>
			</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetDot1XConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Dot1XConfiguration" type="tt:Dot1XConfiguration" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="DeleteDot1XConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Dot1XConfigurationToken" type="tt:ReferenceToken" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="DeleteDot1XConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetRelayOutputs">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetRelayOutputsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RelayOutputs" type="tt:RelayOutput" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetRelayOutputSettings">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RelayOutputToken" type="tt:ReferenceToken"/>
						<xs:element name="Properties" type="tt:RelayOutputSettings"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetRelayOutputSettingsResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetRelayOutputState">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="RelayOutputToken" type="tt:ReferenceToken" minOccurs="1" maxOccurs="1"/>
						<xs:element name="LogicalState" type="tt:RelayLogicalState" minOccurs="1" maxOccurs="1"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetRelayOutputStateResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SendAuxiliaryCommand">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="AuxiliaryCommand" type="tt:AuxiliaryData" minOccurs="1" maxOccurs="1"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SendAuxiliaryCommandResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="AuxiliaryCommandResponse" type="tt:AuxiliaryData" minOccurs="0" maxOccurs="1"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetDot11Capabilities">
				<xs:complexType>
					<xs:sequence>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetDot11CapabilitiesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Capabilities" type="tt:Dot11Capabilities"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetDot11Status">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="InterfaceToken" type="tt:ReferenceToken"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetDot11StatusResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Status" type="tt:Dot11Status"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="ScanAvailableDot11Networks">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="InterfaceToken" type="tt:ReferenceToken"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="ScanAvailableDot11NetworksResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Networks" type="tt:Dot11AvailableNetworks" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetSystemUris">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetSystemUrisResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="SystemLogUris" type="tt:SystemLogUriList" minOccurs="0" maxOccurs="1"/>
						<xs:element name="SupportInfoUri" type="xs:anyURI" minOccurs="0" maxOccurs="1"/>
						<xs:element name="SystemBackupUri" type="xs:anyURI" minOccurs="0" maxOccurs="1"/>
						<xs:element name="Extension" minOccurs="0">
							<xs:complexType>
								<xs:sequence>
									<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
								</xs:sequence>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="StartFirmwareUpgrade">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="StartFirmwareUpgradeResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="UploadUri" type="xs:anyURI"/>
						<xs:element name="UploadDelay" type="xs:duration"/>
						<xs:element name="ExpectedDownTime" type="xs:duration"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="StartSystemRestore">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="StartSystemRestoreResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="UploadUri" type="xs:anyURI"/>
						<xs:element name="ExpectedDownTime" type="xs:duration"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetHashingAlgorithm">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Algorithm" type="tt:StringList">
							<xs:annotation>
								<xs:documentation>
									Hashing algorithm(s) used in HTTP and RTSP Digest Authentication.
								</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetHashingAlgorithmResponse">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			
			<xs:complexType name="UserCredential">
				<xs:sequence>
					<xs:element name="UserName" type="xs:string">
						<xs:annotation>	
							<xs:documentation>User name</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Password" type="xs:string" minOccurs="0">
						<xs:annotation>	
							<xs:documentation> optional password</xs:documentation> 
						</xs:annotation>
					</xs:element>
					<xs:element name="Extension" minOccurs="0">	<!-- deprecated -->
						<xs:complexType>
							<xs:sequence>
								<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- Vendor only -->
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="Token" type="xs:string" minOccurs="0">
						<xs:annotation>
							<xs:documentation> optional access token</xs:documentation>
						</xs:annotation>
					</xs:element>					
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
				</xs:sequence>
			</xs:complexType>
			
			<xs:simpleType name="StorageType">
				<xs:restriction base="xs:string">
					<xs:enumeration value="NFS">
						<xs:annotation>	
							<xs:documentation>NFS protocol</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="CIFS">
						<xs:annotation>
							<xs:documentation>CIFS protocol</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="CDMI">
						<xs:annotation>
							<xs:documentation>CDMI protocol</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="FTP">
						<xs:annotation>
							<xs:documentation>FTP protocol</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ObjectStorageS3">
						<xs:annotation>
							<xs:documentation>Amazon Simple Storage Service (S3) protocol (also used for S3 compatible object storages like MinIO)</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="ObjectStorageAzure">
						<xs:annotation>
							<xs:documentation>Microsoft Azure Blob Storage protocol</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
			
			<xs:complexType name="StorageConfigurationData">
				<xs:sequence>
					<xs:element name="LocalPath" type="xs:anyURI" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Local path</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="StorageUri" type="xs:anyURI" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Storage server address</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="User" type="tds:UserCredential"  minOccurs="0">
						<xs:annotation>
							<xs:documentation>User credential for the storage server</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extension" minOccurs="0">	<!-- deprecated -->
						<xs:complexType>
							<xs:sequence>
								<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- Vendor only -->
							</xs:sequence>
						</xs:complexType>
					</xs:element>
					<xs:element name="CertPathValidationPolicyID" type="xs:string" minOccurs="0">
						<xs:annotation>
							<xs:documentation>The unique identifier of the certification path validation policy to be used for validating the server certificate as declared in the security service.</xs:documentation>
							<xs:documentation>If not configured, server certificate validation behavior is undefined and the device may either apply a vendor specific default validation policy or skip validation at all.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	   <!-- first ONVIF then Vendor -->
				</xs:sequence>
				<xs:attribute name="type" type="xs:string" use="required">
					<xs:annotation>
						<xs:documentation>tds:StorageType lists the acceptable values for type attribute</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Region" type="xs:string">
					<xs:annotation>
						<xs:documentation>Optional region of the storage server</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			 </xs:complexType>

			<xs:complexType name="StorageConfiguration">
				<xs:complexContent>
					<xs:extension base="tt:DeviceEntity">
						<xs:sequence>
							<xs:element name="Data" type="tds:StorageConfigurationData">
							</xs:element>
						</xs:sequence>
					</xs:extension>
				</xs:complexContent>
			</xs:complexType>

			<!--===============================-->
			<!--===============================-->
			<xs:element name="GetStorageConfigurations">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetStorageConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="StorageConfigurations" type="tds:StorageConfiguration" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>			
			<!--===============================-->
			<!--===============================-->
 			<xs:element name="CreateStorageConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="StorageConfiguration" type="tds:StorageConfigurationData">
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>			
			<xs:element name="CreateStorageConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Token" type="tt:ReferenceToken">
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>	 		
			<!--===============================-->
			<!--===============================-->
 			<xs:element name="GetStorageConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Token" type="tt:ReferenceToken">
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>			
			<xs:element name="GetStorageConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="StorageConfiguration" type="tds:StorageConfiguration">
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>	 		
			<!--===============================-->
			<!--===============================-->
 			<xs:element name="SetStorageConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="StorageConfiguration" type="tds:StorageConfiguration">
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>			
			<xs:element name="SetStorageConfigurationResponse">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>	 		
			<!--===============================-->
			<!--===============================-->
 			<xs:element name="DeleteStorageConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Token" type="tt:ReferenceToken">
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>			
			<xs:element name="DeleteStorageConfigurationResponse">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>	 		

			<!--===============================-->
			<xs:element name="GetGeoLocation">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>			
			<xs:element name="GetGeoLocationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Location" type="tt:LocationEntity" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>	 		
			<!--===============================-->
			<xs:element name="SetGeoLocation">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Location" type="tt:LocationEntity" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>			
			<xs:element name="SetGeoLocationResponse">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>	 		
			<!--===============================-->
			<xs:element name="DeleteGeoLocation">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Location" type="tt:LocationEntity" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>			
			<xs:element name="DeleteGeoLocationResponse">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>	 		
			<!--===============================-->
			<!--===============================-->
		</xs:schema>
	</wsdl:types>
	<wsdl:message name="GetServicesRequest">
		<wsdl:part name="parameters" element="tds:GetServices"/>
	</wsdl:message>
	<wsdl:message name="GetServicesResponse">
		<wsdl:part name="parameters" element="tds:GetServicesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetServiceCapabilitiesRequest">
		<wsdl:part name="parameters" element="tds:GetServiceCapabilities"/>
	</wsdl:message>
	<wsdl:message name="GetServiceCapabilitiesResponse">
		<wsdl:part name="parameters" element="tds:GetServiceCapabilitiesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetDeviceInformationRequest">
		<wsdl:part name="parameters" element="tds:GetDeviceInformation"/>
	</wsdl:message>
	<wsdl:message name="GetDeviceInformationResponse">
		<wsdl:part name="parameters" element="tds:GetDeviceInformationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetSystemDateAndTimeRequest">
		<wsdl:part name="parameters" element="tds:SetSystemDateAndTime"/>
	</wsdl:message>
	<wsdl:message name="SetSystemDateAndTimeResponse">
		<wsdl:part name="parameters" element="tds:SetSystemDateAndTimeResponse"/>
	</wsdl:message>
	<wsdl:message name="GetSystemDateAndTimeRequest">
		<wsdl:part name="parameters" element="tds:GetSystemDateAndTime"/>
	</wsdl:message>
	<wsdl:message name="GetSystemDateAndTimeResponse">
		<wsdl:part name="parameters" element="tds:GetSystemDateAndTimeResponse"/>
	</wsdl:message>
	<wsdl:message name="SetSystemFactoryDefaultRequest">
		<wsdl:part name="parameters" element="tds:SetSystemFactoryDefault"/>
	</wsdl:message>
	<wsdl:message name="SetSystemFactoryDefaultResponse">
		<wsdl:part name="parameters" element="tds:SetSystemFactoryDefaultResponse"/>
	</wsdl:message>
	<wsdl:message name="UpgradeSystemFirmwareRequest">
		<wsdl:part name="parameters" element="tds:UpgradeSystemFirmware"/>
	</wsdl:message>
	<wsdl:message name="UpgradeSystemFirmwareResponse">
		<wsdl:part name="parameters" element="tds:UpgradeSystemFirmwareResponse"/>
	</wsdl:message>
	<wsdl:message name="SystemRebootRequest">
		<wsdl:part name="parameters" element="tds:SystemReboot"/>
	</wsdl:message>
	<wsdl:message name="SystemRebootResponse">
		<wsdl:part name="parameters" element="tds:SystemRebootResponse"/>
	</wsdl:message>
	<wsdl:message name="GetSystemBackupRequest">
		<wsdl:part name="parameters" element="tds:GetSystemBackup"/>
	</wsdl:message>
	<wsdl:message name="GetSystemBackupResponse">
		<wsdl:part name="parameters" element="tds:GetSystemBackupResponse"/>
	</wsdl:message>
	<wsdl:message name="RestoreSystemRequest">
		<wsdl:part name="parameters" element="tds:RestoreSystem"/>
	</wsdl:message>
	<wsdl:message name="RestoreSystemResponse">
		<wsdl:part name="parameters" element="tds:RestoreSystemResponse"/>
	</wsdl:message>
	<wsdl:message name="GetSystemSupportInformationRequest">
		<wsdl:part name="parameters" element="tds:GetSystemSupportInformation"/>
	</wsdl:message>
	<wsdl:message name="GetSystemSupportInformationResponse">
		<wsdl:part name="parameters" element="tds:GetSystemSupportInformationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetSystemLogRequest">
		<wsdl:part name="parameters" element="tds:GetSystemLog"/>
	</wsdl:message>
	<wsdl:message name="GetSystemLogResponse">
		<wsdl:part name="parameters" element="tds:GetSystemLogResponse"/>
	</wsdl:message>
	<wsdl:message name="GetScopesRequest">
		<wsdl:part name="parameters" element="tds:GetScopes"/>
	</wsdl:message>
	<wsdl:message name="GetScopesResponse">
		<wsdl:part name="parameters" element="tds:GetScopesResponse"/>
	</wsdl:message>
	<wsdl:message name="SetScopesRequest">
		<wsdl:part name="parameters" element="tds:SetScopes"/>
	</wsdl:message>
	<wsdl:message name="SetScopesResponse">
		<wsdl:part name="parameters" element="tds:SetScopesResponse"/>
	</wsdl:message>
	<wsdl:message name="AddScopesRequest">
		<wsdl:part name="parameters" element="tds:AddScopes"/>
	</wsdl:message>
	<wsdl:message name="AddScopesResponse">
		<wsdl:part name="parameters" element="tds:AddScopesResponse"/>
	</wsdl:message>
	<wsdl:message name="RemoveScopesRequest">
		<wsdl:part name="parameters" element="tds:RemoveScopes"/>
	</wsdl:message>
	<wsdl:message name="RemoveScopesResponse">
		<wsdl:part name="parameters" element="tds:RemoveScopesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetDiscoveryModeRequest">
		<wsdl:part name="parameters" element="tds:GetDiscoveryMode"/>
	</wsdl:message>
	<wsdl:message name="GetDiscoveryModeResponse">
		<wsdl:part name="parameters" element="tds:GetDiscoveryModeResponse"/>
	</wsdl:message>
	<wsdl:message name="SetDiscoveryModeRequest">
		<wsdl:part name="parameters" element="tds:SetDiscoveryMode"/>
	</wsdl:message>
	<wsdl:message name="SetDiscoveryModeResponse">
		<wsdl:part name="parameters" element="tds:SetDiscoveryModeResponse"/>
	</wsdl:message>
	<wsdl:message name="GetRemoteDiscoveryModeRequest">
		<wsdl:part name="parameters" element="tds:GetRemoteDiscoveryMode"/>
	</wsdl:message>
	<wsdl:message name="GetRemoteDiscoveryModeResponse">
		<wsdl:part name="parameters" element="tds:GetRemoteDiscoveryModeResponse"/>
	</wsdl:message>
	<wsdl:message name="SetRemoteDiscoveryModeRequest">
		<wsdl:part name="parameters" element="tds:SetRemoteDiscoveryMode"/>
	</wsdl:message>
	<wsdl:message name="SetRemoteDiscoveryModeResponse">
		<wsdl:part name="parameters" element="tds:SetRemoteDiscoveryModeResponse"/>
	</wsdl:message>
	<wsdl:message name="GetDPAddressesRequest">
		<wsdl:part name="parameters" element="tds:GetDPAddresses"/>
	</wsdl:message>
	<wsdl:message name="GetDPAddressesResponse">
		<wsdl:part name="parameters" element="tds:GetDPAddressesResponse"/>
	</wsdl:message>
	<wsdl:message name="SetDPAddressesRequest">
		<wsdl:part name="parameters" element="tds:SetDPAddresses"/>
	</wsdl:message>
	<wsdl:message name="SetDPAddressesResponse">
		<wsdl:part name="parameters" element="tds:SetDPAddressesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetEndpointReferenceRequest">
		<wsdl:part name="parameters" element="tds:GetEndpointReference"/>
	</wsdl:message>
	<wsdl:message name="GetEndpointReferenceResponse">
		<wsdl:part name="parameters" element="tds:GetEndpointReferenceResponse"/>
	</wsdl:message>
	<wsdl:message name="GetRemoteUserRequest">
		<wsdl:part name="parameters" element="tds:GetRemoteUser"/>
	</wsdl:message>
	<wsdl:message name="GetRemoteUserResponse">
		<wsdl:part name="parameters" element="tds:GetRemoteUserResponse"/>
	</wsdl:message>
	<wsdl:message name="SetRemoteUserRequest">
		<wsdl:part name="parameters" element="tds:SetRemoteUser"/>
	</wsdl:message>
	<wsdl:message name="SetRemoteUserResponse">
		<wsdl:part name="parameters" element="tds:SetRemoteUserResponse"/>
	</wsdl:message>
	<wsdl:message name="GetUsersRequest">
		<wsdl:part name="parameters" element="tds:GetUsers"/>
	</wsdl:message>
	<wsdl:message name="GetUsersResponse">
		<wsdl:part name="parameters" element="tds:GetUsersResponse"/>
	</wsdl:message>
	<wsdl:message name="CreateUsersRequest">
		<wsdl:part name="parameters" element="tds:CreateUsers"/>
	</wsdl:message>
	<wsdl:message name="CreateUsersResponse">
		<wsdl:part name="parameters" element="tds:CreateUsersResponse"/>
	</wsdl:message>
	<wsdl:message name="DeleteUsersRequest">
		<wsdl:part name="parameters" element="tds:DeleteUsers"/>
	</wsdl:message>
	<wsdl:message name="DeleteUsersResponse">
		<wsdl:part name="parameters" element="tds:DeleteUsersResponse"/>
	</wsdl:message>
	<wsdl:message name="SetUserRequest">
		<wsdl:part name="parameters" element="tds:SetUser"/>
	</wsdl:message>
	<wsdl:message name="SetUserResponse">
		<wsdl:part name="parameters" element="tds:SetUserResponse"/>
	</wsdl:message>
	<wsdl:message name="GetWsdlUrlRequest">
		<wsdl:part name="parameters" element="tds:GetWsdlUrl"/>
	</wsdl:message>
	<wsdl:message name="GetWsdlUrlResponse">
		<wsdl:part name="parameters" element="tds:GetWsdlUrlResponse"/>
	</wsdl:message>
	<wsdl:message name="GetPasswordComplexityOptionsRequest">
		<wsdl:part name="parameters" element="tds:GetPasswordComplexityOptions"/>
	</wsdl:message>
	<wsdl:message name="GetPasswordComplexityOptionsResponse">
		<wsdl:part name="parameters" element="tds:GetPasswordComplexityOptionsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetPasswordComplexityConfigurationRequest">
		<wsdl:part name="parameters" element="tds:GetPasswordComplexityConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetPasswordComplexityConfigurationResponse">
		<wsdl:part name="parameters" element="tds:GetPasswordComplexityConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetPasswordComplexityConfigurationRequest">
		<wsdl:part name="parameters" element="tds:SetPasswordComplexityConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetPasswordComplexityConfigurationResponse">
		<wsdl:part name="parameters" element="tds:SetPasswordComplexityConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetPasswordHistoryConfigurationRequest">
		<wsdl:part name="parameters" element="tds:GetPasswordHistoryConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetPasswordHistoryConfigurationResponse">
		<wsdl:part name="parameters" element="tds:GetPasswordHistoryConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetPasswordHistoryConfigurationRequest">
		<wsdl:part name="parameters" element="tds:SetPasswordHistoryConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetPasswordHistoryConfigurationResponse">
		<wsdl:part name="parameters" element="tds:SetPasswordHistoryConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAuthFailureWarningOptionsRequest">
		<wsdl:part name="parameters" element="tds:GetAuthFailureWarningOptions"/>
	</wsdl:message>
	<wsdl:message name="GetAuthFailureWarningOptionsResponse">
		<wsdl:part name="parameters" element="tds:GetAuthFailureWarningOptionsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAuthFailureWarningConfigurationRequest">
		<wsdl:part name="parameters" element="tds:GetAuthFailureWarningConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetAuthFailureWarningConfigurationResponse">
		<wsdl:part name="parameters" element="tds:GetAuthFailureWarningConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetAuthFailureWarningConfigurationRequest">
		<wsdl:part name="parameters" element="tds:SetAuthFailureWarningConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetAuthFailureWarningConfigurationResponse">
		<wsdl:part name="parameters" element="tds:SetAuthFailureWarningConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCapabilitiesRequest">
		<wsdl:part name="parameters" element="tds:GetCapabilities"/>
	</wsdl:message>
	<wsdl:message name="GetCapabilitiesResponse">
		<wsdl:part name="parameters" element="tds:GetCapabilitiesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetHostnameRequest">
		<wsdl:part name="parameters" element="tds:GetHostname"/>
	</wsdl:message>
	<wsdl:message name="GetHostnameResponse">
		<wsdl:part name="parameters" element="tds:GetHostnameResponse"/>
	</wsdl:message>
	<wsdl:message name="SetHostnameRequest">
		<wsdl:part name="parameters" element="tds:SetHostname"/>
	</wsdl:message>
	<wsdl:message name="SetHostnameResponse">
		<wsdl:part name="parameters" element="tds:SetHostnameResponse"/>
	</wsdl:message>
	<wsdl:message name="SetHostnameFromDHCPRequest">
		<wsdl:part name="parameters" element="tds:SetHostnameFromDHCP"/>
	</wsdl:message>
	<wsdl:message name="SetHostnameFromDHCPResponse">
		<wsdl:part name="parameters" element="tds:SetHostnameFromDHCPResponse"/>
	</wsdl:message>
	<wsdl:message name="GetDNSRequest">
		<wsdl:part name="parameters" element="tds:GetDNS"/>
	</wsdl:message>
	<wsdl:message name="GetDNSResponse">
		<wsdl:part name="parameters" element="tds:GetDNSResponse"/>
	</wsdl:message>
	<wsdl:message name="SetDNSRequest">
		<wsdl:part name="parameters" element="tds:SetDNS"/>
	</wsdl:message>
	<wsdl:message name="SetDNSResponse">
		<wsdl:part name="parameters" element="tds:SetDNSResponse"/>
	</wsdl:message>
	<wsdl:message name="GetNTPRequest">
		<wsdl:part name="parameters" element="tds:GetNTP"/>
	</wsdl:message>
	<wsdl:message name="GetNTPResponse">
		<wsdl:part name="parameters" element="tds:GetNTPResponse"/>
	</wsdl:message>
	<wsdl:message name="SetNTPRequest">
		<wsdl:part name="parameters" element="tds:SetNTP"/>
	</wsdl:message>
	<wsdl:message name="SetNTPResponse">
		<wsdl:part name="parameters" element="tds:SetNTPResponse"/>
	</wsdl:message>
	<wsdl:message name="GetDynamicDNSRequest">
		<wsdl:part name="parameters" element="tds:GetDynamicDNS"/>
	</wsdl:message>
	<wsdl:message name="GetDynamicDNSResponse">
		<wsdl:part name="parameters" element="tds:GetDynamicDNSResponse"/>
	</wsdl:message>
	<wsdl:message name="SetDynamicDNSRequest">
		<wsdl:part name="parameters" element="tds:SetDynamicDNS"/>
	</wsdl:message>
	<wsdl:message name="SetDynamicDNSResponse">
		<wsdl:part name="parameters" element="tds:SetDynamicDNSResponse"/>
	</wsdl:message>
	<wsdl:message name="GetNetworkInterfacesRequest">
		<wsdl:part name="parameters" element="tds:GetNetworkInterfaces"/>
	</wsdl:message>
	<wsdl:message name="GetNetworkInterfacesResponse">
		<wsdl:part name="parameters" element="tds:GetNetworkInterfacesResponse"/>
	</wsdl:message>
	<wsdl:message name="SetNetworkInterfacesRequest">
		<wsdl:part name="parameters" element="tds:SetNetworkInterfaces"/>
	</wsdl:message>
	<wsdl:message name="SetNetworkInterfacesResponse">
		<wsdl:part name="parameters" element="tds:SetNetworkInterfacesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetNetworkProtocolsRequest">
		<wsdl:part name="parameters" element="tds:GetNetworkProtocols"/>
	</wsdl:message>
	<wsdl:message name="GetNetworkProtocolsResponse">
		<wsdl:part name="parameters" element="tds:GetNetworkProtocolsResponse"/>
	</wsdl:message>
	<wsdl:message name="SetNetworkProtocolsRequest">
		<wsdl:part name="parameters" element="tds:SetNetworkProtocols"/>
	</wsdl:message>
	<wsdl:message name="SetNetworkProtocolsResponse">
		<wsdl:part name="parameters" element="tds:SetNetworkProtocolsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetNetworkDefaultGatewayRequest">
		<wsdl:part name="parameters" element="tds:GetNetworkDefaultGateway"/>
	</wsdl:message>
	<wsdl:message name="GetNetworkDefaultGatewayResponse">
		<wsdl:part name="parameters" element="tds:GetNetworkDefaultGatewayResponse"/>
	</wsdl:message>
	<wsdl:message name="SetNetworkDefaultGatewayRequest">
		<wsdl:part name="parameters" element="tds:SetNetworkDefaultGateway"/>
	</wsdl:message>
	<wsdl:message name="SetNetworkDefaultGatewayResponse">
		<wsdl:part name="parameters" element="tds:SetNetworkDefaultGatewayResponse"/>
	</wsdl:message>
	<wsdl:message name="GetZeroConfigurationRequest">
		<wsdl:part name="parameters" element="tds:GetZeroConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetZeroConfigurationResponse">
		<wsdl:part name="parameters" element="tds:GetZeroConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetZeroConfigurationRequest">
		<wsdl:part name="parameters" element="tds:SetZeroConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetZeroConfigurationResponse">
		<wsdl:part name="parameters" element="tds:SetZeroConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetIPAddressFilterRequest">
		<wsdl:part name="parameters" element="tds:GetIPAddressFilter"/>
	</wsdl:message>
	<wsdl:message name="GetIPAddressFilterResponse">
		<wsdl:part name="parameters" element="tds:GetIPAddressFilterResponse"/>
	</wsdl:message>
	<wsdl:message name="SetIPAddressFilterRequest">
		<wsdl:part name="parameters" element="tds:SetIPAddressFilter"/>
	</wsdl:message>
	<wsdl:message name="SetIPAddressFilterResponse">
		<wsdl:part name="parameters" element="tds:SetIPAddressFilterResponse"/>
	</wsdl:message>
	<wsdl:message name="AddIPAddressFilterRequest">
		<wsdl:part name="parameters" element="tds:AddIPAddressFilter"/>
	</wsdl:message>
	<wsdl:message name="AddIPAddressFilterResponse">
		<wsdl:part name="parameters" element="tds:AddIPAddressFilterResponse"/>
	</wsdl:message>
	<wsdl:message name="RemoveIPAddressFilterRequest">
		<wsdl:part name="parameters" element="tds:RemoveIPAddressFilter"/>
	</wsdl:message>
	<wsdl:message name="RemoveIPAddressFilterResponse">
		<wsdl:part name="parameters" element="tds:RemoveIPAddressFilterResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAccessPolicyRequest">
		<wsdl:part name="parameters" element="tds:GetAccessPolicy"/>
	</wsdl:message>
	<wsdl:message name="GetAccessPolicyResponse">
		<wsdl:part name="parameters" element="tds:GetAccessPolicyResponse"/>
	</wsdl:message>
	<wsdl:message name="SetAccessPolicyRequest">
		<wsdl:part name="parameters" element="tds:SetAccessPolicy"/>
	</wsdl:message>
	<wsdl:message name="SetAccessPolicyResponse">
		<wsdl:part name="parameters" element="tds:SetAccessPolicyResponse"/>
	</wsdl:message>
	<wsdl:message name="CreateCertificateRequest">
		<wsdl:part name="parameters" element="tds:CreateCertificate"/>
	</wsdl:message>
	<wsdl:message name="CreateCertificateResponse">
		<wsdl:part name="parameters" element="tds:CreateCertificateResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCertificatesRequest">
		<wsdl:part name="parameters" element="tds:GetCertificates"/>
	</wsdl:message>
	<wsdl:message name="GetCertificatesResponse">
		<wsdl:part name="parameters" element="tds:GetCertificatesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCertificatesStatusRequest">
		<wsdl:part name="parameters" element="tds:GetCertificatesStatus"/>
	</wsdl:message>
	<wsdl:message name="GetCertificatesStatusResponse">
		<wsdl:part name="parameters" element="tds:GetCertificatesStatusResponse"/>
	</wsdl:message>
	<wsdl:message name="SetCertificatesStatusRequest">
		<wsdl:part name="parameters" element="tds:SetCertificatesStatus"/>
	</wsdl:message>
	<wsdl:message name="SetCertificatesStatusResponse">
		<wsdl:part name="parameters" element="tds:SetCertificatesStatusResponse"/>
	</wsdl:message>
	<wsdl:message name="DeleteCertificatesRequest">
		<wsdl:part name="parameters" element="tds:DeleteCertificates"/>
	</wsdl:message>
	<wsdl:message name="DeleteCertificatesResponse">
		<wsdl:part name="parameters" element="tds:DeleteCertificatesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetPkcs10RequestRequest">
		<wsdl:part name="parameters" element="tds:GetPkcs10Request"/>
	</wsdl:message>
	<wsdl:message name="GetPkcs10RequestResponse">
		<wsdl:part name="parameters" element="tds:GetPkcs10RequestResponse"/>
	</wsdl:message>
	<wsdl:message name="LoadCertificatesRequest">
		<wsdl:part name="parameters" element="tds:LoadCertificates"/>
	</wsdl:message>
	<wsdl:message name="LoadCertificatesResponse">
		<wsdl:part name="parameters" element="tds:LoadCertificatesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetClientCertificateModeRequest">
		<wsdl:part name="parameters" element="tds:GetClientCertificateMode"/>
	</wsdl:message>
	<wsdl:message name="GetClientCertificateModeResponse">
		<wsdl:part name="parameters" element="tds:GetClientCertificateModeResponse"/>
	</wsdl:message>
	<wsdl:message name="SetClientCertificateModeRequest">
		<wsdl:part name="parameters" element="tds:SetClientCertificateMode"/>
	</wsdl:message>
	<wsdl:message name="SetClientCertificateModeResponse">
		<wsdl:part name="parameters" element="tds:SetClientCertificateModeResponse"/>
	</wsdl:message>
	<wsdl:message name="GetRelayOutputsRequest">
		<wsdl:part name="parameters" element="tds:GetRelayOutputs"/>
	</wsdl:message>
	<wsdl:message name="GetRelayOutputsResponse">
		<wsdl:part name="parameters" element="tds:GetRelayOutputsResponse"/>
	</wsdl:message>
	<wsdl:message name="SetRelayOutputSettingsRequest">
		<wsdl:part name="parameters" element="tds:SetRelayOutputSettings"/>
	</wsdl:message>
	<wsdl:message name="SetRelayOutputSettingsResponse">
		<wsdl:part name="parameters" element="tds:SetRelayOutputSettingsResponse"/>
	</wsdl:message>
	<wsdl:message name="SetRelayOutputStateRequest">
		<wsdl:part name="parameters" element="tds:SetRelayOutputState"/>
	</wsdl:message>
	<wsdl:message name="SetRelayOutputStateResponse">
		<wsdl:part name="parameters" element="tds:SetRelayOutputStateResponse"/>
	</wsdl:message>
	<wsdl:message name="SendAuxiliaryCommandRequest">
		<wsdl:part name="parameters" element="tds:SendAuxiliaryCommand"/>
	</wsdl:message>
	<wsdl:message name="SendAuxiliaryCommandResponse">
		<wsdl:part name="parameters" element="tds:SendAuxiliaryCommandResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCACertificatesRequest">
		<wsdl:part name="parameters" element="tds:GetCACertificates"/>
	</wsdl:message>
	<wsdl:message name="GetCACertificatesResponse">
		<wsdl:part name="parameters" element="tds:GetCACertificatesResponse"/>
	</wsdl:message>
	<wsdl:message name="LoadCertificateWithPrivateKeyRequest">
		<wsdl:part name="parameters" element="tds:LoadCertificateWithPrivateKey"/>
	</wsdl:message>
	<wsdl:message name="LoadCertificateWithPrivateKeyResponse">
		<wsdl:part name="parameters" element="tds:LoadCertificateWithPrivateKeyResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCertificateInformationRequest">
		<wsdl:part name="parameters" element="tds:GetCertificateInformation"/>
	</wsdl:message>
	<wsdl:message name="GetCertificateInformationResponse">
		<wsdl:part name="parameters" element="tds:GetCertificateInformationResponse"/>
	</wsdl:message>
	<wsdl:message name="LoadCACertificatesRequest">
		<wsdl:part name="parameters" element="tds:LoadCACertificates"/>
	</wsdl:message>
	<wsdl:message name="LoadCACertificatesResponse">
		<wsdl:part name="parameters" element="tds:LoadCACertificatesResponse"/>
	</wsdl:message>
	<wsdl:message name="CreateDot1XConfigurationRequest">
		<wsdl:part name="parameters" element="tds:CreateDot1XConfiguration"/>
	</wsdl:message>
	<wsdl:message name="CreateDot1XConfigurationResponse">
		<wsdl:part name="parameters" element="tds:CreateDot1XConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetDot1XConfigurationRequest">
		<wsdl:part name="parameters" element="tds:SetDot1XConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetDot1XConfigurationResponse">
		<wsdl:part name="parameters" element="tds:SetDot1XConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetDot1XConfigurationRequest">
		<wsdl:part name="parameters" element="tds:GetDot1XConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetDot1XConfigurationResponse">
		<wsdl:part name="parameters" element="tds:GetDot1XConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetDot1XConfigurationsRequest">
		<wsdl:part name="parameters" element="tds:GetDot1XConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetDot1XConfigurationsResponse">
		<wsdl:part name="parameters" element="tds:GetDot1XConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="DeleteDot1XConfigurationRequest">
		<wsdl:part name="parameters" element="tds:DeleteDot1XConfiguration"/>
	</wsdl:message>
	<wsdl:message name="DeleteDot1XConfigurationResponse">
		<wsdl:part name="parameters" element="tds:DeleteDot1XConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetDot11CapabilitiesRequest">
		<wsdl:part name="parameters" element="tds:GetDot11Capabilities"/>
	</wsdl:message>
	<wsdl:message name="GetDot11CapabilitiesResponse">
		<wsdl:part name="parameters" element="tds:GetDot11CapabilitiesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetDot11StatusRequest">
		<wsdl:part name="parameters" element="tds:GetDot11Status"/>
	</wsdl:message>
	<wsdl:message name="GetDot11StatusResponse">
		<wsdl:part name="parameters" element="tds:GetDot11StatusResponse"/>
	</wsdl:message>
	<wsdl:message name="ScanAvailableDot11NetworksRequest">
		<wsdl:part name="parameters" element="tds:ScanAvailableDot11Networks"/>
	</wsdl:message>
	<wsdl:message name="ScanAvailableDot11NetworksResponse">
		<wsdl:part name="parameters" element="tds:ScanAvailableDot11NetworksResponse"/>
	</wsdl:message>
	<wsdl:message name="GetSystemUrisRequest">
		<wsdl:part name="parameters" element="tds:GetSystemUris"/>
	</wsdl:message>
	<wsdl:message name="GetSystemUrisResponse">
		<wsdl:part name="parameters" element="tds:GetSystemUrisResponse"/>
	</wsdl:message>
	<wsdl:message name="StartFirmwareUpgradeRequest">
		<wsdl:part name="parameters" element="tds:StartFirmwareUpgrade"/>
	</wsdl:message>
	<wsdl:message name="StartFirmwareUpgradeResponse">
		<wsdl:part name="parameters" element="tds:StartFirmwareUpgradeResponse"/>
	</wsdl:message>
	<wsdl:message name="StartSystemRestoreRequest">
		<wsdl:part name="parameters" element="tds:StartSystemRestore"/>
	</wsdl:message>
	<wsdl:message name="StartSystemRestoreResponse">
		<wsdl:part name="parameters" element="tds:StartSystemRestoreResponse"/>
	</wsdl:message>
	
	<wsdl:message name="GetStorageConfigurationsRequest">
		<wsdl:part name="parameters" element="tds:GetStorageConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetStorageConfigurationsResponse">
		<wsdl:part name="parameters" element="tds:GetStorageConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="CreateStorageConfigurationRequest">
		<wsdl:part name="parameters" element="tds:CreateStorageConfiguration"/>
	</wsdl:message>
	<wsdl:message name="CreateStorageConfigurationResponse">
		<wsdl:part name="parameters" element="tds:CreateStorageConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetStorageConfigurationRequest">
		<wsdl:part name="parameters" element="tds:GetStorageConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetStorageConfigurationResponse">
		<wsdl:part name="parameters" element="tds:GetStorageConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetStorageConfigurationRequest">
		<wsdl:part name="parameters" element="tds:SetStorageConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetStorageConfigurationResponse">
		<wsdl:part name="parameters" element="tds:SetStorageConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="DeleteStorageConfigurationRequest">
		<wsdl:part name="parameters" element="tds:DeleteStorageConfiguration"/>
	</wsdl:message>
	<wsdl:message name="DeleteStorageConfigurationResponse">
		<wsdl:part name="parameters" element="tds:DeleteStorageConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetGeoLocationRequest">
		<wsdl:part name="parameters" element="tds:GetGeoLocation"/>
	</wsdl:message>
	<wsdl:message name="GetGeoLocationResponse">
		<wsdl:part name="parameters" element="tds:GetGeoLocationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetGeoLocationRequest">
		<wsdl:part name="parameters" element="tds:SetGeoLocation"/>
	</wsdl:message>
	<wsdl:message name="SetGeoLocationResponse">
		<wsdl:part name="parameters" element="tds:SetGeoLocationResponse"/>
	</wsdl:message>
	<wsdl:message name="DeleteGeoLocationRequest">
		<wsdl:part name="parameters" element="tds:DeleteGeoLocation"/>
	</wsdl:message>
	<wsdl:message name="DeleteGeoLocationResponse">
		<wsdl:part name="parameters" element="tds:DeleteGeoLocationResponse"/>
	</wsdl:message>	
	<wsdl:message name="SetHashingAlgorithmRequest">
		<wsdl:part name="parameters" element="tds:SetHashingAlgorithm"/>
	</wsdl:message>
	<wsdl:message name="SetHashingAlgorithmResponse">
		<wsdl:part name="parameters" element="tds:SetHashingAlgorithmResponse"/>
	</wsdl:message>
	
	<wsdl:portType name="Device">
		<wsdl:operation name="GetServices">
			<wsdl:documentation>Returns information about services on the device.</wsdl:documentation>
			<wsdl:input message="tds:GetServicesRequest"/>
			<wsdl:output message="tds:GetServicesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetServiceCapabilities">
			<wsdl:documentation>Returns the capabilities of the device service. The result is returned in a typed answer.</wsdl:documentation>
			<wsdl:input message="tds:GetServiceCapabilitiesRequest"/>
			<wsdl:output message="tds:GetServiceCapabilitiesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetDeviceInformation">
			<wsdl:documentation>This operation gets basic device information from the device.</wsdl:documentation>
			<wsdl:input message="tds:GetDeviceInformationRequest"/>
			<wsdl:output message="tds:GetDeviceInformationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetSystemDateAndTime">
			<wsdl:documentation>This operation sets the device system date and time. The device shall support the
				configuration of the daylight saving setting and of the manual system date and time (if
				applicable) or indication of NTP time (if applicable) through the SetSystemDateAndTime
				command. <br/>
				If system time and date are set manually, the client shall include UTCDateTime in the request.<br/>
				A TimeZone token which is not formed according to the rules of IEEE 1003.1 section 8.3 is considered as invalid timezone.<br/>
				The DayLightSavings flag should be set to true to activate any DST settings of the TimeZone string. 
				Clear the DayLightSavings flag if the DST portion of the TimeZone settings should be ignored.
			</wsdl:documentation>
			<wsdl:input message="tds:SetSystemDateAndTimeRequest"/>
			<wsdl:output message="tds:SetSystemDateAndTimeResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetSystemDateAndTime">
			<wsdl:documentation>This operation gets the device system date and time. The device shall support the return of
				the daylight saving setting and of the manual system date and time (if applicable) or indication
				of NTP time (if applicable) through the GetSystemDateAndTime command.<br/>
				A device shall provide the UTCDateTime information.</wsdl:documentation>
			<wsdl:input message="tds:GetSystemDateAndTimeRequest"/>
			<wsdl:output message="tds:GetSystemDateAndTimeResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetSystemFactoryDefault">
			<wsdl:documentation>This operation reloads the parameters on the device to their factory default values.</wsdl:documentation>
			<wsdl:input message="tds:SetSystemFactoryDefaultRequest"/>
			<wsdl:output message="tds:SetSystemFactoryDefaultResponse"/>
		</wsdl:operation>
		<wsdl:operation name="UpgradeSystemFirmware">
			<wsdl:documentation>This operation upgrades a device firmware version. After a successful upgrade the response
				message is sent before the device reboots. The device should support firmware upgrade
				through the UpgradeSystemFirmware command. The exact format of the firmware data is
				outside the scope of this standard.</wsdl:documentation>
			<wsdl:input message="tds:UpgradeSystemFirmwareRequest"/>
			<wsdl:output message="tds:UpgradeSystemFirmwareResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SystemReboot">
			<wsdl:documentation>This operation reboots the device.</wsdl:documentation>
			<wsdl:input message="tds:SystemRebootRequest"/>
			<wsdl:output message="tds:SystemRebootResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RestoreSystem">
			<wsdl:documentation>This operation restores the system backup configuration files(s) previously retrieved from a
				device. The device should support restore of backup configuration file(s) through the
				RestoreSystem command. The exact format of the backup configuration file(s) is outside the
				scope of this standard. If the command is supported, it shall accept backup files returned by
				the GetSystemBackup command.</wsdl:documentation>
			<wsdl:input message="tds:RestoreSystemRequest"/>
			<wsdl:output message="tds:RestoreSystemResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetSystemBackup">
			<wsdl:documentation>This operation is retrieves system backup configuration file(s) from a device. The device
				should support return of back up configuration file(s) through the GetSystemBackup command.
				The backup is returned with reference to a name and mime-type together with binary data.
				The exact format of the backup configuration files is outside the scope of this standard.</wsdl:documentation>
			<wsdl:input message="tds:GetSystemBackupRequest"/>
			<wsdl:output message="tds:GetSystemBackupResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetSystemLog">
			<wsdl:documentation>This operation gets a system log from the device. The exact format of the system logs is outside the scope of this standard.</wsdl:documentation>
			<wsdl:input message="tds:GetSystemLogRequest"/>
			<wsdl:output message="tds:GetSystemLogResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetSystemSupportInformation">
			<wsdl:documentation>This operation gets arbitary device diagnostics information from the device.</wsdl:documentation>
			<wsdl:input message="tds:GetSystemSupportInformationRequest"/>
			<wsdl:output message="tds:GetSystemSupportInformationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetScopes">
			<wsdl:documentation>This operation requests the scope parameters of a device. The scope parameters are used in
				the device discovery to match a probe message, see Section 7. The Scope parameters are of
				two different types: <ul>
					<li>Fixed</li>
					<li>Configurable</li>
				</ul>
				Fixed scope parameters are permanent device characteristics and cannot be removed through the device management interface. 
				The scope type is indicated in the scope list returned in the get scope parameters response. A device shall support 
				retrieval of discovery scope parameters through the GetScopes command. As some scope parameters are mandatory, 
				the device shall return a non-empty scope list in the response.</wsdl:documentation>
			<wsdl:input message="tds:GetScopesRequest"/>
			<wsdl:output message="tds:GetScopesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetScopes">
			<wsdl:documentation>This operation sets the scope parameters of a device. The scope parameters are used in the
				device discovery to match a probe message.
				This operation replaces all existing configurable scope parameters (not fixed parameters). If
				this shall be avoided, one should use the scope add command instead. The device shall
				support configuration of discovery scope parameters through the SetScopes command.</wsdl:documentation>
			<wsdl:input message="tds:SetScopesRequest"/>
			<wsdl:output message="tds:SetScopesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddScopes">
			<wsdl:documentation>This operation adds new configurable scope parameters to a device. The scope parameters
				are used in the device discovery to match a probe message. The device shall
				support addition of discovery scope parameters through the AddScopes command.</wsdl:documentation>
			<wsdl:input message="tds:AddScopesRequest"/>
			<wsdl:output message="tds:AddScopesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemoveScopes">
			<wsdl:documentation>This operation deletes scope-configurable scope parameters from a device. The scope
				parameters are used in the device discovery to match a probe message, see Section 7. The
				device shall support deletion of discovery scope parameters through the RemoveScopes
				command.
				Table</wsdl:documentation>
			<wsdl:input message="tds:RemoveScopesRequest"/>
			<wsdl:output message="tds:RemoveScopesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetDiscoveryMode">
			<wsdl:documentation>This operation gets the discovery mode of a device. See Section 7.2 for the definition of the
				different device discovery modes. The device shall support retrieval of the discovery mode
				setting through the GetDiscoveryMode command.</wsdl:documentation>
			<wsdl:input message="tds:GetDiscoveryModeRequest"/>
			<wsdl:output message="tds:GetDiscoveryModeResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetDiscoveryMode">
			<wsdl:documentation>This operation sets the discovery mode operation of a device. See Section 7.2 for the
				definition of the different device discovery modes. The device shall support configuration of
				the discovery mode setting through the SetDiscoveryMode command.</wsdl:documentation>
			<wsdl:input message="tds:SetDiscoveryModeRequest"/>
			<wsdl:output message="tds:SetDiscoveryModeResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetRemoteDiscoveryMode">
			<wsdl:documentation>This operation gets the remote discovery mode of a device. See Section 7.4 for the definition
				of remote discovery extensions. A device that supports remote discovery shall support
				retrieval of the remote discovery mode setting through the GetRemoteDiscoveryMode
				command.</wsdl:documentation>
			<wsdl:input message="tds:GetRemoteDiscoveryModeRequest"/>
			<wsdl:output message="tds:GetRemoteDiscoveryModeResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetRemoteDiscoveryMode">
			<wsdl:documentation>This operation sets the remote discovery mode of operation of a device. See Section 7.4 for
				the definition of remote discovery remote extensions. A device that supports remote discovery
				shall support configuration of the discovery mode setting through the
				SetRemoteDiscoveryMode command.</wsdl:documentation>
			<wsdl:input message="tds:SetRemoteDiscoveryModeRequest"/>
			<wsdl:output message="tds:SetRemoteDiscoveryModeResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetDPAddresses">
			<wsdl:documentation>This operation gets the remote DP address or addresses from a device. If the device supports
				remote discovery, as specified in Section 7.4, the device shall support retrieval of the remote
				DP address(es) through the GetDPAddresses command.</wsdl:documentation>
			<wsdl:input message="tds:GetDPAddressesRequest"/>
			<wsdl:output message="tds:GetDPAddressesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetDPAddresses">
			<wsdl:documentation>This operation sets the remote DP address or addresses on a device. If the device supports
				remote discovery, as specified in Section 7.4, the device shall support configuration of the
				remote DP address(es) through the SetDPAddresses command.</wsdl:documentation>
			<wsdl:input message="tds:SetDPAddressesRequest"/>
			<wsdl:output message="tds:SetDPAddressesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetEndpointReference">
			<wsdl:documentation>A client can ask for the device service endpoint reference address property that can be used
				to derive the password equivalent for remote user operation. The device shall support the
				GetEndpointReference command returning the address property of the device service
				endpoint reference.</wsdl:documentation>
			<wsdl:input message="tds:GetEndpointReferenceRequest"/>
			<wsdl:output message="tds:GetEndpointReferenceResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetRemoteUser">
			<wsdl:documentation>This operation returns the configured remote user (if any). A device supporting remote user
				handling shall support this operation. The user is only valid for the WS-UserToken profile or
				as an HTTP / RTSP user.<br/>
				The algorithm to use for deriving the password is described in section 5.12.2.1 of the core specification.</wsdl:documentation>
			<wsdl:input message="tds:GetRemoteUserRequest"/>
			<wsdl:output message="tds:GetRemoteUserResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetRemoteUser">
			<wsdl:documentation>This operation sets the remote user. A device supporting remote user handling shall support this
				operation. The user is only valid for the WS-UserToken profile or as an HTTP / RTSP user.<br/>
				The password that is set shall always be the original (not derived) password.<br/>
				If UseDerivedPassword is set password derivation shall be done by the device when connecting to a
				remote device.The algorithm to use for deriving the password is described in section 5.12.2.1 of the core specification.<br/>
				To remove the remote user SetRemoteUser should be called without the RemoteUser parameter.</wsdl:documentation>
			<wsdl:input message="tds:SetRemoteUserRequest"/>
			<wsdl:output message="tds:SetRemoteUserResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetUsers">
			<wsdl:documentation>This operation lists the registered users and corresponding credentials on a device. The
				device shall support retrieval of registered device users and their credentials for the user
				token through the GetUsers command.</wsdl:documentation>
			<wsdl:input message="tds:GetUsersRequest"/>
			<wsdl:output message="tds:GetUsersResponse"/>
		</wsdl:operation>
		<wsdl:operation name="CreateUsers">
			<wsdl:documentation>This operation creates new device users and corresponding credentials on a device for authentication purposes. 
				The device shall support creation of device users and their credentials through the CreateUsers
				command. Either all users are created successfully or a fault message shall be returned
				without creating any user.<br/>
				ONVIF compliant devices are recommended to support password length of at least 28 bytes,
				as clients may follow the password derivation mechanism which results in 'password
				equivalent' of length 28 bytes, as described in section 3.1.2 of the ONVIF security white paper.</wsdl:documentation>
			<wsdl:input message="tds:CreateUsersRequest"/>
			<wsdl:output message="tds:CreateUsersResponse"/>
		</wsdl:operation>
		<wsdl:operation name="DeleteUsers">
			<wsdl:documentation>This operation deletes users on a device. The device shall support deletion of device users and their credentials 
				through the DeleteUsers command. A device may have one or more fixed users
				that cannot be deleted to ensure access to the unit. Either all users are deleted successfully or a
				fault message shall be returned and no users be deleted.</wsdl:documentation>
			<wsdl:input message="tds:DeleteUsersRequest"/>
			<wsdl:output message="tds:DeleteUsersResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetUser">
			<wsdl:documentation>This operation updates the settings for one or several users on a device for authentication purposes.
				The device shall support update of device users and their credentials through the SetUser command. 
				Either all change requests are processed successfully or a fault message shall be returned and no change requests be processed.</wsdl:documentation>
			<wsdl:input message="tds:SetUserRequest"/>
			<wsdl:output message="tds:SetUserResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetWsdlUrl">
			<wsdl:documentation>This method allows to provide a URL where product specific WSDL and schema definitions can be retrieved. This method is deprecated.</wsdl:documentation>
			<wsdl:input message="tds:GetWsdlUrlRequest"/>
			<wsdl:output message="tds:GetWsdlUrlResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetPasswordComplexityOptions">
			<wsdl:documentation>This method allows retrieval of all the available parameters and their valid ranges for the password complexity configuration.</wsdl:documentation>
			<wsdl:input message="tds:GetPasswordComplexityOptionsRequest"/>
			<wsdl:output message="tds:GetPasswordComplexityOptionsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetPasswordComplexityConfiguration">
			<wsdl:documentation>This method allows retrieval of the current password complexity configuration settings.</wsdl:documentation>
			<wsdl:input message="tds:GetPasswordComplexityConfigurationRequest"/>
			<wsdl:output message="tds:GetPasswordComplexityConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetPasswordComplexityConfiguration">
			<wsdl:documentation>This method allows setting of the password complexity configuration.</wsdl:documentation>
			<wsdl:input message="tds:SetPasswordComplexityConfigurationRequest"/>
			<wsdl:output message="tds:SetPasswordComplexityConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetPasswordHistoryConfiguration">
			<wsdl:documentation>This method allows retrieval of the current password history configuration settings.</wsdl:documentation>
			<wsdl:input message="tds:GetPasswordHistoryConfigurationRequest"/>
			<wsdl:output message="tds:GetPasswordHistoryConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetPasswordHistoryConfiguration">
			<wsdl:documentation>This method allows setting of the password history configuration.</wsdl:documentation>
			<wsdl:input message="tds:SetPasswordHistoryConfigurationRequest"/>
			<wsdl:output message="tds:SetPasswordHistoryConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAuthFailureWarningOptions">
			<wsdl:documentation>This method allows retrieval of all the available parameters and their valid ranges for the authentication failure warning configuration.</wsdl:documentation>
			<wsdl:input message="tds:GetAuthFailureWarningOptionsRequest"/>
			<wsdl:output message="tds:GetAuthFailureWarningOptionsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAuthFailureWarningConfiguration">
			<wsdl:documentation>This method allows retrieval of the current authentication failure warning configuration settings.</wsdl:documentation>
			<wsdl:input message="tds:GetAuthFailureWarningConfigurationRequest"/>
			<wsdl:output message="tds:GetAuthFailureWarningConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetAuthFailureWarningConfiguration">
			<wsdl:documentation>This method allows setting of the authentication failure warning configuration.</wsdl:documentation>
			<wsdl:input message="tds:SetAuthFailureWarningConfigurationRequest"/>
			<wsdl:output message="tds:SetAuthFailureWarningConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCapabilities">
			<wsdl:documentation>This method has been replaced by the more generic GetServices method.
			 For capabilities of individual services refer to the GetServiceCapabilities methods.</wsdl:documentation>
			<wsdl:input message="tds:GetCapabilitiesRequest"/>
			<wsdl:output message="tds:GetCapabilitiesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetHostname">
			<wsdl:documentation>This operation is used by an endpoint to get the hostname from a device. The device shall
				return its hostname configurations through the GetHostname command.</wsdl:documentation>
			<wsdl:input message="tds:GetHostnameRequest"/>
			<wsdl:output message="tds:GetHostnameResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetHostname">
			<wsdl:documentation>This operation sets the hostname on a device. It shall be possible to set the device hostname
				configurations through the SetHostname command.<br/>
				A device shall accept string formated according to RFC 1123 section 2.1 or alternatively to RFC 952, 
				other string shall be considered as invalid strings. 
			</wsdl:documentation>
			<wsdl:input message="tds:SetHostnameRequest"/>
			<wsdl:output message="tds:SetHostnameResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetHostnameFromDHCP">
			<wsdl:documentation>This operation controls whether the hostname is set manually or retrieved via DHCP.</wsdl:documentation>
			<wsdl:input message="tds:SetHostnameFromDHCPRequest"/>
			<wsdl:output message="tds:SetHostnameFromDHCPResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetDNS">
			<wsdl:documentation>This operation gets the DNS settings from a device. The device shall return its DNS
				configurations through the GetDNS command.</wsdl:documentation>
			<wsdl:input message="tds:GetDNSRequest"/>
			<wsdl:output message="tds:GetDNSResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetDNS">
			<wsdl:documentation>This operation sets the DNS settings on a device. It shall be possible to set the device DNS
				configurations through the SetDNS command.</wsdl:documentation>
			<wsdl:input message="tds:SetDNSRequest"/>
			<wsdl:output message="tds:SetDNSResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetNTP">
			<wsdl:documentation>This operation gets the NTP settings from a device. If the device supports NTP, it shall be
				possible to get the NTP server settings through the GetNTP command.</wsdl:documentation>
			<wsdl:input message="tds:GetNTPRequest"/>
			<wsdl:output message="tds:GetNTPResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetNTP">
			<wsdl:documentation>This operation sets the NTP settings on a device. If the device supports NTP, it shall be
				possible to set the NTP server settings through the SetNTP command.<br/>
				A device shall accept string formated according to RFC 1123 section 2.1 or alternatively to RFC 952, 
				other string shall be considered as invalid strings. <br/>
				Changes to the NTP server list will not affect the clock mode DateTimeType. Use SetSystemDateAndTime to activate NTP operation.
			</wsdl:documentation>
			<wsdl:input message="tds:SetNTPRequest"/>
			<wsdl:output message="tds:SetNTPResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetDynamicDNS">
			<wsdl:documentation>This operation gets the dynamic DNS settings from a device. If the device supports dynamic
				DNS as specified in [RFC 2136] and [RFC 4702], it shall be possible to get the type, name
				and TTL through the GetDynamicDNS command.</wsdl:documentation>
			<wsdl:input message="tds:GetDynamicDNSRequest"/>
			<wsdl:output message="tds:GetDynamicDNSResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetDynamicDNS">
			<wsdl:documentation>This operation sets the dynamic DNS settings on a device. If the device supports dynamic
				DNS as specified in [RFC 2136] and [RFC 4702], it shall be possible to set the type, name
				and TTL through the SetDynamicDNS command.</wsdl:documentation>
			<wsdl:input message="tds:SetDynamicDNSRequest"/>
			<wsdl:output message="tds:SetDynamicDNSResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetNetworkInterfaces">
			<wsdl:documentation>This operation gets the network interface configuration from a device. The device shall
				support return of network interface configuration settings as defined by the NetworkInterface
				type through the GetNetworkInterfaces command.</wsdl:documentation>
			<wsdl:input message="tds:GetNetworkInterfacesRequest"/>
			<wsdl:output message="tds:GetNetworkInterfacesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetNetworkInterfaces">
			<wsdl:documentation>This operation sets the network interface configuration on a device. The device shall support
				network configuration of supported network interfaces through the SetNetworkInterfaces
				command.<br/>
				For interoperability with a client unaware of the IEEE 802.11 extension a device shall retain
				its IEEE 802.11 configuration if the IEEE 802.11 configuration element isnt present in the
				request.</wsdl:documentation>
			<wsdl:input message="tds:SetNetworkInterfacesRequest"/>
			<wsdl:output message="tds:SetNetworkInterfacesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetNetworkProtocols">
			<wsdl:documentation>This operation gets defined network protocols from a device. The device shall support the
				GetNetworkProtocols command returning configured network protocols.</wsdl:documentation>
			<wsdl:input message="tds:GetNetworkProtocolsRequest"/>
			<wsdl:output message="tds:GetNetworkProtocolsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetNetworkProtocols">
			<wsdl:documentation>This operation configures defined network protocols on a device. The device shall support
				configuration of defined network protocols through the SetNetworkProtocols command.</wsdl:documentation>
			<wsdl:input message="tds:SetNetworkProtocolsRequest"/>
			<wsdl:output message="tds:SetNetworkProtocolsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetNetworkDefaultGateway">
			<wsdl:documentation>This operation gets the default gateway settings from a device. The device shall support the
				GetNetworkDefaultGateway command returning configured default gateway address(es).</wsdl:documentation>
			<wsdl:input message="tds:GetNetworkDefaultGatewayRequest"/>
			<wsdl:output message="tds:GetNetworkDefaultGatewayResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetNetworkDefaultGateway">
			<wsdl:documentation>This operation sets the default gateway settings on a device. The device shall support
				configuration of default gateway through the SetNetworkDefaultGateway command.</wsdl:documentation>
			<wsdl:input message="tds:SetNetworkDefaultGatewayRequest"/>
			<wsdl:output message="tds:SetNetworkDefaultGatewayResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetZeroConfiguration">
			<wsdl:documentation>This operation gets the zero-configuration from a device. If the device supports dynamic IP
				configuration according to [RFC3927], it shall support the return of IPv4 zero configuration
				address and status through the GetZeroConfiguration command.<br/>
			Devices supporting zero configuration on more than one interface shall use the extension to list the additional interface settings.</wsdl:documentation>
			<wsdl:input message="tds:GetZeroConfigurationRequest"/>
			<wsdl:output message="tds:GetZeroConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetZeroConfiguration">
			<wsdl:documentation>This operation sets the zero-configuration. Use GetCapalities to get if zero-zero-configuration is supported or not.</wsdl:documentation>
			<wsdl:input message="tds:SetZeroConfigurationRequest"/>
			<wsdl:output message="tds:SetZeroConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetIPAddressFilter">
			<wsdl:documentation>This operation gets the IP address filter settings from a device. If the device supports device
				access control based on IP filtering rules (denied or accepted ranges of IP addresses), the
				device shall support the GetIPAddressFilter command.</wsdl:documentation>
			<wsdl:input message="tds:GetIPAddressFilterRequest"/>
			<wsdl:output message="tds:GetIPAddressFilterResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetIPAddressFilter">
			<wsdl:documentation>This operation sets the IP address filter settings on a device. If the device supports device
				access control based on IP filtering rules (denied or accepted ranges of IP addresses), the
				device shall support configuration of IP filtering rules through the SetIPAddressFilter
				command.</wsdl:documentation>
			<wsdl:input message="tds:SetIPAddressFilterRequest"/>
			<wsdl:output message="tds:SetIPAddressFilterResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddIPAddressFilter">
			<wsdl:documentation>This operation adds an IP filter address to a device. If the device supports device access
				control based on IP filtering rules (denied or accepted ranges of IP addresses), the device
				shall support adding of IP filtering addresses through the AddIPAddressFilter command.</wsdl:documentation>
			<wsdl:input message="tds:AddIPAddressFilterRequest"/>
			<wsdl:output message="tds:AddIPAddressFilterResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemoveIPAddressFilter">
			<wsdl:documentation>This operation deletes an IP filter address from a device. If the device supports device access
				control based on IP filtering rules (denied or accepted ranges of IP addresses), the device
				shall support deletion of IP filtering addresses through the RemoveIPAddressFilter command.</wsdl:documentation>
			<wsdl:input message="tds:RemoveIPAddressFilterRequest"/>
			<wsdl:output message="tds:RemoveIPAddressFilterResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAccessPolicy">
			<wsdl:documentation>Access to different services and sub-sets of services should be subject to access control. The
				WS-Security framework gives the prerequisite for end-point authentication. Authorization
				decisions can then be taken using an access security policy. This standard does not mandate
				any particular policy description format or security policy but this is up to the device
				manufacturer or system provider to choose policy and policy description format of choice.
				However, an access policy (in arbitrary format) can be requested using this command. If the
				device supports access policy settings based on WS-Security authentication, then the device
				shall support this command.</wsdl:documentation>
			<wsdl:input message="tds:GetAccessPolicyRequest"/>
			<wsdl:output message="tds:GetAccessPolicyResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetAccessPolicy">
			<wsdl:documentation>This command sets the device access security policy (for more details on the access security
				policy see the Get command). If the device supports access policy settings
				based on WS-Security authentication, then the device shall support this command.</wsdl:documentation>
			<wsdl:input message="tds:SetAccessPolicyRequest"/>
			<wsdl:output message="tds:SetAccessPolicyResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetRelayOutputs">
			<wsdl:documentation>This operation gets a list of all available relay outputs and their settings.<br/>
				This method has been depricated with version 2.0. Refer to the DeviceIO service.</wsdl:documentation>
			<wsdl:input message="tds:GetRelayOutputsRequest"/>
			<wsdl:output message="tds:GetRelayOutputsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetRelayOutputSettings">
			<wsdl:documentation>This operation sets the settings of a relay output.
				<br/>This method has been depricated with version 2.0. Refer to the DeviceIO service.</wsdl:documentation>
			<wsdl:input message="tds:SetRelayOutputSettingsRequest"/>
			<wsdl:output message="tds:SetRelayOutputSettingsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetRelayOutputState">
			<wsdl:documentation>This operation sets the state of a relay output.
				<br/>This method has been depricated with version 2.0. Refer to the DeviceIO service.</wsdl:documentation>
			<wsdl:input message="tds:SetRelayOutputStateRequest"/>
			<wsdl:output message="tds:SetRelayOutputStateResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SendAuxiliaryCommand">
			<wsdl:documentation>Manage auxiliary commands supported by a device, such as controlling an Infrared (IR) lamp, 
				a heater or a wiper or a thermometer that is connected to the device.<br/>
				The supported commands can be retrieved via the AuxiliaryCommands capability.<br/>
				Although the name of the auxiliary commands can be freely defined, commands starting with the prefix tt: are 
				reserved to define frequently used commands and these reserved commands shall all share the "tt:command|parameter" syntax.
				<ul>
					<li>tt:Wiper|On  Request to start the wiper.</li>
					<li>tt:Wiper|Off  Request to stop the wiper.</li>
					<li>tt:Washer|On  Request to start the washer.</li>
					<li>tt:Washer|Off  Request to stop the washer.</li>
					<li>tt:WashingProcedure|On  Request to start the washing procedure.</li>
					<li>tt: WashingProcedure |Off  Request to stop the washing procedure.</li>
					<li>tt:IRLamp|On  Request to turn ON an IR illuminator attached to the unit.</li>
					<li>tt:IRLamp|Off  Request to turn OFF an IR illuminator attached to the unit.</li>
					<li>tt:IRLamp|Auto  Request to configure an IR illuminator attached to the unit so that it automatically turns ON and OFF.</li>
				</ul>
				A device that indicates auxiliary service capability shall support this command.</wsdl:documentation>
			<wsdl:input message="tds:SendAuxiliaryCommandRequest"/>
			<wsdl:output message="tds:SendAuxiliaryCommandResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetDot11Capabilities">
			<wsdl:documentation>This operation returns the IEEE802.11 capabilities. The device shall support
				this operation.</wsdl:documentation>
			<wsdl:input message="tds:GetDot11CapabilitiesRequest"/>
			<wsdl:output message="tds:GetDot11CapabilitiesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetDot11Status">
			<wsdl:documentation>This operation returns the status of a wireless network interface. The device shall support this
				command.</wsdl:documentation>
			<wsdl:input message="tds:GetDot11StatusRequest"/>
			<wsdl:output message="tds:GetDot11StatusResponse"/>
		</wsdl:operation>
		<wsdl:operation name="ScanAvailableDot11Networks">
			<wsdl:documentation>This operation returns a lists of the wireless networks in range of the device. A device should
				support this operation.</wsdl:documentation>
			<wsdl:input message="tds:ScanAvailableDot11NetworksRequest"/>
			<wsdl:output message="tds:ScanAvailableDot11NetworksResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetSystemUris">
			<wsdl:documentation>This operation is used to retrieve URIs from which system information may be downloaded
				using HTTP. URIs may be returned for the following system information:<br/>
				System Logs. Multiple system logs may be returned, of different types. The exact format of
				the system logs is outside the scope of this specification.<br/>
				Support Information. This consists of arbitrary device diagnostics information from a device.
				The exact format of the diagnostic information is outside the scope of this specification.<br/>
				System Backup. The received file is a backup file that can be used to restore the current
				device configuration at a later date. The exact format of the backup configuration file is
				outside the scope of this specification.<br/>
				If the device allows retrieval of system logs, support information or system backup data, it
				should make them available via HTTP GET. If it does, it shall support the GetSystemUris
				command.</wsdl:documentation>
			<wsdl:input message="tds:GetSystemUrisRequest"/>
			<wsdl:output message="tds:GetSystemUrisResponse"/>
		</wsdl:operation>
		<wsdl:operation name="StartFirmwareUpgrade">
			<wsdl:documentation>This operation initiates a firmware upgrade using the HTTP POST mechanism. The response
				to the command includes an HTTP URL to which the upgrade file may be uploaded. The
				actual upgrade takes place as soon as the HTTP POST operation has completed. The device
				should support firmware upgrade through the StartFirmwareUpgrade command. The exact
				format of the firmware data is outside the scope of this specification.
				Firmware upgrade over HTTP may be achieved using the following steps:<ol>
					<li>Client calls StartFirmwareUpgrade.</li>
					<li>Server responds with upload URI and optional delay value.</li>
					<li>Client waits for delay duration if specified by server.</li>
					<li>Client transmits the firmware image to the upload URI using HTTP POST.</li>
					<li>Server reprograms itself using the uploaded image, then reboots.</li>
				</ol>
				If the firmware upgrade fails because the upgrade file was invalid, the HTTP POST response
				shall be 415 Unsupported Media Type. If the firmware upgrade fails due to an error at the
				device, the HTTP POST response shall be 500 Internal Server Error.<br/>
				The value of the Content-Type header in the HTTP POST request shall be application/octetstream.</wsdl:documentation>
			<wsdl:input message="tds:StartFirmwareUpgradeRequest"/>
			<wsdl:output message="tds:StartFirmwareUpgradeResponse"/>
		</wsdl:operation>
		<wsdl:operation name="StartSystemRestore">
			<wsdl:documentation>This operation initiates a system restore from backed up configuration data using the HTTP
				POST mechanism. The response to the command includes an HTTP URL to which the backup
				file may be uploaded. The actual restore takes place as soon as the HTTP POST operation
				has completed. Devices should support system restore through the StartSystemRestore
				command. The exact format of the backup configuration data is outside the scope of this
				specification.<br/>
				System restore over HTTP may be achieved using the following steps:<ol>
					<li>Client calls StartSystemRestore.</li>
					<li>Server responds with upload URI.</li>
					<li>Client transmits the configuration data to the upload URI using HTTP POST.</li>
					<li>Server applies the uploaded configuration, then reboots if necessary.</li>
				</ol>
				If the system restore fails because the uploaded file was invalid, the HTTP POST response
				shall be 415 Unsupported Media Type. If the system restore fails due to an error at the
				device, the HTTP POST response shall be 500 Internal Server Error.<br/>
				The value of the Content-Type header in the HTTP POST request shall be application/octetstream.</wsdl:documentation>
			<wsdl:input message="tds:StartSystemRestoreRequest"/>
			<wsdl:output message="tds:StartSystemRestoreResponse"/>
		</wsdl:operation>

		<wsdl:operation name="GetStorageConfigurations">
			<wsdl:documentation>
			This operation lists all existing storage configurations for the device. 
			</wsdl:documentation>
			<wsdl:input message="tds:GetStorageConfigurationsRequest"/>
			<wsdl:output message="tds:GetStorageConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="CreateStorageConfiguration">
			<wsdl:documentation>
			This operation creates a new storage configuration. 
			The configuration data shall be created in the device and shall be persistent (remain after reboot).
			</wsdl:documentation>
			<wsdl:input message="tds:CreateStorageConfigurationRequest"/>
			<wsdl:output message="tds:CreateStorageConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetStorageConfiguration">
			<wsdl:documentation>
			This operation retrieves the Storage configuration associated with the given storage configuration token.
			</wsdl:documentation>
			<wsdl:input message="tds:GetStorageConfigurationRequest"/>
			<wsdl:output message="tds:GetStorageConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetStorageConfiguration">
			<wsdl:documentation>
			This operation modifies an existing Storage configuration.
			</wsdl:documentation>
			<wsdl:input message="tds:SetStorageConfigurationRequest"/>
			<wsdl:output message="tds:SetStorageConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="DeleteStorageConfiguration">
			<wsdl:documentation>
			This operation deletes the given storage configuration and configuration change shall always be persistent.
			</wsdl:documentation>
			<wsdl:input message="tds:DeleteStorageConfigurationRequest"/>
			<wsdl:output message="tds:DeleteStorageConfigurationResponse"/>
		</wsdl:operation>

		<wsdl:operation name="GetGeoLocation">
			<wsdl:documentation>
				This operation lists all existing geo location configurations for the device. 
			</wsdl:documentation>
			<wsdl:input message="tds:GetGeoLocationRequest"/>
			<wsdl:output message="tds:GetGeoLocationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetGeoLocation">
			<wsdl:documentation>
				This operation allows to modify one or more geo configuration entries.
			</wsdl:documentation>
			<wsdl:input message="tds:SetGeoLocationRequest"/>
			<wsdl:output message="tds:SetGeoLocationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="DeleteGeoLocation">
			<wsdl:documentation>
				This operation deletes the given geo location entries.
			</wsdl:documentation>
			<wsdl:input message="tds:DeleteGeoLocationRequest"/>
			<wsdl:output message="tds:DeleteGeoLocationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetHashingAlgorithm">
		<wsdl:documentation>
				This operation sets the hashing algorithm(s) used in HTTP and RTSP Digest Authentication.
			</wsdl:documentation>
			<wsdl:input message="tds:SetHashingAlgorithmRequest"/>
			<wsdl:output message="tds:SetHashingAlgorithmResponse"/>
		</wsdl:operation>

		<!--===============================-->
		<!--The definition and interfaces for the Security have been deprecated with release 16.12
			The Security part was handed over to Security Configuration Service.
			For backward compatibility the methods remains in the devicemgmt.wsdl file.-->
		
		<wsdl:operation name="CreateCertificate">
			<wsdl:input message="tds:CreateCertificateRequest"/>
			<wsdl:output message="tds:CreateCertificateResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCertificates">
			<wsdl:input message="tds:GetCertificatesRequest"/>
			<wsdl:output message="tds:GetCertificatesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCertificatesStatus">
			<wsdl:input message="tds:GetCertificatesStatusRequest"/>
			<wsdl:output message="tds:GetCertificatesStatusResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetCertificatesStatus">
			<wsdl:input message="tds:SetCertificatesStatusRequest"/>
			<wsdl:output message="tds:SetCertificatesStatusResponse"/>
		</wsdl:operation>
		<wsdl:operation name="DeleteCertificates">
			<wsdl:input message="tds:DeleteCertificatesRequest"/>
			<wsdl:output message="tds:DeleteCertificatesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetPkcs10Request">
			<wsdl:input message="tds:GetPkcs10RequestRequest"/>
			<wsdl:output message="tds:GetPkcs10RequestResponse"/>
		</wsdl:operation>
		<wsdl:operation name="LoadCertificates">
			<wsdl:input message="tds:LoadCertificatesRequest"/>
			<wsdl:output message="tds:LoadCertificatesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetClientCertificateMode">
			<wsdl:input message="tds:GetClientCertificateModeRequest"/>
			<wsdl:output message="tds:GetClientCertificateModeResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetClientCertificateMode">
			<wsdl:input message="tds:SetClientCertificateModeRequest"/>
			<wsdl:output message="tds:SetClientCertificateModeResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCACertificates">
			<wsdl:input message="tds:GetCACertificatesRequest"/>
			<wsdl:output message="tds:GetCACertificatesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="LoadCertificateWithPrivateKey">
			<wsdl:input message="tds:LoadCertificateWithPrivateKeyRequest"/>
			<wsdl:output message="tds:LoadCertificateWithPrivateKeyResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCertificateInformation">
			<wsdl:input message="tds:GetCertificateInformationRequest"/>
			<wsdl:output message="tds:GetCertificateInformationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="LoadCACertificates">
			<wsdl:input message="tds:LoadCACertificatesRequest"/>
			<wsdl:output message="tds:LoadCACertificatesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="CreateDot1XConfiguration">
			<wsdl:input message="tds:CreateDot1XConfigurationRequest"/>
			<wsdl:output message="tds:CreateDot1XConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetDot1XConfiguration">
			<wsdl:input message="tds:SetDot1XConfigurationRequest"/>
			<wsdl:output message="tds:SetDot1XConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetDot1XConfiguration">
			<wsdl:input message="tds:GetDot1XConfigurationRequest"/>
			<wsdl:output message="tds:GetDot1XConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetDot1XConfigurations">
			<wsdl:input message="tds:GetDot1XConfigurationsRequest"/>
			<wsdl:output message="tds:GetDot1XConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="DeleteDot1XConfiguration">
			<wsdl:input message="tds:DeleteDot1XConfigurationRequest"/>
			<wsdl:output message="tds:DeleteDot1XConfigurationResponse"/>
		</wsdl:operation>		
		<!--===============================-->

	</wsdl:portType>
	<wsdl:binding name="DeviceBinding" type="tds:Device">
		<soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
		<wsdl:operation name="GetServices">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetServices"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetServiceCapabilities">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetServiceCapabilities"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetDeviceInformation">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetDeviceInformation"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetSystemDateAndTime">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetSystemDateAndTime"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetSystemDateAndTime">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetSystemDateAndTime"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetSystemFactoryDefault">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetSystemFactoryDefault"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="UpgradeSystemFirmware">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/UpgradeSystemFirmware"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SystemReboot">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SystemReboot"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="RestoreSystem">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/RestoreSystem"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetSystemBackup">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetSystemBackup"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetSystemLog">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetSystemLog"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetSystemSupportInformation">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetSystemSupportInformation"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetScopes">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetScopes"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetScopes">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetScopes"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="AddScopes">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/AddScopes"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="RemoveScopes">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/RemoveScopes"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetDiscoveryMode">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetDiscoveryMode"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetDiscoveryMode">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetDiscoveryMode"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetRemoteDiscoveryMode">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetRemoteDiscoveryMode"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetRemoteDiscoveryMode">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetRemoteDiscoveryMode"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetDPAddresses">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetDPAddresses"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetEndpointReference">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetEndpointReference"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetRemoteUser">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetRemoteUser"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetRemoteUser">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetRemoteUser"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetUsers">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetUsers"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="CreateUsers">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/CreateUsers"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="DeleteUsers">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/DeleteUsers"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetUser">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetUser"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetWsdlUrl">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetWsdlUrl"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetPasswordComplexityOptions">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetPasswordComplexityOptions"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetPasswordComplexityConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetPasswordComplexityConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetPasswordComplexityConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetPasswordComplexityConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetPasswordHistoryConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetPasswordHistoryConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetPasswordHistoryConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetPasswordHistoryConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
        	<wsdl:operation name="GetAuthFailureWarningOptions">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetAuthFailureWarningOptions"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAuthFailureWarningConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetAuthFailureWarningConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetAuthFailureWarningConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetAuthFailureWarningConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCapabilities">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetCapabilities"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetDPAddresses">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetDPAddresses"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetHostname">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetHostname"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetHostname">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetHostname"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetHostnameFromDHCP">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetHostnameFromDHCP"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetDNS">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetDNS"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetDNS">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetDNS"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetNTP">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetNTP"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetNTP">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetNTP"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetDynamicDNS">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetDynamicDNS"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetDynamicDNS">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetDynamicDNS"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetNetworkInterfaces">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetNetworkInterfaces"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetNetworkInterfaces">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetNetworkInterfaces"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetNetworkProtocols">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetNetworkProtocols"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetNetworkProtocols">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetNetworkProtocols"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetNetworkDefaultGateway">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetNetworkDefaultGateway"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetNetworkDefaultGateway">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetNetworkDefaultGateway"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetZeroConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetZeroConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetZeroConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetZeroConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetIPAddressFilter">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetIPAddressFilter"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetIPAddressFilter">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetIPAddressFilter"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="AddIPAddressFilter">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/AddIPAddressFilter"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="RemoveIPAddressFilter">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/RemoveIPAddressFilter"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAccessPolicy">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetAccessPolicy"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetAccessPolicy">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetAccessPolicy"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="CreateCertificate">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/CreateCertificate"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCertificates">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetCertificates"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCertificatesStatus">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetCertificatesStatus"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetCertificatesStatus">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetCertificatesStatus"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="DeleteCertificates">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/DeleteCertificates"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetPkcs10Request">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetPkcs10Request"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="LoadCertificates">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/LoadCertificates"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetClientCertificateMode">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetClientCertificateMode"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetClientCertificateMode">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetClientCertificateMode"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetRelayOutputs">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetRelayOutputs"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetRelayOutputSettings">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetRelayOutputSettings"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetRelayOutputState">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetRelayOutputState"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SendAuxiliaryCommand">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SendAuxiliaryCommand"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCACertificates">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetCACertificates"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="LoadCertificateWithPrivateKey">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/LoadCertificateWithPrivateKey"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCertificateInformation">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetCertificateInformation"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="LoadCACertificates">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/LoadCACertificates"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="CreateDot1XConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/CreateDot1XConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetDot1XConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetDot1XConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetDot1XConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetDot1XConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetDot1XConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetDot1XConfigurations"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="DeleteDot1XConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/DeleteDot1XConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetDot11Capabilities">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetDot11Capabilities"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetDot11Status">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetDot11Status"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="ScanAvailableDot11Networks">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/ScanAvailableDot11Networks"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetSystemUris">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetSystemUris"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="StartFirmwareUpgrade">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/StartFirmwareUpgrade"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="StartSystemRestore">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/StartSystemRestore"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>

		<wsdl:operation name="GetStorageConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetStorageConfigurations"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="CreateStorageConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/CreateStorageConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetStorageConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetStorageConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetStorageConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetStorageConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="DeleteStorageConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/DeleteStorageConfiguration"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>

		<wsdl:operation name="GetGeoLocation">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/GetGeoLocation"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetGeoLocation">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetGeoLocation"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="DeleteGeoLocation">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/DeleteGeoLocation"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetHashingAlgorithm">
			<soap:operation soapAction="http://www.onvif.org/ver10/device/wsdl/SetHashingAlgorithm"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		
		
	</wsdl:binding>
	<!--===============================-->
	<!--===============================-->
</wsdl:definitions>
</file>

<file path="wsdl/vendor/include.xsd">
<xs:schema xmlns:xs='http://www.w3.org/2001/XMLSchema' 
           xmlns:tns='http://www.w3.org/2004/08/xop/include' 
           targetNamespace='http://www.w3.org/2004/08/xop/include' >

  <xs:element name='Include' type='tns:Include' />
  <xs:complexType name='Include' >
	<xs:sequence>
	  <xs:any namespace='##other' minOccurs='0' maxOccurs='unbounded' />
	</xs:sequence>
	<xs:attribute name='href' type='xs:anyURI' use='required' />
	<xs:anyAttribute namespace='##other' />
  </xs:complexType>
</xs:schema>
</file>

<file path="wsdl/vendor/media.wsdl">
<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../../../ver20/util/onvif-wsdl-viewer.xsl"?>
<!--
Copyright (c) 2008-2021 by ONVIF: Open Network Video Interface Forum. All rights reserved.

Recipients of this document may copy, distribute, publish, or display this document so long as this copyright notice, license and disclaimer are retained with all copies of the document. No license is granted to modify this document.

THIS DOCUMENT IS PROVIDED "AS IS," AND THE CORPORATION AND ITS MEMBERS AND THEIR AFFILIATES, MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THIS DOCUMENT ARE SUITABLE FOR ANY PURPOSE; OR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.
IN NO EVENT WILL THE CORPORATION OR ITS MEMBERS OR THEIR AFFILIATES BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE OR CONSEQUENTIAL DAMAGES, ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT, WHETHER OR NOT (1) THE CORPORATION, MEMBERS OR THEIR AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR (2) SUCH DAMAGES WERE REASONABLY FORESEEABLE, AND ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT.  THE FOREGOING DISCLAIMER AND LIMITATION ON LIABILITY DO NOT APPLY TO, INVALIDATE, OR LIMIT REPRESENTATIONS AND WARRANTIES MADE BY THE MEMBERS AND THEIR RESPECTIVE AFFILIATES TO THE CORPORATION AND OTHER MEMBERS IN CERTAIN WRITTEN POLICIES OF THE CORPORATION.
-->
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap12/" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:trt="http://www.onvif.org/ver10/media/wsdl" targetNamespace="http://www.onvif.org/ver10/media/wsdl">
	<wsdl:types>
		<xs:schema targetNamespace="http://www.onvif.org/ver10/media/wsdl" xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" version="21.06">
			<xs:import namespace="http://www.onvif.org/ver10/schema" schemaLocation="./onvif.xsd"/>
			<!--  Message Request/Responses elements  -->
			<!--===============================-->
			<xs:element name="GetServiceCapabilities">
				<xs:complexType>
					<xs:sequence/>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetServiceCapabilitiesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Capabilities" type="trt:Capabilities">
							<xs:annotation>
								<xs:documentation>The capabilities for the media service is returned in the Capabilities element.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:complexType name="Capabilities">
				<xs:sequence>
					<xs:element name="ProfileCapabilities" type="trt:ProfileCapabilities">
						<xs:annotation>
							<xs:documentation>Media profile capabilities.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="StreamingCapabilities" type="trt:StreamingCapabilities">
						<xs:annotation>
							<xs:documentation>Streaming capabilities.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:attribute name="SnapshotUri" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates if GetSnapshotUri is supported.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Rotation" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates whether or not Rotation feature is supported.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="VideoSourceMode" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates the support for changing video source mode.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="OSD" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates if OSD is supported.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="TemporaryOSDText" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates the support for temporary osd text configuration. </xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="EXICompression" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates the support for the Efficient XML Interchange (EXI) binary XML format.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:complexType>
			<xs:element name="Capabilities" type="trt:Capabilities"/>
			<!--===============================-->
			<xs:complexType name="ProfileCapabilities">
				<xs:sequence>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:attribute name="MaximumNumberOfProfiles" type="xs:int">
					<xs:annotation>
						<xs:documentation>Maximum number of profiles supported.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:complexType>
			<!--===============================-->
			<xs:complexType name="StreamingCapabilities">
				<xs:sequence>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:attribute name="RTPMulticast" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for RTP multicast.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="RTP_TCP" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for RTP over TCP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="RTP_RTSP_TCP" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for RTP/RTSP/TCP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="NonAggregateControl" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates support for non aggregate RTSP control.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="NoRTSPStreaming" type="xs:boolean">
					<xs:annotation>
						<xs:documentation> Indicates the device does not support live media streaming via RTSP.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:complexType>
			<!--===============================-->
			<xs:element name="GetVideoSources">
				<xs:complexType>
					<xs:sequence>
				   </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetVideoSourcesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="VideoSources" type="tt:VideoSource" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>List of existing Video Sources</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioSources">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioSourcesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="AudioSources" type="tt:AudioSource" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>List of existing Audio Sources</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioOutputs">
				<xs:complexType>
					<xs:sequence>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioOutputsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="AudioOutputs" type="tt:AudioOutput" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>List of existing Audio Outputs</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="CreateProfile">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Name" type="tt:Name">
							<xs:annotation>
								<xs:documentation>friendly name of the profile to be created</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="Token" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional token, specifying the unique identifier of the new profile. <br/>A device supports at least a token length of 12 characters and characters "A-Z" | "a-z" | "0-9" | "-.".</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="CreateProfileResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Profile" type="tt:Profile">
							<xs:annotation>
								<xs:documentation>returns the new created profile</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetProfile">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>this command requests a specific profile</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetProfileResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Profile" type="tt:Profile">
							<xs:annotation>
								<xs:documentation>returns the requested media profile</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetProfiles">
				<xs:complexType>
					<xs:sequence>
				
      </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetProfilesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Profiles" type="tt:Profile" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>lists all profiles that exist in the media service </xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddVideoEncoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Reference to the profile where the configuration should be added</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the VideoEncoderConfiguration to add</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddVideoEncoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
				   </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemoveVideoEncoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the media profile from which the
VideoEncoderConfiguration shall be removed.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemoveVideoEncoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
    </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddVideoSourceConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Reference to the profile where the configuration should be added</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the VideoSourceConfiguration to add</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddVideoSourceConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemoveVideoSourceConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the media profile from which the
VideoSourceConfiguration shall be removed.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemoveVideoSourceConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddAudioEncoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Reference to the profile where the configuration should be added</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the AudioEncoderConfiguration to add</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddAudioEncoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemoveAudioEncoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the media profile from which the
AudioEncoderConfiguration shall be removed.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemoveAudioEncoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddAudioSourceConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Reference to the profile where the configuration should be added</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the AudioSourceConfiguration to add</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddAudioSourceConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemoveAudioSourceConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the media profile from which the
AudioSourceConfiguration shall be removed.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemoveAudioSourceConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddPTZConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Reference to the profile where the configuration should be added</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the PTZConfiguration to add</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddPTZConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemovePTZConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the media profile from which the
PTZConfiguration shall be removed.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemovePTZConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddVideoAnalyticsConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Reference to the profile where the configuration should be added</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the VideoAnalyticsConfiguration to add</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddVideoAnalyticsConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemoveVideoAnalyticsConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the media profile from which the
VideoAnalyticsConfiguration shall be removed.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemoveVideoAnalyticsConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddMetadataConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Reference to the profile where the configuration should be added</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the MetadataConfiguration to add</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddMetadataConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemoveMetadataConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the media profile from which the
MetadataConfiguration shall be removed.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemoveMetadataConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddAudioOutputConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Reference to the profile where the configuration should be added</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the AudioOutputConfiguration to add</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddAudioOutputConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
                   </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemoveAudioOutputConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a reference to the media profile from which the
AudioOutputConfiguration shall be removed.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemoveAudioOutputConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
                    </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="AddAudioDecoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>This element contains a reference to the profile where the configuration should be added.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>This element contains a reference to the AudioDecoderConfiguration to add.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="AddAudioDecoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
                    </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="RemoveAudioDecoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>This element contains a  reference to the media profile from which the AudioDecoderConfiguration shall be removed.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="RemoveAudioDecoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
                    </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="DeleteProfile">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>This element contains a  reference to the profile that should be deleted.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="DeleteProfileResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<!--===============================-->
			<!--===============================-->
			<xs:element name="GetVideoEncoderConfigurations">
				<xs:complexType>
					<xs:sequence>
      </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetVideoEncoderConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:VideoEncoderConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>This element contains a list of video encoder configurations.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetVideoSourceConfigurations">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetVideoSourceConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:VideoSourceConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>This element contains a list of video source configurations.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioEncoderConfigurations">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioEncoderConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:AudioEncoderConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>This element contains a list of audio encoder configurations.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioSourceConfigurations">
				<xs:complexType>
					<xs:sequence>
      </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioSourceConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:AudioSourceConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>This element contains a list of audio source configurations.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetVideoAnalyticsConfigurations">
				<xs:complexType>
					<xs:sequence>
      </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetVideoAnalyticsConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:VideoAnalyticsConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>This element contains a list of VideoAnalytics configurations.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetMetadataConfigurations">
				<xs:complexType>
					<xs:sequence>
      </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetMetadataConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:MetadataConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>This element contains a list of metadata configurations</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<!--===============================-->
			<xs:element name="GetAudioOutputConfigurations">
				<xs:complexType>
					<xs:sequence>
				   </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioOutputConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:AudioOutputConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>This element contains a list of audio output configurations</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioDecoderConfigurations">
				<xs:complexType>
					<xs:sequence>
				   </xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioDecoderConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:AudioDecoderConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>This element contains a list of audio decoder configurations</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetVideoSourceConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Token of the requested video source configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetVideoSourceConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:VideoSourceConfiguration">
							<xs:annotation>
								<xs:documentation>The requested video source configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetVideoEncoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Token of the requested video encoder configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetVideoEncoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:VideoEncoderConfiguration">
							<xs:annotation>
								<xs:documentation>The requested video encoder configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioSourceConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Token of the requested audio source configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioSourceConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:AudioSourceConfiguration">
							<xs:annotation>
								<xs:documentation>The requested audio source configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioEncoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Token of the requested audio encoder configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioEncoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:AudioEncoderConfiguration">
							<xs:annotation>
								<xs:documentation>The requested audio encoder configuration</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetVideoAnalyticsConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Token of the requested video analytics configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetVideoAnalyticsConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:VideoAnalyticsConfiguration">
							<xs:annotation>
								<xs:documentation>The requested video analytics configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetMetadataConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Token of the requested metadata configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetMetadataConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:MetadataConfiguration">
							<xs:annotation>
								<xs:documentation>The requested metadata configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<!--===============================-->
			<xs:element name="GetAudioOutputConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Token of the requested audio output configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioOutputConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:AudioOutputConfiguration">
							<xs:annotation>
								<xs:documentation>The requested audio output configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioDecoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Token of the requested audio decoder configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioDecoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:AudioDecoderConfiguration">
							<xs:annotation>
								<xs:documentation>The requested audio decoder configuration</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCompatibleVideoEncoderConfigurations">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains the token of an existing media profile the configurations shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCompatibleVideoEncoderConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:VideoEncoderConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of video encoder configurations that are compatible with the specified media profile.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCompatibleVideoSourceConfigurations">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains the token of an existing media profile the configurations shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCompatibleVideoSourceConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:VideoSourceConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of video source configurations that are compatible with the specified media profile.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCompatibleAudioEncoderConfigurations">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains the token of an existing media profile the configurations shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCompatibleAudioEncoderConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:AudioEncoderConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of audio encoder configurations that are compatible with the specified media profile.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCompatibleAudioSourceConfigurations">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains the token of an existing media profile the configurations shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCompatibleAudioSourceConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:AudioSourceConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of audio source configurations that are compatible with the specified media profile.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCompatibleVideoAnalyticsConfigurations">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains the token of an existing media profile the configurations shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCompatibleVideoAnalyticsConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:VideoAnalyticsConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of video analytics configurations that are compatible with the specified media profile.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCompatibleMetadataConfigurations">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains the token of an existing media profile the configurations shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCompatibleMetadataConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:MetadataConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of metadata configurations that are compatible with the specified media profile.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<!--===============================-->
			<xs:element name="GetCompatibleAudioOutputConfigurations">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains the token of an existing media profile the configurations shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCompatibleAudioOutputConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:AudioOutputConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of audio output configurations that are compatible with the specified media profile.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetCompatibleAudioDecoderConfigurations">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains the token of an existing media profile the configurations shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetCompatibleAudioDecoderConfigurationsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configurations" type="tt:AudioDecoderConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Contains a list of audio decoder configurations that are compatible with the specified media profile. </xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<!--===============================-->
			<!--===============================-->
			<!--===============================-->
			<!--===============================-->
			<!--===============================-->
			<xs:element name="SetVideoEncoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:VideoEncoderConfiguration">
							<xs:annotation>
								<xs:documentation>Contains the modified video encoder configuration. The configuration shall exist in the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ForcePersistence" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>The ForcePersistence element is obsolete and should always be assumed to be true.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetVideoEncoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetVideoSourceConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:VideoSourceConfiguration">
							<xs:annotation>
								<xs:documentation>Contains the modified video source configuration. The configuration shall exist in the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ForcePersistence" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>The ForcePersistence element is obsolete and should always be assumed to be true.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetVideoSourceConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetAudioEncoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:AudioEncoderConfiguration">
							<xs:annotation>
								<xs:documentation>Contains the modified audio encoder configuration. The configuration shall exist in the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ForcePersistence" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>The ForcePersistence element is obsolete and should always be assumed to be true.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetAudioEncoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetAudioSourceConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:AudioSourceConfiguration">
							<xs:annotation>
								<xs:documentation>Contains the modified audio source configuration. The configuration shall exist in the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ForcePersistence" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>The ForcePersistence element is obsolete and should always be assumed to be true.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetAudioSourceConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetVideoAnalyticsConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:VideoAnalyticsConfiguration">
							<xs:annotation>
								<xs:documentation>Contains the modified video analytics configuration. The configuration shall exist in the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ForcePersistence" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>The ForcePersistence element is obsolete and should always be assumed to be true.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetVideoAnalyticsConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetMetadataConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:MetadataConfiguration">
							<xs:annotation>
								<xs:documentation>Contains the modified metadata configuration. The configuration shall exist in the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ForcePersistence" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>The ForcePersistence element is obsolete and should always be assumed to be true.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetMetadataConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<!--===============================-->
			<xs:element name="SetAudioOutputConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:AudioOutputConfiguration">
							<xs:annotation>
								<xs:documentation>Contains the modified audio output configuration. The configuration shall exist in the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ForcePersistence" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>The ForcePersistence element is obsolete and should always be assumed to be true.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetAudioOutputConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
				   </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetAudioDecoderConfiguration">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Configuration" type="tt:AudioDecoderConfiguration">
							<xs:annotation>
								<xs:documentation>Contains the modified audio decoder configuration. The configuration shall exist in the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ForcePersistence" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>The ForcePersistence element is obsolete and should always be assumed to be true.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetAudioDecoderConfigurationResponse">
				<xs:complexType>
					<xs:sequence>
				   </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetVideoSourceConfigurationOptions">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional video source configurationToken that specifies an existing configuration that the options are intended for.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ProfileToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetVideoSourceConfigurationOptionsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Options" type="tt:VideoSourceConfigurationOptions">
							<xs:annotation>
								<xs:documentation>This message contains the video source configuration options. If a video source configuration is specified, the options shall concern that particular configuration. If a media profile is specified, the options shall be compatible with that media profile. If no tokens are specified, the options shall be considered generic for the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetVideoEncoderConfigurationOptions">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional video encoder configuration token that specifies an existing configuration that the options are intended for.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ProfileToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetVideoEncoderConfigurationOptionsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Options" type="tt:VideoEncoderConfigurationOptions"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioSourceConfigurationOptions">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional audio source configuration token that specifies an existing configuration that the options are intended for.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ProfileToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioSourceConfigurationOptionsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Options" type="tt:AudioSourceConfigurationOptions">
							<xs:annotation>
								<xs:documentation>This message contains the audio source configuration options. If a audio source configuration is specified, the options shall concern that particular configuration. If a media profile is specified, the options shall be compatible with that media profile. If no tokens are specified, the options shall be considered generic for the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioEncoderConfigurationOptions">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional audio encoder configuration token that specifies an existing configuration that the options are intended for.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ProfileToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioEncoderConfigurationOptionsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Options" type="tt:AudioEncoderConfigurationOptions">
							<xs:annotation>
								<xs:documentation>This message contains the audio encoder configuration options. If a audio encoder configuration is specified, the options shall concern that particular configuration. If a media profile is specified, the options shall be compatible with that media profile. If no tokens are specified, the options shall be considered generic for the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetMetadataConfigurationOptions">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional metadata configuration token that specifies an existing configuration that the options are intended for.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ProfileToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetMetadataConfigurationOptionsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Options" type="tt:MetadataConfigurationOptions">
							<xs:annotation>
								<xs:documentation>This message contains the metadata configuration options. If a metadata configuration is specified, the options shall concern that particular configuration. If a media profile is specified, the options shall be compatible with that media profile. If no tokens are specified, the options shall be considered generic for the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioOutputConfigurationOptions">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional audio output configuration token that specifies an existing configuration that the options are intended for.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ProfileToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioOutputConfigurationOptionsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Options" type="tt:AudioOutputConfigurationOptions">
							<xs:annotation>
								<xs:documentation>This message contains the audio output configuration options. If a audio output configuration is specified, the options shall concern that particular configuration. If a media profile is specified, the options shall be compatible with that media profile. If no tokens are specified, the options shall be considered generic for the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetAudioDecoderConfigurationOptions">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional audio decoder configuration token that specifies an existing configuration that the options are intended for.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ProfileToken" type="tt:ReferenceToken" minOccurs="0">
							<xs:annotation>
								<xs:documentation>Optional ProfileToken that specifies an existing media profile that the options shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetAudioDecoderConfigurationOptionsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Options" type="tt:AudioDecoderConfigurationOptions">
							<xs:annotation>
								<xs:documentation>This message contains the audio decoder configuration options. If a audio decoder configuration is specified, the options shall concern that particular configuration. If a media profile is specified, the options shall be compatible with that media profile. If no tokens are specified, the options shall be considered generic for the device.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetGuaranteedNumberOfVideoEncoderInstances">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Token of the video source configuration</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetGuaranteedNumberOfVideoEncoderInstancesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="TotalNumber" type="xs:int">
							<xs:annotation>
								<xs:documentation>The minimum guaranteed total number of encoder instances (applications) per VideoSourceConfiguration. The device is able to deliver the TotalNumber of streams</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="JPEG" type="xs:int" minOccurs="0">
							<xs:annotation>
								<xs:documentation>If a device limits the number of instances for respective Video Codecs the response contains the information how many Jpeg streams can be set up at the same time per VideoSource.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="H264" type="xs:int" minOccurs="0">
							<xs:annotation>
								<xs:documentation>If a device limits the number of instances for respective Video Codecs the response contains the information how many H264 streams can be set up at the same time per VideoSource.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="MPEG4" type="xs:int" minOccurs="0">
							<xs:annotation>
								<xs:documentation>If a device limits the number of instances for respective Video Codecs the response contains the information how many Mpeg4 streams can be set up at the same time per VideoSource.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetStreamUri">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="StreamSetup" type="tt:StreamSetup">
							<xs:annotation>
								<xs:documentation>Stream Setup that should be used with the uri</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>The ProfileToken element indicates the media profile to use and will define the configuration of the content of the stream.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetStreamUriResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="MediaUri" type="tt:MediaUri">
							<xs:annotation>
								<xs:documentation/>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="StartMulticastStreaming">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains the token of the Profile that is used to define the multicast stream.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="StartMulticastStreamingResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="StopMulticastStreaming">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains the token of the Profile that is used to define the multicast stream.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="StopMulticastStreamingResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetSynchronizationPoint">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a Profile reference for which a Synchronization Point is requested.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetSynchronizationPointResponse">
				<xs:complexType>
					<xs:sequence>
          </xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetSnapshotUri">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ProfileToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>The ProfileToken element indicates the media profile to use and will define the source and dimensions of the snapshot.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetSnapshotUriResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="MediaUri" type="tt:MediaUri">
							<xs:annotation>
								<xs:documentation/>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--================ Video Source Mode ===============-->
			<xs:element name="GetVideoSourceModes">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="VideoSourceToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a video source reference for which a video source mode is requested.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetVideoSourceModesResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="VideoSourceModes" type="trt:VideoSourceMode" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>Return the information for specified video source mode.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetVideoSourceMode">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="VideoSourceToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Contains a video source reference for which a video source mode is requested.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:element name="VideoSourceModeToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Indicate video source mode.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetVideoSourceModeResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Reboot" type="xs:boolean">
							<xs:annotation>
								<xs:documentation>The response contains information about rebooting after returning response. When Reboot is set true, a device will reboot automatically after setting mode.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:complexType name="VideoSourceMode"> 
				<xs:sequence>
					<xs:element name="MaxFramerate" type="xs:float">
						<xs:annotation>
							<xs:documentation>Max frame rate in frames per second for this video source mode.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="MaxResolution" type="tt:VideoResolution">
						<xs:annotation>
							<xs:documentation>Max horizontal and vertical resolution for this video source mode.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Encodings" type="tt:StringList">
						<xs:annotation>
							<xs:documentation>Indication which encodings are supported for this video source. The list may contain one or more enumeration values of tt:VideoEncoding.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Reboot" type="xs:boolean">
						<xs:annotation>
							<xs:documentation>After setting the mode if a device starts to reboot this value is true. If a device change the mode without rebooting this value is false. If true, configured parameters may not be guaranteed by the device after rebooting.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Description" type="tt:Description" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Informative description of this video source mode. This field should be described in English.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extension" type="trt:VideoSourceModeExtension" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="token" type="tt:ReferenceToken" use="required">
					<xs:annotation>
						<xs:documentation>Indicate token for video source mode.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Enabled" type="xs:boolean"> 
					<xs:annotation>
						<xs:documentation>Indication of whether this mode is active. If active this value is true. In case of non-indication, it means as false. The value of true shall be had by only one video source mode.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:complexType>
			<!--===============================-->
			<xs:complexType name="VideoSourceModeExtension"> 
				<xs:sequence>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
				</xs:sequence>
			</xs:complexType>

			<!--===============================-->
			<!--============OSD Schema Begin================-->
			<xs:element name="GetOSDs">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken" minOccurs="0" maxOccurs="1">
							<xs:annotation>
								<xs:documentation>Token of the Video Source Configuration, which has OSDs associated with are requested. If token not exist, request all available OSDs.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetOSDsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="OSDs" type="tt:OSDConfiguration" minOccurs="0" maxOccurs="unbounded">
							<xs:annotation>
								<xs:documentation>This element contains a list of requested OSDs.</xs:documentation>
							</xs:annotation>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetOSD">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="OSDToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>The GetOSD command fetches the OSD configuration if the OSD token is known.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetOSDResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="OSD" type="tt:OSDConfiguration">
							<xs:annotation>
								<xs:documentation>The requested OSD configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="SetOSD">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="OSD" type="tt:OSDConfiguration">
							<xs:annotation>
								<xs:documentation>Contains the modified OSD configuration.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="SetOSDResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="GetOSDOptions">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="ConfigurationToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Video Source Configuration Token that specifies an existing video source configuration that the options shall be compatible with.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="GetOSDOptionsResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="OSDOptions" type="tt:OSDConfigurationOptions">
							<xs:annotation>
								<xs:documentation/>
							</xs:annotation>
						</xs:element>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="CreateOSD">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="OSD" type="tt:OSDConfiguration">
							<xs:annotation>
								<xs:documentation>Contain the initial OSD configuration for create.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="CreateOSDResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="OSDToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>Returns Token of the newly created OSD</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--===============================-->
			<xs:element name="DeleteOSD">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="OSDToken" type="tt:ReferenceToken">
							<xs:annotation>
								<xs:documentation>This element contains a reference to the OSD configuration that should be deleted.</xs:documentation>
							</xs:annotation>
						</xs:element>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:element name="DeleteOSDResponse">
				<xs:complexType>
					<xs:sequence>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>	 <!-- first Vendor then ONVIF -->
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<!--============OSD Schema End================-->
		</xs:schema>
	</wsdl:types>
	<wsdl:message name="GetServiceCapabilitiesRequest">
		<wsdl:part name="parameters" element="trt:GetServiceCapabilities"/>
	</wsdl:message>
	<wsdl:message name="GetServiceCapabilitiesResponse">
		<wsdl:part name="parameters" element="trt:GetServiceCapabilitiesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetVideoSourcesRequest">
		<wsdl:part name="parameters" element="trt:GetVideoSources"/>
	</wsdl:message>
	<wsdl:message name="GetVideoSourcesResponse">
		<wsdl:part name="parameters" element="trt:GetVideoSourcesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioSourcesRequest">
		<wsdl:part name="parameters" element="trt:GetAudioSources"/>
	</wsdl:message>
	<wsdl:message name="GetAudioSourcesResponse">
		<wsdl:part name="parameters" element="trt:GetAudioSourcesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioOutputsRequest">
		<wsdl:part name="parameters" element="trt:GetAudioOutputs"/>
	</wsdl:message>
	<wsdl:message name="GetAudioOutputsResponse">
		<wsdl:part name="parameters" element="trt:GetAudioOutputsResponse"/>
	</wsdl:message>
	<wsdl:message name="CreateProfileRequest">
		<wsdl:part name="parameters" element="trt:CreateProfile"/>
	</wsdl:message>
	<wsdl:message name="CreateProfileResponse">
		<wsdl:part name="parameters" element="trt:CreateProfileResponse"/>
	</wsdl:message>
	<wsdl:message name="GetProfileRequest">
		<wsdl:part name="parameters" element="trt:GetProfile"/>
	</wsdl:message>
	<wsdl:message name="GetProfileResponse">
		<wsdl:part name="parameters" element="trt:GetProfileResponse"/>
	</wsdl:message>
	<wsdl:message name="GetProfilesRequest">
		<wsdl:part name="parameters" element="trt:GetProfiles"/>
	</wsdl:message>
	<wsdl:message name="GetProfilesResponse">
		<wsdl:part name="parameters" element="trt:GetProfilesResponse"/>
	</wsdl:message>
	<wsdl:message name="AddVideoEncoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:AddVideoEncoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="AddVideoEncoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:AddVideoEncoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="RemoveVideoEncoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:RemoveVideoEncoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="RemoveVideoEncoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:RemoveVideoEncoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="AddVideoSourceConfigurationRequest">
		<wsdl:part name="parameters" element="trt:AddVideoSourceConfiguration"/>
	</wsdl:message>
	<wsdl:message name="AddVideoSourceConfigurationResponse">
		<wsdl:part name="parameters" element="trt:AddVideoSourceConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="RemoveVideoSourceConfigurationRequest">
		<wsdl:part name="parameters" element="trt:RemoveVideoSourceConfiguration"/>
	</wsdl:message>
	<wsdl:message name="RemoveVideoSourceConfigurationResponse">
		<wsdl:part name="parameters" element="trt:RemoveVideoSourceConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="AddAudioEncoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:AddAudioEncoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="AddAudioEncoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:AddAudioEncoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="RemoveAudioEncoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:RemoveAudioEncoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="RemoveAudioEncoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:RemoveAudioEncoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="AddAudioSourceConfigurationRequest">
		<wsdl:part name="parameters" element="trt:AddAudioSourceConfiguration"/>
	</wsdl:message>
	<wsdl:message name="AddAudioSourceConfigurationResponse">
		<wsdl:part name="parameters" element="trt:AddAudioSourceConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="RemoveAudioSourceConfigurationRequest">
		<wsdl:part name="parameters" element="trt:RemoveAudioSourceConfiguration"/>
	</wsdl:message>
	<wsdl:message name="RemoveAudioSourceConfigurationResponse">
		<wsdl:part name="parameters" element="trt:RemoveAudioSourceConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="AddPTZConfigurationRequest">
		<wsdl:part name="parameters" element="trt:AddPTZConfiguration"/>
	</wsdl:message>
	<wsdl:message name="AddPTZConfigurationResponse">
		<wsdl:part name="parameters" element="trt:AddPTZConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="RemovePTZConfigurationRequest">
		<wsdl:part name="parameters" element="trt:RemovePTZConfiguration"/>
	</wsdl:message>
	<wsdl:message name="RemovePTZConfigurationResponse">
		<wsdl:part name="parameters" element="trt:RemovePTZConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="AddVideoAnalyticsConfigurationRequest">
		<wsdl:part name="parameters" element="trt:AddVideoAnalyticsConfiguration"/>
	</wsdl:message>
	<wsdl:message name="AddVideoAnalyticsConfigurationResponse">
		<wsdl:part name="parameters" element="trt:AddVideoAnalyticsConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="RemoveVideoAnalyticsConfigurationRequest">
		<wsdl:part name="parameters" element="trt:RemoveVideoAnalyticsConfiguration"/>
	</wsdl:message>
	<wsdl:message name="RemoveVideoAnalyticsConfigurationResponse">
		<wsdl:part name="parameters" element="trt:RemoveVideoAnalyticsConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="AddMetadataConfigurationRequest">
		<wsdl:part name="parameters" element="trt:AddMetadataConfiguration"/>
	</wsdl:message>
	<wsdl:message name="AddMetadataConfigurationResponse">
		<wsdl:part name="parameters" element="trt:AddMetadataConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="RemoveMetadataConfigurationRequest">
		<wsdl:part name="parameters" element="trt:RemoveMetadataConfiguration"/>
	</wsdl:message>
	<wsdl:message name="RemoveMetadataConfigurationResponse">
		<wsdl:part name="parameters" element="trt:RemoveMetadataConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="AddAudioOutputConfigurationRequest">
		<wsdl:part name="parameters" element="trt:AddAudioOutputConfiguration"/>
	</wsdl:message>
	<wsdl:message name="AddAudioOutputConfigurationResponse">
		<wsdl:part name="parameters" element="trt:AddAudioOutputConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="RemoveAudioOutputConfigurationRequest">
		<wsdl:part name="parameters" element="trt:RemoveAudioOutputConfiguration"/>
	</wsdl:message>
	<wsdl:message name="RemoveAudioOutputConfigurationResponse">
		<wsdl:part name="parameters" element="trt:RemoveAudioOutputConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="AddAudioDecoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:AddAudioDecoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="AddAudioDecoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:AddAudioDecoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="RemoveAudioDecoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:RemoveAudioDecoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="RemoveAudioDecoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:RemoveAudioDecoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="DeleteProfileRequest">
		<wsdl:part name="parameters" element="trt:DeleteProfile"/>
	</wsdl:message>
	<wsdl:message name="DeleteProfileResponse">
		<wsdl:part name="parameters" element="trt:DeleteProfileResponse"/>
	</wsdl:message>
	<wsdl:message name="GetVideoSourceConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetVideoSourceConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetVideoSourceConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetVideoSourceConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetVideoEncoderConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetVideoEncoderConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetVideoEncoderConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetVideoEncoderConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioSourceConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetAudioSourceConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetAudioSourceConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetAudioSourceConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioEncoderConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetAudioEncoderConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetAudioEncoderConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetAudioEncoderConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetVideoAnalyticsConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetVideoAnalyticsConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetVideoAnalyticsConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetVideoAnalyticsConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetMetadataConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetMetadataConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetMetadataConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetMetadataConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioOutputConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetAudioOutputConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetAudioOutputConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetAudioOutputConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioDecoderConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetAudioDecoderConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetAudioDecoderConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetAudioDecoderConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetVideoSourceConfigurationRequest">
		<wsdl:part name="parameters" element="trt:GetVideoSourceConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetVideoSourceConfigurationResponse">
		<wsdl:part name="parameters" element="trt:GetVideoSourceConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetVideoEncoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:GetVideoEncoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetVideoEncoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:GetVideoEncoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioSourceConfigurationRequest">
		<wsdl:part name="parameters" element="trt:GetAudioSourceConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetAudioSourceConfigurationResponse">
		<wsdl:part name="parameters" element="trt:GetAudioSourceConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioEncoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:GetAudioEncoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetAudioEncoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:GetAudioEncoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetVideoAnalyticsConfigurationRequest">
		<wsdl:part name="parameters" element="trt:GetVideoAnalyticsConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetVideoAnalyticsConfigurationResponse">
		<wsdl:part name="parameters" element="trt:GetVideoAnalyticsConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetMetadataConfigurationRequest">
		<wsdl:part name="parameters" element="trt:GetMetadataConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetMetadataConfigurationResponse">
		<wsdl:part name="parameters" element="trt:GetMetadataConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioOutputConfigurationRequest">
		<wsdl:part name="parameters" element="trt:GetAudioOutputConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetAudioOutputConfigurationResponse">
		<wsdl:part name="parameters" element="trt:GetAudioOutputConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioDecoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:GetAudioDecoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="GetAudioDecoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:GetAudioDecoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleVideoEncoderConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetCompatibleVideoEncoderConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleVideoEncoderConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetCompatibleVideoEncoderConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleVideoSourceConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetCompatibleVideoSourceConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleVideoSourceConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetCompatibleVideoSourceConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleAudioEncoderConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetCompatibleAudioEncoderConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleAudioEncoderConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetCompatibleAudioEncoderConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleAudioSourceConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetCompatibleAudioSourceConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleAudioSourceConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetCompatibleAudioSourceConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleVideoAnalyticsConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetCompatibleVideoAnalyticsConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleVideoAnalyticsConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetCompatibleVideoAnalyticsConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleMetadataConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetCompatibleMetadataConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleMetadataConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetCompatibleMetadataConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleAudioOutputConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetCompatibleAudioOutputConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleAudioOutputConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetCompatibleAudioOutputConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleAudioDecoderConfigurationsRequest">
		<wsdl:part name="parameters" element="trt:GetCompatibleAudioDecoderConfigurations"/>
	</wsdl:message>
	<wsdl:message name="GetCompatibleAudioDecoderConfigurationsResponse">
		<wsdl:part name="parameters" element="trt:GetCompatibleAudioDecoderConfigurationsResponse"/>
	</wsdl:message>
	<wsdl:message name="SetVideoSourceConfigurationRequest">
		<wsdl:part name="parameters" element="trt:SetVideoSourceConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetVideoSourceConfigurationResponse">
		<wsdl:part name="parameters" element="trt:SetVideoSourceConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetVideoEncoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:SetVideoEncoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetVideoEncoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:SetVideoEncoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetAudioSourceConfigurationRequest">
		<wsdl:part name="parameters" element="trt:SetAudioSourceConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetAudioSourceConfigurationResponse">
		<wsdl:part name="parameters" element="trt:SetAudioSourceConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetAudioEncoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:SetAudioEncoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetAudioEncoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:SetAudioEncoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetVideoAnalyticsConfigurationRequest">
		<wsdl:part name="parameters" element="trt:SetVideoAnalyticsConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetVideoAnalyticsConfigurationResponse">
		<wsdl:part name="parameters" element="trt:SetVideoAnalyticsConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetMetadataConfigurationRequest">
		<wsdl:part name="parameters" element="trt:SetMetadataConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetMetadataConfigurationResponse">
		<wsdl:part name="parameters" element="trt:SetMetadataConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetAudioOutputConfigurationRequest">
		<wsdl:part name="parameters" element="trt:SetAudioOutputConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetAudioOutputConfigurationResponse">
		<wsdl:part name="parameters" element="trt:SetAudioOutputConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="SetAudioDecoderConfigurationRequest">
		<wsdl:part name="parameters" element="trt:SetAudioDecoderConfiguration"/>
	</wsdl:message>
	<wsdl:message name="SetAudioDecoderConfigurationResponse">
		<wsdl:part name="parameters" element="trt:SetAudioDecoderConfigurationResponse"/>
	</wsdl:message>
	<wsdl:message name="GetVideoSourceConfigurationOptionsRequest">
		<wsdl:part name="parameters" element="trt:GetVideoSourceConfigurationOptions"/>
	</wsdl:message>
	<wsdl:message name="GetVideoSourceConfigurationOptionsResponse">
		<wsdl:part name="parameters" element="trt:GetVideoSourceConfigurationOptionsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetVideoEncoderConfigurationOptionsRequest">
		<wsdl:part name="parameters" element="trt:GetVideoEncoderConfigurationOptions"/>
	</wsdl:message>
	<wsdl:message name="GetVideoEncoderConfigurationOptionsResponse">
		<wsdl:part name="parameters" element="trt:GetVideoEncoderConfigurationOptionsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioSourceConfigurationOptionsRequest">
		<wsdl:part name="parameters" element="trt:GetAudioSourceConfigurationOptions"/>
	</wsdl:message>
	<wsdl:message name="GetAudioSourceConfigurationOptionsResponse">
		<wsdl:part name="parameters" element="trt:GetAudioSourceConfigurationOptionsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioEncoderConfigurationOptionsRequest">
		<wsdl:part name="parameters" element="trt:GetAudioEncoderConfigurationOptions"/>
	</wsdl:message>
	<wsdl:message name="GetAudioEncoderConfigurationOptionsResponse">
		<wsdl:part name="parameters" element="trt:GetAudioEncoderConfigurationOptionsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetMetadataConfigurationOptionsRequest">
		<wsdl:part name="parameters" element="trt:GetMetadataConfigurationOptions"/>
	</wsdl:message>
	<wsdl:message name="GetMetadataConfigurationOptionsResponse">
		<wsdl:part name="parameters" element="trt:GetMetadataConfigurationOptionsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioOutputConfigurationOptionsRequest">
		<wsdl:part name="parameters" element="trt:GetAudioOutputConfigurationOptions"/>
	</wsdl:message>
	<wsdl:message name="GetAudioOutputConfigurationOptionsResponse">
		<wsdl:part name="parameters" element="trt:GetAudioOutputConfigurationOptionsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetAudioDecoderConfigurationOptionsRequest">
		<wsdl:part name="parameters" element="trt:GetAudioDecoderConfigurationOptions"/>
	</wsdl:message>
	<wsdl:message name="GetAudioDecoderConfigurationOptionsResponse">
		<wsdl:part name="parameters" element="trt:GetAudioDecoderConfigurationOptionsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetGuaranteedNumberOfVideoEncoderInstancesRequest">
		<wsdl:part name="parameters" element="trt:GetGuaranteedNumberOfVideoEncoderInstances"/>
	</wsdl:message>
	<wsdl:message name="GetGuaranteedNumberOfVideoEncoderInstancesResponse">
		<wsdl:part name="parameters" element="trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse"/>
	</wsdl:message>
	<wsdl:message name="GetStreamUriRequest">
		<wsdl:part name="parameters" element="trt:GetStreamUri"/>
	</wsdl:message>
	<wsdl:message name="GetStreamUriResponse">
		<wsdl:part name="parameters" element="trt:GetStreamUriResponse"/>
	</wsdl:message>
	<wsdl:message name="StartMulticastStreamingRequest">
		<wsdl:part name="parameters" element="trt:StartMulticastStreaming"/>
	</wsdl:message>
	<wsdl:message name="StartMulticastStreamingResponse">
		<wsdl:part name="parameters" element="trt:StartMulticastStreamingResponse"/>
	</wsdl:message>
	<wsdl:message name="StopMulticastStreamingRequest">
		<wsdl:part name="parameters" element="trt:StopMulticastStreaming"/>
	</wsdl:message>
	<wsdl:message name="StopMulticastStreamingResponse">
		<wsdl:part name="parameters" element="trt:StopMulticastStreamingResponse"/>
	</wsdl:message>
	<wsdl:message name="SetSynchronizationPointRequest">
		<wsdl:part name="parameters" element="trt:SetSynchronizationPoint"/>
	</wsdl:message>
	<wsdl:message name="SetSynchronizationPointResponse">
		<wsdl:part name="parameters" element="trt:SetSynchronizationPointResponse"/>
	</wsdl:message>
	<wsdl:message name="GetSnapshotUriRequest">
		<wsdl:part name="parameters" element="trt:GetSnapshotUri"/>
	</wsdl:message>
	<wsdl:message name="GetSnapshotUriResponse">
		<wsdl:part name="parameters" element="trt:GetSnapshotUriResponse"/>
	</wsdl:message>
	<wsdl:message name="GetVideoSourceModesRequest">
		<wsdl:part name="parameters" element="trt:GetVideoSourceModes"/>
	</wsdl:message>
	<wsdl:message name="GetVideoSourceModesResponse">
		<wsdl:part name="parameters" element="trt:GetVideoSourceModesResponse"/>
	</wsdl:message>
	<wsdl:message name="SetVideoSourceModeRequest">
		<wsdl:part name="parameters" element="trt:SetVideoSourceMode"/>
	</wsdl:message>
	<wsdl:message name="SetVideoSourceModeResponse">
		<wsdl:part name="parameters" element="trt:SetVideoSourceModeResponse"/>
	</wsdl:message>
	<wsdl:message name="GetOSDsRequest">
		<wsdl:part name="parameters" element="trt:GetOSDs"/>
	</wsdl:message>
	<wsdl:message name="GetOSDsResponse">
		<wsdl:part name="parameters" element="trt:GetOSDsResponse"/>
	</wsdl:message>
	<wsdl:message name="GetOSDRequest">
		<wsdl:part name="parameters" element="trt:GetOSD"/>
	</wsdl:message>
	<wsdl:message name="GetOSDResponse">
		<wsdl:part name="parameters" element="trt:GetOSDResponse"/>
	</wsdl:message>
	<wsdl:message name="GetOSDOptionsRequest">
		<wsdl:part name="parameters" element="trt:GetOSDOptions"/>
	</wsdl:message>
	<wsdl:message name="GetOSDOptionsResponse">
		<wsdl:part name="parameters" element="trt:GetOSDOptionsResponse"/>
	</wsdl:message>
	<wsdl:message name="SetOSDRequest">
		<wsdl:part name="parameters" element="trt:SetOSD"/>
	</wsdl:message>
	<wsdl:message name="SetOSDResponse">
		<wsdl:part name="parameters" element="trt:SetOSDResponse"/>
	</wsdl:message>
	<wsdl:message name="CreateOSDRequest">
		<wsdl:part name="parameters" element="trt:CreateOSD"/>
	</wsdl:message>
	<wsdl:message name="CreateOSDResponse">
		<wsdl:part name="parameters" element="trt:CreateOSDResponse"/>
	</wsdl:message>
	<wsdl:message name="DeleteOSDRequest">
		<wsdl:part name="parameters" element="trt:DeleteOSD"/>
	</wsdl:message>
	<wsdl:message name="DeleteOSDResponse">
		<wsdl:part name="parameters" element="trt:DeleteOSDResponse"/>
	</wsdl:message>
	<wsdl:portType name="Media">
		<!--===============================-->
		<!--===============================-->
		<wsdl:operation name="GetServiceCapabilities">
			<wsdl:documentation>Returns the capabilities of the media service. The result is returned in a typed answer.</wsdl:documentation>
			<wsdl:input message="trt:GetServiceCapabilitiesRequest"/>
			<wsdl:output message="trt:GetServiceCapabilitiesResponse"/>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetVideoSources">
			<wsdl:documentation>This command lists all available physical video inputs of the device.</wsdl:documentation>
			<wsdl:input message="trt:GetVideoSourcesRequest"/>
			<wsdl:output message="trt:GetVideoSourcesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioSources">
			<wsdl:documentation>This command lists all available physical audio inputs of the device.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioSourcesRequest"/>
			<wsdl:output message="trt:GetAudioSourcesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioOutputs">
			<wsdl:documentation>This command lists all available physical audio outputs of the device.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioOutputsRequest"/>
			<wsdl:output message="trt:GetAudioOutputsResponse"/>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="CreateProfile">
			<wsdl:documentation>This operation creates a new empty media profile. The media profile shall be created in the
device and shall be persistent (remain after reboot). A created profile shall be deletable and a device shall set the fixed attribute to false in the
returned Profile.</wsdl:documentation>
			<wsdl:input message="trt:CreateProfileRequest"/>
			<wsdl:output message="trt:CreateProfileResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetProfile">
			<wsdl:documentation>If the profile token is already known, a profile can be fetched through the GetProfile command.</wsdl:documentation>
			<wsdl:input message="trt:GetProfileRequest"/>
			<wsdl:output message="trt:GetProfileResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetProfiles">
			<wsdl:documentation>Any endpoint can ask for the existing media profiles of a device using the GetProfiles
command. Pre-configured or dynamically configured profiles can be retrieved using this
command. This command lists all configured profiles in a device. The client does not need to
know the media profile in order to use the command.</wsdl:documentation>
			<wsdl:input message="trt:GetProfilesRequest"/>
			<wsdl:output message="trt:GetProfilesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddVideoEncoderConfiguration">
			<wsdl:documentation>This operation adds a VideoEncoderConfiguration to an existing media profile. If a
configuration exists in the media profile, it will be replaced. The change shall be persistent. A device shall
support adding a compatible VideoEncoderConfiguration to a Profile containing a VideoSourceConfiguration and shall
support streaming video data of such a profile.
			</wsdl:documentation>
			<wsdl:input message="trt:AddVideoEncoderConfigurationRequest"/>
			<wsdl:output message="trt:AddVideoEncoderConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemoveVideoEncoderConfiguration">
			<wsdl:documentation>This operation removes a VideoEncoderConfiguration from an existing media profile. If the
media profile does not contain a VideoEncoderConfiguration, the operation has no effect. The removal shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:RemoveVideoEncoderConfigurationRequest"/>
			<wsdl:output message="trt:RemoveVideoEncoderConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddVideoSourceConfiguration">
			<wsdl:documentation>This operation adds a VideoSourceConfiguration to an existing media profile. If such a
configuration exists in the media profile, it will be replaced. The change shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:AddVideoSourceConfigurationRequest"/>
			<wsdl:output message="trt:AddVideoSourceConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemoveVideoSourceConfiguration">
			<wsdl:documentation>This operation removes a VideoSourceConfiguration from an existing media profile. If the
media profile does not contain a VideoSourceConfiguration, the operation has no effect. The removal shall be persistent. Video source configurations should only be removed after removing a
VideoEncoderConfiguration from the media profile.</wsdl:documentation>
			<wsdl:input message="trt:RemoveVideoSourceConfigurationRequest"/>
			<wsdl:output message="trt:RemoveVideoSourceConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddAudioEncoderConfiguration">
			<wsdl:documentation>This operation adds an AudioEncoderConfiguration to an existing media profile. If a 
configuration exists in the media profile, it will be replaced. The change shall be persistent. A device shall
support adding a compatible AudioEncoderConfiguration to a profile containing an AudioSourceConfiguration and shall
support streaming audio data of such a profile.
			</wsdl:documentation>
			<wsdl:input message="trt:AddAudioEncoderConfigurationRequest"/>
			<wsdl:output message="trt:AddAudioEncoderConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemoveAudioEncoderConfiguration">
			<wsdl:documentation>This operation removes an AudioEncoderConfiguration from an existing media profile. If the
media profile does not contain an AudioEncoderConfiguration, the operation has no effect.
The removal shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:RemoveAudioEncoderConfigurationRequest"/>
			<wsdl:output message="trt:RemoveAudioEncoderConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddAudioSourceConfiguration">
			<wsdl:documentation>This operation adds an AudioSourceConfiguration to an existing media profile. If a
configuration exists in the media profile, it will be replaced. The change shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:AddAudioSourceConfigurationRequest"/>
			<wsdl:output message="trt:AddAudioSourceConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemoveAudioSourceConfiguration">
			<wsdl:documentation>This operation removes an AudioSourceConfiguration from an existing media profile. If the
media profile does not contain an AudioSourceConfiguration, the operation has no effect. The
removal shall be persistent. Audio source configurations should only be removed after removing an
AudioEncoderConfiguration from the media profile.</wsdl:documentation>
			<wsdl:input message="trt:RemoveAudioSourceConfigurationRequest"/>
			<wsdl:output message="trt:RemoveAudioSourceConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddPTZConfiguration">
			<wsdl:documentation>This operation adds a PTZConfiguration to an existing media profile. If a configuration exists
in the media profile, it will be replaced. The change shall be persistent. Adding a PTZConfiguration to a media profile means that streams using that media profile can
contain PTZ status (in the metadata), and that the media profile can be used for controlling
PTZ movement.</wsdl:documentation>
			<wsdl:input message="trt:AddPTZConfigurationRequest"/>
			<wsdl:output message="trt:AddPTZConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemovePTZConfiguration">
			<wsdl:documentation>This operation removes a PTZConfiguration from an existing media profile. If the media profile
does not contain a PTZConfiguration, the operation has no effect. The removal shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:RemovePTZConfigurationRequest"/>
			<wsdl:output message="trt:RemovePTZConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddVideoAnalyticsConfiguration">
			<wsdl:documentation>This operation adds a VideoAnalytics configuration to an existing media profile. If a
configuration exists in the media profile, it will be replaced. The change shall be persistent. Adding a VideoAnalyticsConfiguration to a media profile means that streams using that media
profile can contain video analytics data (in the metadata) as defined by the submitted configuration reference. A profile containing only a video analytics configuration but no video source configuration is incomplete. Therefore, a client should first add a video source configuration to a profile before adding a video analytics configuration. The device can deny adding of a video analytics
configuration before a video source configuration.</wsdl:documentation>
			<wsdl:input message="trt:AddVideoAnalyticsConfigurationRequest"/>
			<wsdl:output message="trt:AddVideoAnalyticsConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemoveVideoAnalyticsConfiguration">
			<wsdl:documentation>This operation removes a VideoAnalyticsConfiguration from an existing media profile. If the media profile does not contain a VideoAnalyticsConfiguration, the operation has no effect.
The removal shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:RemoveVideoAnalyticsConfigurationRequest"/>
			<wsdl:output message="trt:RemoveVideoAnalyticsConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddMetadataConfiguration">
			<wsdl:documentation>This operation adds a Metadata configuration to an existing media profile. If a configuration exists in the media profile, it will be replaced. The change shall be persistent. Adding a MetadataConfiguration to a Profile means that streams using that profile contain metadata. Metadata can consist of events, PTZ status, and/or video analytics data.</wsdl:documentation>
			<wsdl:input message="trt:AddMetadataConfigurationRequest"/>
			<wsdl:output message="trt:AddMetadataConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemoveMetadataConfiguration">
			<wsdl:documentation>This operation removes a MetadataConfiguration from an existing media profile. If the media profile does not contain a MetadataConfiguration, the operation has no effect. The removal shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:RemoveMetadataConfigurationRequest"/>
			<wsdl:output message="trt:RemoveMetadataConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddAudioOutputConfiguration">
			<wsdl:documentation>This operation adds an AudioOutputConfiguration to an existing media profile. If a configuration exists in the media profile, it will be replaced. The change shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:AddAudioOutputConfigurationRequest"/>
			<wsdl:output message="trt:AddAudioOutputConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemoveAudioOutputConfiguration">
			<wsdl:documentation>This operation removes an AudioOutputConfiguration from an existing media profile. If the media profile does not contain an AudioOutputConfiguration, the operation has no effect. The removal shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:RemoveAudioOutputConfigurationRequest"/>
			<wsdl:output message="trt:RemoveAudioOutputConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="AddAudioDecoderConfiguration">
			<wsdl:documentation>This operation adds an AudioDecoderConfiguration to an existing media profile. If a configuration exists in the media profile, it shall be replaced. The change shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:AddAudioDecoderConfigurationRequest"/>
			<wsdl:output message="trt:AddAudioDecoderConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="RemoveAudioDecoderConfiguration">
			<wsdl:documentation>This operation removes an AudioDecoderConfiguration from an existing media profile. If the media profile does not contain an AudioDecoderConfiguration, the operation has no effect. The removal shall be persistent.</wsdl:documentation>
			<wsdl:input message="trt:RemoveAudioDecoderConfigurationRequest"/>
			<wsdl:output message="trt:RemoveAudioDecoderConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="DeleteProfile">
			<wsdl:documentation>This operation deletes a profile. This change shall always be persistent. Deletion of a profile is only possible for non-fixed profiles</wsdl:documentation>
			<wsdl:input message="trt:DeleteProfileRequest"/>
			<wsdl:output message="trt:DeleteProfileResponse"/>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetVideoSourceConfigurations">
			<wsdl:documentation>This operation lists all existing video source configurations for a device. The client need not know anything about the video source configurations in order to use the command.</wsdl:documentation>
			<wsdl:input message="trt:GetVideoSourceConfigurationsRequest"/>
			<wsdl:output message="trt:GetVideoSourceConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetVideoEncoderConfigurations">
			<wsdl:documentation>This operation lists all existing video encoder configurations of a device. This command lists all configured video encoder configurations in a device. The client need not know anything apriori about the video encoder configurations in order to use the command.</wsdl:documentation>
			<wsdl:input message="trt:GetVideoEncoderConfigurationsRequest"/>
			<wsdl:output message="trt:GetVideoEncoderConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioSourceConfigurations">
			<wsdl:documentation>This operation lists all existing audio source configurations of a device. This command lists all audio source configurations in a device. The client need not know anything apriori about the audio source configurations in order to use the command.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioSourceConfigurationsRequest"/>
			<wsdl:output message="trt:GetAudioSourceConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioEncoderConfigurations">
			<wsdl:documentation>This operation lists all existing device audio encoder configurations. The client need not know anything apriori about the audio encoder configurations in order to use the command.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioEncoderConfigurationsRequest"/>
			<wsdl:output message="trt:GetAudioEncoderConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetVideoAnalyticsConfigurations">
			<wsdl:documentation>This operation lists all video analytics configurations of a device. This command lists all configured video analytics in a device. The client need not know anything apriori about the video analytics in order to use the command.</wsdl:documentation>
			<wsdl:input message="trt:GetVideoAnalyticsConfigurationsRequest"/>
			<wsdl:output message="trt:GetVideoAnalyticsConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetMetadataConfigurations">
			<wsdl:documentation>This operation lists all existing metadata configurations. The client need not know anything apriori about the metadata in order to use the command.</wsdl:documentation>
			<wsdl:input message="trt:GetMetadataConfigurationsRequest"/>
			<wsdl:output message="trt:GetMetadataConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioOutputConfigurations">
			<wsdl:documentation>This command lists all existing AudioOutputConfigurations of a device. The NVC need not know anything apriori about the audio configurations to use this command.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioOutputConfigurationsRequest"/>
			<wsdl:output message="trt:GetAudioOutputConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioDecoderConfigurations">
			<wsdl:documentation>This command lists all existing AudioDecoderConfigurations of a device. The NVC need not know anything apriori about the audio decoder configurations in order to
use this command.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioDecoderConfigurationsRequest"/>
			<wsdl:output message="trt:GetAudioDecoderConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetVideoSourceConfiguration">
			<wsdl:documentation>If the video source configuration token is already known, the video source configuration can be fetched through the GetVideoSourceConfiguration command.</wsdl:documentation>
			<wsdl:input message="trt:GetVideoSourceConfigurationRequest"/>
			<wsdl:output message="trt:GetVideoSourceConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetVideoEncoderConfiguration">
			<wsdl:documentation>If the video encoder configuration token is already known, the encoder configuration can be fetched through the GetVideoEncoderConfiguration command.</wsdl:documentation>
			<wsdl:input message="trt:GetVideoEncoderConfigurationRequest"/>
			<wsdl:output message="trt:GetVideoEncoderConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioSourceConfiguration">
			<wsdl:documentation>The GetAudioSourceConfiguration command fetches the audio source configurations if the audio source configuration token is already known. An</wsdl:documentation>
			<wsdl:input message="trt:GetAudioSourceConfigurationRequest"/>
			<wsdl:output message="trt:GetAudioSourceConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioEncoderConfiguration">
			<wsdl:documentation>The GetAudioEncoderConfiguration command fetches the encoder configuration if the audio encoder configuration token is known.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioEncoderConfigurationRequest"/>
			<wsdl:output message="trt:GetAudioEncoderConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetVideoAnalyticsConfiguration">
			<wsdl:documentation>The GetVideoAnalyticsConfiguration command fetches the video analytics configuration if the video analytics token is known.</wsdl:documentation>
			<wsdl:input message="trt:GetVideoAnalyticsConfigurationRequest"/>
			<wsdl:output message="trt:GetVideoAnalyticsConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetMetadataConfiguration">
			<wsdl:documentation>The GetMetadataConfiguration command fetches the metadata configuration if the metadata token is known.</wsdl:documentation>
			<wsdl:input message="trt:GetMetadataConfigurationRequest"/>
			<wsdl:output message="trt:GetMetadataConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioOutputConfiguration">
			<wsdl:documentation>If the audio output configuration token is already known, the output configuration can be fetched through the GetAudioOutputConfiguration command.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioOutputConfigurationRequest"/>
			<wsdl:output message="trt:GetAudioOutputConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioDecoderConfiguration">
			<wsdl:documentation>If the audio decoder configuration token is already known, the decoder configuration can be fetched through the GetAudioDecoderConfiguration command.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioDecoderConfigurationRequest"/>
			<wsdl:output message="trt:GetAudioDecoderConfigurationResponse"/>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetCompatibleVideoEncoderConfigurations">
			<wsdl:documentation>This operation lists all the video encoder configurations of the device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddVideoEncoderConfiguration command on the media profile. The result will vary depending on the capabilities, configurations and settings in the device.</wsdl:documentation>
			<wsdl:input message="trt:GetCompatibleVideoEncoderConfigurationsRequest"/>
			<wsdl:output message="trt:GetCompatibleVideoEncoderConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleVideoSourceConfigurations">
			<wsdl:documentation>This operation requests all the video source configurations of the device that are compatible
with a certain media profile. Each of the returned configurations shall be a valid input
parameter for the AddVideoSourceConfiguration command on the media profile. The result
will vary depending on the capabilities, configurations and settings in the device.</wsdl:documentation>
			<wsdl:input message="trt:GetCompatibleVideoSourceConfigurationsRequest"/>
			<wsdl:output message="trt:GetCompatibleVideoSourceConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleAudioEncoderConfigurations">
			<wsdl:documentation>This operation requests all audio encoder configurations of a device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddAudioSourceConfiguration command on the media profile. The result varies depending on the capabilities, configurations and settings in the device.</wsdl:documentation>
			<wsdl:input message="trt:GetCompatibleAudioEncoderConfigurationsRequest"/>
			<wsdl:output message="trt:GetCompatibleAudioEncoderConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleAudioSourceConfigurations">
			<wsdl:documentation>This operation requests all audio source configurations of the device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddAudioEncoderConfiguration command on the media profile. The result varies depending on the capabilities, configurations and settings in the device.</wsdl:documentation>
			<wsdl:input message="trt:GetCompatibleAudioSourceConfigurationsRequest"/>
			<wsdl:output message="trt:GetCompatibleAudioSourceConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleVideoAnalyticsConfigurations">
			<wsdl:documentation>This operation requests all video analytic configurations of the device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddVideoAnalyticsConfiguration command on the media profile. The result varies depending on the capabilities, configurations and settings in the device.</wsdl:documentation>
			<wsdl:input message="trt:GetCompatibleVideoAnalyticsConfigurationsRequest"/>
			<wsdl:output message="trt:GetCompatibleVideoAnalyticsConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleMetadataConfigurations">
			<wsdl:documentation>This operation requests all the metadata configurations of the device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddMetadataConfiguration command on the media profile. The result varies depending on the capabilities, configurations and settings in the device.</wsdl:documentation>
			<wsdl:input message="trt:GetCompatibleMetadataConfigurationsRequest"/>
			<wsdl:output message="trt:GetCompatibleMetadataConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleAudioOutputConfigurations">
			<wsdl:documentation>This command lists all audio output configurations of a device that are compatible with a certain media profile. Each returned configuration shall be a valid input for the 
AddAudioOutputConfiguration command.</wsdl:documentation>
			<wsdl:input message="trt:GetCompatibleAudioOutputConfigurationsRequest"/>
			<wsdl:output message="trt:GetCompatibleAudioOutputConfigurationsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleAudioDecoderConfigurations">
			<wsdl:documentation>This operation lists all the audio decoder configurations of the device that are compatible with a certain media profile. Each of the returned configurations shall be a valid input parameter for the AddAudioDecoderConfiguration command on the media profile.</wsdl:documentation>
			<wsdl:input message="trt:GetCompatibleAudioDecoderConfigurationsRequest"/>
			<wsdl:output message="trt:GetCompatibleAudioDecoderConfigurationsResponse"/>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="SetVideoSourceConfiguration">
			<wsdl:documentation>This operation modifies a video source configuration. The ForcePersistence flag indicates if the changes shall remain after reboot of the device. Running streams using this configuration may be immediately updated according to the new settings. The changes are not guaranteed to take effect unless the client requests a new stream URI and restarts any affected stream. NVC methods for changing a running stream are out of scope for this specification.</wsdl:documentation>
			<wsdl:input message="trt:SetVideoSourceConfigurationRequest"/>
			<wsdl:output message="trt:SetVideoSourceConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetVideoEncoderConfiguration">
			<wsdl:documentation>This operation modifies a video encoder configuration. The ForcePersistence flag indicates if the changes shall remain after reboot of the device. Changes in the Multicast settings shall always be persistent. Running streams using this configuration may be immediately updated according to the new settings. The changes are not guaranteed to take effect unless the client requests a new stream URI and restarts any affected stream. NVC methods for changing a running stream are out of scope for this specification. <br/>SessionTimeout is provided as a hint for keeping rtsp session by a device. If necessary the device may adapt parameter values for SessionTimeout elements without returning an error. For the time between keep alive calls the client shall adhere to the timeout value signaled via RTSP.</wsdl:documentation>
			<wsdl:input message="trt:SetVideoEncoderConfigurationRequest"/>
			<wsdl:output message="trt:SetVideoEncoderConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetAudioSourceConfiguration">
			<wsdl:documentation>This operation modifies an audio source configuration. The ForcePersistence flag indicates if
the changes shall remain after reboot of the device. Running streams using this configuration
may be immediately updated according to the new settings. The changes are not guaranteed
to take effect unless the client requests a new stream URI and restarts any affected stream
NVC methods for changing a running stream are out of scope for this specification.</wsdl:documentation>
			<wsdl:input message="trt:SetAudioSourceConfigurationRequest"/>
			<wsdl:output message="trt:SetAudioSourceConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetAudioEncoderConfiguration">
			<wsdl:documentation>This operation modifies an audio encoder configuration. The ForcePersistence flag indicates if
the changes shall remain after reboot of the device. Running streams using this configuration may be immediately updated
according to the new settings. The changes are not guaranteed to take effect unless the client
requests a new stream URI and restarts any affected streams. NVC methods for changing a
running stream are out of scope for this specification.</wsdl:documentation>
			<wsdl:input message="trt:SetAudioEncoderConfigurationRequest"/>
			<wsdl:output message="trt:SetAudioEncoderConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetVideoAnalyticsConfiguration">
			<wsdl:documentation>A video analytics configuration is modified using this command. The ForcePersistence flag
indicates if the changes shall remain after reboot of the device or not. Running streams using
this configuration shall be immediately updated according to the new settings. Otherwise
inconsistencies can occur between the scene description processed by the rule engine and
the notifications produced by analytics engine and rule engine which reference the very same
video analytics configuration token.</wsdl:documentation>
			<wsdl:input message="trt:SetVideoAnalyticsConfigurationRequest"/>
			<wsdl:output message="trt:SetVideoAnalyticsConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetMetadataConfiguration">
			<wsdl:documentation>This operation modifies a metadata configuration. The ForcePersistence flag indicates if the
changes shall remain after reboot of the device. Changes in the Multicast settings shall
always be persistent. Running streams using this configuration may be updated immediately
according to the new settings. The changes are not guaranteed to take effect unless the client
requests a new stream URI and restarts any affected streams. NVC methods for changing a
running stream are out of scope for this specification.</wsdl:documentation>
			<wsdl:input message="trt:SetMetadataConfigurationRequest"/>
			<wsdl:output message="trt:SetMetadataConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetAudioOutputConfiguration">
			<wsdl:documentation>This operation modifies an audio output configuration. The ForcePersistence flag indicates if
the changes shall remain after reboot of the device.</wsdl:documentation>
			<wsdl:input message="trt:SetAudioOutputConfigurationRequest"/>
			<wsdl:output message="trt:SetAudioOutputConfigurationResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetAudioDecoderConfiguration">
			<wsdl:documentation>This operation modifies an audio decoder configuration. The ForcePersistence flag indicates if
the changes shall remain after reboot of the device.</wsdl:documentation>
			<wsdl:input message="trt:SetAudioDecoderConfigurationRequest"/>
			<wsdl:output message="trt:SetAudioDecoderConfigurationResponse"/>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetVideoSourceConfigurationOptions">
			<wsdl:documentation>This operation returns the available options  (supported values and ranges for video source configuration parameters) when the video source parameters are
reconfigured If a video source configuration is specified, the options shall concern that
particular configuration. If a media profile is specified, the options shall be compatible with
that media profile.</wsdl:documentation>
			<wsdl:input message="trt:GetVideoSourceConfigurationOptionsRequest"/>
			<wsdl:output message="trt:GetVideoSourceConfigurationOptionsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetVideoEncoderConfigurationOptions">
			<wsdl:documentation>This operation returns the available options (supported values and ranges for video encoder 
				configuration parameters) when the video encoder parameters are reconfigured. <br/>
				For JPEG, MPEG4 and H264 extension elements have been defined that provide additional information. A device must provide the 
				XxxOption information for all encodings supported and should additionally provide the corresponding XxxOption2 information.<br/>
				This response contains the available video encoder configuration options. If a video encoder configuration is specified, 
				the options shall concern that particular configuration. If a media profile is specified, the options shall be 
				compatible with that media profile. If no tokens are specified, the options shall be considered generic for the device.
			</wsdl:documentation>
			<wsdl:input message="trt:GetVideoEncoderConfigurationOptionsRequest"/>
			<wsdl:output message="trt:GetVideoEncoderConfigurationOptionsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioSourceConfigurationOptions">
			<wsdl:documentation>This operation returns the available options (supported values and ranges for audio source configuration parameters) when the audio source parameters are
reconfigured. If an audio source configuration is specified, the options shall concern that
particular configuration. If a media profile is specified, the options shall be compatible with
that media profile.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioSourceConfigurationOptionsRequest"/>
			<wsdl:output message="trt:GetAudioSourceConfigurationOptionsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioEncoderConfigurationOptions">
			<wsdl:documentation>This operation returns the available options  (supported values and ranges for audio encoder configuration parameters) when the audio encoder parameters are
reconfigured.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioEncoderConfigurationOptionsRequest"/>
			<wsdl:output message="trt:GetAudioEncoderConfigurationOptionsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetMetadataConfigurationOptions">
			<wsdl:documentation>This operation returns the available options (supported values and ranges for metadata configuration parameters) for changing the metadata configuration.</wsdl:documentation>
			<wsdl:input message="trt:GetMetadataConfigurationOptionsRequest"/>
			<wsdl:output message="trt:GetMetadataConfigurationOptionsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioOutputConfigurationOptions">
			<wsdl:documentation>This operation returns the available options (supported values and ranges for audio output configuration parameters) for configuring an audio output.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioOutputConfigurationOptionsRequest"/>
			<wsdl:output message="trt:GetAudioOutputConfigurationOptionsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetAudioDecoderConfigurationOptions">
			<wsdl:documentation>This command list the audio decoding capabilities for a given profile and configuration of a
device.</wsdl:documentation>
			<wsdl:input message="trt:GetAudioDecoderConfigurationOptionsRequest"/>
			<wsdl:output message="trt:GetAudioDecoderConfigurationOptionsResponse"/>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetGuaranteedNumberOfVideoEncoderInstances">
			<wsdl:documentation>The GetGuaranteedNumberOfVideoEncoderInstances command can be used to request the
minimum number of guaranteed video encoder instances (applications) per Video Source
Configuration.</wsdl:documentation>
			<wsdl:input message="trt:GetGuaranteedNumberOfVideoEncoderInstancesRequest"/>
			<wsdl:output message="trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse"/>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetStreamUri">
			<wsdl:documentation>This operation requests a URI that can be used to initiate a live media stream using RTSP as
the control protocol. The returned URI shall remain valid indefinitely even if the profile is
changed. The ValidUntilConnect, ValidUntilReboot and Timeout Parameter shall be set
accordingly (ValidUntilConnect=false, ValidUntilReboot=false, timeout=PT0S). <br/>
				The correct syntax for the StreamSetup element for these media stream setups defined in 5.1.1 of the streaming specification are as follows:
				<ol>
					<li>RTP unicast over UDP: StreamType = "RTP_unicast", TransportProtocol = "UDP"</li>
					<li>RTP over RTSP over HTTP over TCP: StreamType = "RTP_unicast", TransportProtocol = "HTTP"</li>
					<li>RTP over RTSP over TCP: StreamType = "RTP_unicast", TransportProtocol = "RTSP"</li>
				</ol>
				<br/>
If a multicast stream is requested at least one of VideoEncoderConfiguration, AudioEncoderConfiguration and MetadataConfiguration shall have a valid multicast setting.<br/>
For full compatibility with other ONVIF services a device should not generate Uris longer than
128 octets.</wsdl:documentation>
			<wsdl:input message="trt:GetStreamUriRequest"/>
			<wsdl:output message="trt:GetStreamUriResponse"/>
		</wsdl:operation>
		<wsdl:operation name="StartMulticastStreaming">
			<wsdl:documentation>This command starts multicast streaming using a specified media profile of a device.
Streaming continues until StopMulticastStreaming is called for the same Profile. The
streaming shall continue after a reboot of the device until a StopMulticastStreaming request is
received. The multicast address, port and TTL are configured in the
VideoEncoderConfiguration, AudioEncoderConfiguration and MetadataConfiguration
respectively.</wsdl:documentation>
			<wsdl:input message="trt:StartMulticastStreamingRequest"/>
			<wsdl:output message="trt:StartMulticastStreamingResponse"/>
		</wsdl:operation>
		<wsdl:operation name="StopMulticastStreaming">
			<wsdl:documentation>This command stop multicast streaming using a specified media profile of a device</wsdl:documentation>
			<wsdl:input message="trt:StopMulticastStreamingRequest"/>
			<wsdl:output message="trt:StopMulticastStreamingResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetSynchronizationPoint">
			<wsdl:documentation>Synchronization points allow clients to decode and correctly use all data after the
synchronization point.
For example, if a video stream is configured with a large I-frame distance and a client loses a
single packet, the client does not display video until the next I-frame is transmitted. In such
cases, the client can request a Synchronization Point which enforces the device to add an I-Frame as soon as possible. Clients can request Synchronization Points for profiles. The device
shall add synchronization points for all streams associated with this profile.
Similarly, a synchronization point is used to get an update on full PTZ or event status through
the metadata stream.
If a video stream is associated with the profile, an I-frame shall be added to this video stream.
If a PTZ metadata stream is associated to the profile,
the PTZ position shall be repeated within the metadata stream.</wsdl:documentation>
			<wsdl:input message="trt:SetSynchronizationPointRequest"/>
			<wsdl:output message="trt:SetSynchronizationPointResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetSnapshotUri">
			<wsdl:documentation>A client uses the GetSnapshotUri command to obtain a JPEG snapshot from the
device. The returned URI shall remain valid indefinitely even if the profile is changed. The
ValidUntilConnect, ValidUntilReboot and Timeout Parameter shall be set accordingly
(ValidUntilConnect=false, ValidUntilReboot=false, timeout=PT0S). The URI can be used for
acquiring a JPEG image through a HTTP GET operation. The image encoding will always be
JPEG regardless of the encoding setting in the media profile. The Jpeg settings
(like resolution or quality) may be taken from the profile if suitable. The provided
image will be updated automatically and independent from calls to GetSnapshotUri.</wsdl:documentation>
			<wsdl:input message="trt:GetSnapshotUriRequest"/>
			<wsdl:output message="trt:GetSnapshotUriResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetVideoSourceModes">
			<wsdl:documentation>A device returns the information for current video source mode and settable video source modes of specified video source. A device that indicates a capability of  VideoSourceModes shall support this command.</wsdl:documentation>
			<wsdl:input message="trt:GetVideoSourceModesRequest"/>
			<wsdl:output message="trt:GetVideoSourceModesResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetVideoSourceMode">
			<wsdl:documentation>SetVideoSourceMode changes the media profile structure relating to video source for the specified video source mode. A device that indicates a capability of VideoSourceModes shall support this command. The behavior after changing the mode is not defined in this specification.</wsdl:documentation>
			<wsdl:input message="trt:SetVideoSourceModeRequest"/>
			<wsdl:output message="trt:SetVideoSourceModeResponse"/>
		</wsdl:operation>
		<!--==============OSD Operation Begin=================-->
		<wsdl:operation name="GetOSDs">
			<wsdl:documentation>Get the OSDs.</wsdl:documentation>
			<wsdl:input message="trt:GetOSDsRequest"/>
			<wsdl:output message="trt:GetOSDsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetOSD">
			<wsdl:documentation>Get the OSD.</wsdl:documentation>
			<wsdl:input message="trt:GetOSDRequest"/>
			<wsdl:output message="trt:GetOSDResponse"/>
		</wsdl:operation>
		<wsdl:operation name="GetOSDOptions">
			<wsdl:documentation>Get the OSD Options.</wsdl:documentation>
			<wsdl:input message="trt:GetOSDOptionsRequest"/>
			<wsdl:output message="trt:GetOSDOptionsResponse"/>
		</wsdl:operation>
		<wsdl:operation name="SetOSD">
			<wsdl:documentation>Set the OSD</wsdl:documentation>
			<wsdl:input message="trt:SetOSDRequest"/>
			<wsdl:output message="trt:SetOSDResponse"/>
		</wsdl:operation>
		<wsdl:operation name="CreateOSD">
			<wsdl:documentation>Create the OSD.</wsdl:documentation>
			<wsdl:input message="trt:CreateOSDRequest"/>
			<wsdl:output message="trt:CreateOSDResponse"/>
		</wsdl:operation>
		<wsdl:operation name="DeleteOSD">
			<wsdl:documentation>Delete the OSD.</wsdl:documentation>
			<wsdl:input message="trt:DeleteOSDRequest"/>
			<wsdl:output message="trt:DeleteOSDResponse"/>
		</wsdl:operation>
		<!--==============OSD Operation End=================-->
	</wsdl:portType>
	<wsdl:binding name="MediaBinding" type="trt:Media">
		<soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/>
		<!--===============================-->
		<!--===============================-->
		<wsdl:operation name="GetServiceCapabilities">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetServiceCapabilities"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetVideoSources">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdlGetVideoSources/"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<!--===============================-->
		<wsdl:operation name="GetAudioSources">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioSources"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetAudioOutputs">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioOutputs"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="CreateProfile">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/CreateProfile"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetProfile">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdlGetProfile/"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetProfiles">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetProfiles"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="AddVideoEncoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/AddVideoEncoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="AddVideoSourceConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/AddVideoSourceConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="AddAudioEncoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/AddAudioEncoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="AddAudioSourceConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/AddAudioSourceConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="AddPTZConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/AddPTZConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="AddVideoAnalyticsConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/AddVideoAnalyticsConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="AddMetadataConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/AddMetadataConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="AddAudioOutputConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/AddAudioOutputConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="AddAudioDecoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/AddAudioDecoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="RemoveVideoEncoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/RemoveVideoEncoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="RemoveVideoSourceConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/RemoveVideoSourceConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="RemoveAudioEncoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/RemoveAudioEncoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="RemoveAudioSourceConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/RemoveAudioSourceConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="RemovePTZConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/RemovePTZConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="RemoveVideoAnalyticsConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/RemoveVideoAnalyticsConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="RemoveMetadataConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/RemoveMetadataConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="RemoveAudioOutputConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/RemoveAudioOutputConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="RemoveAudioDecoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/RemoveAudioDecoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="DeleteProfile">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/DeleteProfile"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<!--===============================-->
		<!--===============================-->
		<wsdl:operation name="GetVideoSourceConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetVideoSourceConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetVideoEncoderConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetVideoEncoderConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioSourceConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdlGetAudioSourceConfigurations/"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioEncoderConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioEncoderConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetVideoAnalyticsConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetVideoAnalyticsConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetMetadataConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetMetadataConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioOutputConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioOutputConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioDecoderConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioDecoderConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetVideoSourceConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetVideoSourceConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetVideoEncoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetVideoEncoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioSourceConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioSourceConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioEncoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioEncoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetVideoAnalyticsConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetVideoAnalyticsConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetMetadataConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetMetadataConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioOutputConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioOutputConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioDecoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioDecoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetCompatibleVideoEncoderConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetCompatibleVideoEncoderConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleVideoSourceConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetCompatibleVideoSourceConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleAudioEncoderConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetCompatibleAudioEncoderConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleAudioSourceConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetCompatibleAudioSourceConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleVideoAnalyticsConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetCompatibleVideoAnalyticsConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleMetadataConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetCompatibleMetadataConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleAudioOutputConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetCompatibleAudioOutputConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetCompatibleAudioDecoderConfigurations">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetCompatibleAudioDecoderConfigurations"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="SetVideoSourceConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetVideoSourceConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetVideoEncoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetVideoEncoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetAudioSourceConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetAudioSourceConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetAudioEncoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetAudioEncoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetVideoAnalyticsConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetVideoAnalyticsConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetMetadataConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetMetadataConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetAudioOutputConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetAudioOutputConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetAudioDecoderConfiguration">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetAudioDecoderConfiguration"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetVideoSourceConfigurationOptions">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdlGetVideoSourceConfigurationOptions/"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetVideoEncoderConfigurationOptions">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetVideoEncoderConfigurationOptions"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioSourceConfigurationOptions">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioSourceConfigurationOptions"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioEncoderConfigurationOptions">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioEncoderConfigurationOptions"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetMetadataConfigurationOptions">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetMetadataConfigurationOptions"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioOutputConfigurationOptions">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioOutputConfigurationOptions"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetAudioDecoderConfigurationOptions">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetAudioDecoderConfigurationOptions"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetGuaranteedNumberOfVideoEncoderInstances">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetGuaranteedNumberOfVideoEncoderInstances"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<!--===============================-->
		<!--===============================-->
		<wsdl:operation name="GetStreamUri">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetStreamUri"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="StartMulticastStreaming">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/StartMulticastStreaming"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="StopMulticastStreaming">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/StopMulticastStreaming"/>
			<wsdl:input>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body parts="parameters" use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="SetSynchronizationPoint">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetSynchronizationPoint"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetSnapshotUri">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetSnapshotUri"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="GetVideoSourceModes">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetVideoSourceModes"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<wsdl:operation name="SetVideoSourceMode">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetVideoSourceMode"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--===============================-->
		<!--==============OSD Operation Begin=================-->
		<wsdl:operation name="GetOSDs">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetOSDs"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetOSD">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetOSD"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="GetOSDOptions">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/GetOSDOptions"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="SetOSD">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/SetOSD"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="CreateOSD">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/CreateOSD"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<wsdl:operation name="DeleteOSD">
			<soap:operation soapAction="http://www.onvif.org/ver10/media/wsdl/DeleteOSD"/>
			<wsdl:input>
				<soap:body use="literal"/>
			</wsdl:input>
			<wsdl:output>
				<soap:body use="literal"/>
			</wsdl:output>
		</wsdl:operation>
		<!--==============OSD Operation End=================-->
	</wsdl:binding>
</wsdl:definitions>
</file>

<file path="wsdl/vendor/onvif.xsd">
<?xml version="1.0" encoding="utf-8"?>
<!--<?xml-stylesheet type="text/xsl" href="onvif-schema-viewer.xsl"?>-->
<!--
Copyright (c) 2008-2024 by ONVIF: Open Network Video Interface Forum. All rights reserved.

Recipients of this document may copy, distribute, publish, or display this document so long as this copyright notice, license and disclaimer are retained with all copies of the document. No license is granted to modify this document.

THIS DOCUMENT IS PROVIDED "AS IS," AND THE CORPORATION AND ITS MEMBERS AND THEIR AFFILIATES, MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR TITLE; THAT THE CONTENTS OF THIS DOCUMENT ARE SUITABLE FOR ANY PURPOSE; OR THAT THE IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.
IN NO EVENT WILL THE CORPORATION OR ITS MEMBERS OR THEIR AFFILIATES BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL, PUNITIVE OR CONSEQUENTIAL DAMAGES, ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT, WHETHER OR NOT (1) THE CORPORATION, MEMBERS OR THEIR AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR (2) SUCH DAMAGES WERE REASONABLY FORESEEABLE, AND ARISING OUT OF OR RELATING TO ANY USE OR DISTRIBUTION OF THIS DOCUMENT.  THE FOREGOING DISCLAIMER AND LIMITATION ON LIABILITY DO NOT APPLY TO, INVALIDATE, OR LIMIT REPRESENTATIONS AND WARRANTIES MADE BY THE MEMBERS AND THEIR RESPECTIVE AFFILIATES TO THE CORPORATION AND OTHER MEMBERS IN CERTAIN WRITTEN POLICIES OF THE CORPORATION.
-->
<xs:schema xmlns:tt="http://www.onvif.org/ver10/schema" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:wsnt="http://docs.oasis-open.org/wsn/b-2" xmlns:xop="http://www.w3.org/2004/08/xop/include" xmlns:soapenv="http://www.w3.org/2003/05/soap-envelope" targetNamespace="http://www.onvif.org/ver10/schema" elementFormDefault="qualified" version="24.12">
	<xs:include schemaLocation="./common.xsd"/>
	<xs:import namespace="http://www.w3.org/2005/05/xmlmime" schemaLocation="./xmlmime.xsd"/>
	<xs:import namespace="http://www.w3.org/2003/05/soap-envelope" schemaLocation="./soap-envelope.xsd"/>
	<xs:import namespace="http://docs.oasis-open.org/wsn/b-2" schemaLocation="./b-2.xsd"/>
	<xs:import namespace="http://www.w3.org/2004/08/xop/include" schemaLocation="./include.xsd"/>
	<!--===============================-->
	<!--         Generic Types         -->
	<!--===============================-->
	<xs:complexType name="DeviceEntity">
		<xs:annotation>
			<xs:documentation>Base class for physical entities like inputs and outputs.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="token" type="tt:ReferenceToken" use="required">
			<xs:annotation>
				<xs:documentation>Unique identifier referencing the physical entity.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="Name">
		<xs:annotation>
			<xs:documentation>User readable name. Length up to 64 characters.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:maxLength value="64"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="IntRectangle">
		<xs:annotation>
			<xs:documentation>Rectangle defined by lower left corner position and size. Units are pixel.</xs:documentation>
		</xs:annotation>
		<xs:attribute name="x" type="xs:int" use="required"/>
		<xs:attribute name="y" type="xs:int" use="required"/>
		<xs:attribute name="width" type="xs:int" use="required"/>
		<xs:attribute name="height" type="xs:int" use="required"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IntRectangleRange">
		<xs:annotation>
			<xs:documentation>Range of a rectangle. The rectangle itself is defined by lower left corner position and size. Units are pixel.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="XRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Range of X-axis.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="YRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Range of Y-axis.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WidthRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Range of width.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="HeightRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Range of height.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FloatRange">
		<xs:annotation>
			<xs:documentation>Range of values greater equal Min value and less equal Max value.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Min" type="xs:float"/>
			<xs:element name="Max" type="xs:float"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DurationRange">
		<xs:annotation>
			<xs:documentation>Range of duration greater equal Min duration and less equal Max duration.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Min" type="xs:duration"/>
			<xs:element name="Max" type="xs:duration"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IntItems">
		<xs:annotation>
			<xs:documentation>List of values.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Items" type="xs:int" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="IntList">
		<xs:list itemType="xs:int"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="FloatList">
		<xs:list itemType="xs:float"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="StringAttrList">
		<xs:list itemType="xs:string"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="StringList">
		<xs:list itemType="xs:string"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="ReferenceTokenList">
		<xs:list itemType="tt:ReferenceToken"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="FloatItems">
		<xs:sequence>
			<xs:element name="Items" type="xs:float" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:element name="StringItems">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Item" type="xs:string" maxOccurs="unbounded" />
			</xs:sequence>
		</xs:complexType>
	</xs:element>
	<xs:element name="StringList" type="tt:StringList"/>
	<xs:element name="IntRange" type="tt:IntRange"/>
	<xs:element name="IntList" type="tt:IntList"/>
	<xs:element name="FloatRange" type="tt:FloatRange"/>
	<xs:element name="FloatList" type="tt:FloatList"/>
	<xs:element name="DurationRange" type="tt:DurationRange"/>
	<xs:element name="IntRectangleRange" type="tt:IntRectangleRange"/>
	<!--===============================-->
	<xs:complexType name="AnyHolder">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--      End, Generic Types       -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--      Media Related Types      -->
	<!--===============================-->
	<xs:complexType name="VideoSource">
		<xs:annotation>
			<xs:documentation>Representation of a physical video input.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="tt:DeviceEntity">
				<xs:sequence>
					<xs:element name="Framerate" type="xs:float">
						<xs:annotation>
							<xs:documentation>Frame rate in frames per second.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Resolution" type="tt:VideoResolution">
						<xs:annotation>
							<xs:documentation>Horizontal and vertical resolution</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Imaging" type="tt:ImagingSettings" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Optional configuration of the image sensor.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extension" type="tt:VideoSourceExtension" minOccurs="0"/>
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoSourceExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Imaging" type="tt:ImagingSettings20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional configuration of the image sensor. To be used if imaging service 2.00 is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:VideoSourceExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoSourceExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AudioSource">
		<xs:annotation>
			<xs:documentation>Representation of a physical audio input.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="tt:DeviceEntity">
				<xs:sequence>
					<xs:element name="Channels" type="xs:int">
						<xs:annotation>
							<xs:documentation>number of available audio channels. (1: mono, 2: stereo) </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Profile">
		<xs:annotation>
			<xs:documentation>
			A media profile consists of a set of media configurations. Media profiles are used by a client
			to configure properties of a media stream from an NVT.<br/>
			An NVT shall provide at least one media profile at boot. An NVT should provide ready to use
			profiles for the most common media configurations that the device offers.<br/>
			A profile consists of a set of interconnected configuration entities. Configurations are provided
			by the NVT and can be either static or created dynamically by the NVT. For example, the
			dynamic configurations can be created by the NVT depending on current available encoding
			resources.
		</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Name" type="tt:Name">
				<xs:annotation>
					<xs:documentation>User readable name of the profile.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VideoSourceConfiguration" type="tt:VideoSourceConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional configuration of the Video input.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AudioSourceConfiguration" type="tt:AudioSourceConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional configuration of the Audio input.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VideoEncoderConfiguration" type="tt:VideoEncoderConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional configuration of the Video encoder.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AudioEncoderConfiguration" type="tt:AudioEncoderConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional configuration of the Audio encoder.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VideoAnalyticsConfiguration" type="tt:VideoAnalyticsConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional configuration of the video analytics module and rule engine.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PTZConfiguration" type="tt:PTZConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional configuration of the pan tilt zoom unit.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MetadataConfiguration" type="tt:MetadataConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional configuration of the metadata stream.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ProfileExtension" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Extensions defined in ONVIF 2.0</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="token" type="tt:ReferenceToken" use="required">
			<xs:annotation>
				<xs:documentation>Unique identifier of the profile.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fixed" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>A value of true signals that the profile cannot be deleted. Default is false.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ProfileExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="AudioOutputConfiguration" type="tt:AudioOutputConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional configuration of the Audio output.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AudioDecoderConfiguration" type="tt:AudioDecoderConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional configuration of the Audio decoder.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ProfileExtension2" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ProfileExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:element name="VideoSourceConfiguration" type="tt:VideoSourceConfiguration"/>
	<xs:element name="AudioSourceConfiguration" type="tt:AudioSourceConfiguration"/>
	<xs:element name="VideoEncoderConfiguration" type="tt:VideoEncoderConfiguration"/>
	<xs:element name="AudioEncoderConfiguration" type="tt:AudioEncoderConfiguration"/>
	<xs:element name="VideoAnalyticsConfiguration" type="tt:VideoAnalyticsConfiguration"/>
	<xs:element name="PTZConfiguration" type="tt:PTZConfiguration"/>
	<xs:element name="MetadataConfiguration" type="tt:MetadataConfiguration"/>
	<xs:element name="AudioOutputConfiguration" type="tt:AudioOutputConfiguration"/>
	<xs:element name="AudioDecoderConfiguration" type="tt:AudioDecoderConfiguration"/>
	<!--===============================-->
	<xs:complexType name="ConfigurationEntity">
		<xs:annotation>
			<xs:documentation>Base type defining the common properties of a configuration.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Name" type="tt:Name">
				<xs:annotation>
					<xs:documentation>User readable name. Length up to 64 characters.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UseCount" type="xs:int">
				<xs:annotation>
					<xs:documentation>Number of internal references currently using this configuration. <p style='margin:0'>This informational parameter is read-only. Deprecated for Media2 Service.</p></xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="token" type="tt:ReferenceToken" use="required">
			<xs:annotation>
				<xs:documentation>Token that uniquely references this configuration. Length up to 64 characters.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--===============================-->
	<!--   VideoSourceConfiguration   -->
	<!--===============================-->
	<xs:complexType name="VideoSourceConfiguration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="SourceToken" type="tt:ReferenceToken">
						<xs:annotation>
							<xs:documentation>Reference to the physical input.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Bounds" type="tt:IntRectangle">
						<xs:annotation>
							<xs:documentation>Rectangle specifying the Video capturing area. The capturing area shall not be larger than the whole Video source area.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="Extension" type="tt:VideoSourceConfigurationExtension" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="ViewMode" type="xs:string">
					<xs:annotation>
						<xs:documentation>Readonly parameter signalling Source configuration's view mode, for devices supporting different view modes as defined in tt:viewModes.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoSourceConfigurationExtension">
		<xs:sequence>
			<xs:element name="Rotate" type="tt:Rotate" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional element to configure rotation of captured image.
						What resolutions a device supports shall be unaffected by the Rotate parameters.<br/>
						If a device is configured with Rotate=AUTO, the device shall take control over the Degree parameter and automatically update it so that a client can query current rotation.<br/>
						The device shall automatically apply the same rotation to its pan/tilt control direction depending on the following condition: 
						if Reverse=AUTO in PTControlDirection or if the device doesnt support Reverse in PTControlDirection
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:VideoSourceConfigurationExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoSourceConfigurationExtension2">
		<xs:sequence>
			<xs:element name="LensDescription" type="tt:LensDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation><xs:documentation>Optional element describing the geometric lens distortion. Multiple instances for future variable lens support.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:element name="SceneOrientation" type="tt:SceneOrientation" minOccurs="0" maxOccurs="1">
				<xs:annotation><xs:documentation>Optional element describing the scene orientation in the cameras field of view.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Rotate">
		<xs:sequence>
			<xs:element name="Mode" type="tt:RotateMode">
				<xs:annotation>
					<xs:documentation>Parameter to enable/disable Rotation feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Degree" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional parameter to configure how much degree of clockwise rotation of image  for On mode. Omitting this parameter for On mode means 180 degree rotation.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:RotateExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RotateExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="RotateMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="OFF">
				<xs:annotation><xs:documentation>Enable the Rotate feature. Degree of rotation is specified Degree parameter.</xs:documentation></xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ON">
			<xs:annotation><xs:documentation>Disable the Rotate feature.</xs:documentation></xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AUTO">
				<xs:annotation><xs:documentation>Rotate feature is automatically activated by the device.</xs:documentation></xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="LensProjection">
		<xs:sequence>
			<xs:element name="Angle" type="xs:float">
				<xs:annotation><xs:documentation>Angle of incidence.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:element name="Radius" type="xs:float">
				<xs:annotation><xs:documentation>Mapping radius as a consequence of the emergent angle.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:element name="Transmittance" type="xs:float" minOccurs="0">
				<xs:annotation><xs:documentation>Optional ray absorption at the given angle due to vignetting. A value of one means no absorption.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="LensOffset">
		<xs:attribute name="x" type="xs:float">
			<xs:annotation><xs:documentation>Optional horizontal offset of the lens center in normalized coordinates.</xs:documentation></xs:annotation>
		</xs:attribute>
		<xs:attribute name="y" type="xs:float">
			<xs:annotation><xs:documentation>Optional vertical offset of the lens center in normalized coordinates.</xs:documentation></xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="LensDescription">
		<xs:sequence>
			<xs:element name="Offset" type="tt:LensOffset">
				<xs:annotation><xs:documentation>Offset of the lens center to the imager center in normalized coordinates.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:element name="Projection" type="tt:LensProjection" maxOccurs="unbounded">
				<xs:annotation><xs:documentation>Radial description of the projection characteristics. The resulting curve is defined by the B-Spline interpolation 
					over the given elements. The element for Radius zero shall not be provided. The projection points shall be ordered with ascending Radius. 
					Items outside the last projection Radius shall be assumed to be invisible (black).</xs:documentation></xs:annotation>
			</xs:element>
			<xs:element name="XFactor" type="xs:float">
				<xs:annotation><xs:documentation>Compensation of the x coordinate needed for the ONVIF normalized coordinate system. </xs:documentation></xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:attribute name="FocalLength" type="xs:float">
			<xs:annotation><xs:documentation>Optional focal length of the optical system.</xs:documentation></xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoSourceConfigurationOptions">
		<xs:sequence>
			<xs:element name="BoundsRange" type="tt:IntRectangleRange">
				<xs:annotation>
					<xs:documentation>
						Supported range for the capturing area.
						Device that does not support cropped streaming shall express BoundsRange option as mentioned below
						BoundsRange->XRange and BoundsRange->YRange with same Min/Max values HeightRange and WidthRange Min/Max values same as VideoSource Height and Width Limits.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VideoSourceTokensAvailable" type="tt:ReferenceToken" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of physical inputs.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:VideoSourceConfigurationOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="MaximumNumberOfProfiles" type="xs:int">
			<xs:annotation>
				<xs:documentation>Maximum number of profiles.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoSourceConfigurationOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Rotate" type="tt:RotateOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Options of parameters for Rotation feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:VideoSourceConfigurationOptionsExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoSourceConfigurationOptionsExtension2">
		<xs:sequence>
			<xs:element name="SceneOrientationMode" type="tt:SceneOrientationMode" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Scene orientation modes supported by the device for this configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RotateOptions">
		<xs:sequence>
			<xs:element name="Mode" type="tt:RotateMode" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Supported options of Rotate mode parameter.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DegreeList" type="tt:IntItems" minOccurs="0">
				<xs:annotation>
					<xs:documentation>List of supported degree value for rotation.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:RotateOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Reboot" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Signals if a device requires a reboot after changing the rotation.
				If a device can handle rotation changes without rebooting this value shall be set to false.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RotateOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--    Scene Orientation    -->
	<!--===============================-->
	<xs:simpleType name="SceneOrientationMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="MANUAL" />
			<xs:enumeration value="AUTO" />
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="SceneOrientationOption">
		<xs:restriction base="xs:string">
			<xs:annotation>
				<xs:documentation>
					Defines the acceptable values for the Orientation element of the SceneOrientation type
				</xs:documentation>
			</xs:annotation>
			<xs:enumeration value="Below" />
			<xs:enumeration value="Horizon" />
			<xs:enumeration value="Above" />
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="SceneOrientation">
		<xs:sequence>
			<xs:element name="Mode" type="tt:SceneOrientationMode">
				<xs:annotation>
					<xs:documentation>
						Parameter to assign the way the camera determines the scene orientation.
					</xs:documentation>
				</xs:annotation>
			</xs:element>      
			<xs:element name="Orientation" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						Assigned or determined scene orientation based on the Mode. When assigning the Mode to AUTO, this field 
						is optional and will be ignored by the device. When assigning the Mode to MANUAL, this field is required 
						and the device will return an InvalidArgs fault if missing. 
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="ViewModes">
		<xs:annotation>
			<xs:documentation>Source view modes supported by device.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="tt:Fisheye">
				<xs:annotation>
					<xs:documentation>Undewarped viewmode from device supporting fisheye lens.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="tt:360Panorama">
				<xs:annotation>
					<xs:documentation>360 degree panoramic view.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="tt:180Panorama">
				<xs:annotation>
					<xs:documentation>180 degree panoramic view.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="tt:Quad">
				<xs:annotation>
					<xs:documentation>View mode combining four streams in single Quad, eg., applicable for devices supporting four heads.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="tt:Original">
				<xs:annotation>
					<xs:documentation>Unaltered view from the sensor.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="tt:LeftHalf">
				<xs:annotation>
					<xs:documentation>Viewmode combining the left side sensors, applicable for devices supporting multiple sensors.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="tt:RightHalf">
				<xs:annotation>
					<xs:documentation>Viewmode combining the right side sensors, applicable for devices supporting multiple sensors.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="tt:Dewarp">
				<xs:annotation>
					<xs:documentation>Dewarped view mode for device supporting fisheye lens.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<!--   VideoEncoderConfiguration   -->
	<!--===============================-->
	<xs:complexType name="VideoEncoderConfiguration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="Encoding" type="tt:VideoEncoding">
						<xs:annotation>
							<xs:documentation>Used video codec, either Jpeg, H.264 or Mpeg4</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Resolution" type="tt:VideoResolution">
						<xs:annotation>
							<xs:documentation>Configured video resolution</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Quality" type="xs:float">
						<xs:annotation>
							<xs:documentation>Relative value for the video quantizers and the quality of the video. A high value within supported quality range means higher quality</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="RateControl" type="tt:VideoRateControl" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Optional element to configure rate control related parameters.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="MPEG4" type="tt:Mpeg4Configuration" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Optional element to configure Mpeg4 related parameters.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="H264" type="tt:H264Configuration" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Optional element to configure H.264 related parameters.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Multicast" type="tt:MulticastConfiguration">
						<xs:annotation>
							<xs:documentation>Defines the multicast settings that could be used for video streaming.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="SessionTimeout" type="xs:duration">
						<xs:annotation>
							<xs:documentation>The rtsp session timeout for the related video stream</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:attribute name="GuaranteedFrameRate" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>
							A value of true indicates that frame rate is a fixed value rather than an upper limit,
							and that the video encoder shall prioritize frame rate over all other adaptable
							configuration values such as bitrate.  Default is false.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="VideoEncoding">
		<xs:restriction base="xs:string">
			<xs:enumeration value="JPEG"/>
			<xs:enumeration value="MPEG4"/>
			<xs:enumeration value="H264"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="Mpeg4Profile">
		<xs:restriction base="xs:string">
			<xs:enumeration value="SP"/>
			<xs:enumeration value="ASP"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="H264Profile">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Baseline"/>
			<xs:enumeration value="Main"/>
			<xs:enumeration value="Extended"/>
			<xs:enumeration value="High"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="VideoResolution">
		<xs:sequence>
			<xs:element name="Width" type="xs:int">
				<xs:annotation>
					<xs:documentation>Number of the columns of the Video image. If there is a 90-degree rotation, this represents the number of lines of the Video image.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Height" type="xs:int">
				<xs:annotation>
					<xs:documentation>Number of the lines of the Video image. If there is a 90-degree rotation, this represents the number of columns of the Video image.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoRateControl">
		<xs:sequence>
			<xs:element name="FrameRateLimit" type="xs:int">
				<xs:annotation>
					<xs:documentation>Maximum output framerate in fps. If an EncodingInterval is provided the resulting encoded framerate will be reduced by the given factor.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EncodingInterval" type="xs:int">
				<xs:annotation>
					<xs:documentation>Interval at which images are encoded and transmitted. (A value of 1 means that every frame is encoded, a value of 2 means that every 2nd frame is encoded ...)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BitrateLimit" type="xs:int">
				<xs:annotation>
					<xs:documentation>the maximum output bitrate in kbps</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Mpeg4Configuration">
		<xs:sequence>
			<xs:element name="GovLength" type="xs:int">
				<xs:annotation>
					<xs:documentation>Determines the interval in which the I-Frames will be coded. An entry of 1 indicates I-Frames are continuously generated. An entry of 2 indicates that every 2nd image is an I-Frame, and 3 only every 3rd frame, etc. The frames in between are coded as P or B Frames.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Mpeg4Profile" type="tt:Mpeg4Profile">
				<xs:annotation>
					<xs:documentation>the Mpeg4 profile, either simple profile (SP) or advanced simple profile (ASP)</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="H264Configuration">
		<xs:sequence>
			<xs:element name="GovLength" type="xs:int">
				<xs:annotation>
					<xs:documentation>Group of Video frames length. Determines typically the interval in which the I-Frames will be coded. An entry of 1 indicates I-Frames are continuously generated. An entry of 2 indicates that every 2nd image is an I-Frame, and 3 only every 3rd frame, etc. The frames in between are coded as P or B Frames.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="H264Profile" type="tt:H264Profile">
				<xs:annotation>
					<xs:documentation>the H.264 profile, either baseline, main, extended or high</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoEncoderConfigurationOptions">
		<xs:sequence>
			<xs:element name="QualityRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Range of the quality values. A high value means higher quality.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="JPEG" type="tt:JpegOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional JPEG encoder settings ranges (See also Extension element).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MPEG4" type="tt:Mpeg4Options" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional MPEG-4 encoder settings ranges (See also Extension element).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="H264" type="tt:H264Options" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional H.264 encoder settings ranges (See also Extension element).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:VideoEncoderOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="GuaranteedFrameRateSupported" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>
					Indicates the support for the GuaranteedFrameRate attribute on the VideoEncoderConfiguration element.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoEncoderOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="JPEG" type="tt:JpegOptions2" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional JPEG encoder settings ranges.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MPEG4" type="tt:Mpeg4Options2" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional MPEG-4 encoder settings ranges.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="H264" type="tt:H264Options2" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional H.264 encoder settings ranges.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:VideoEncoderOptionsExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoEncoderOptionsExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="JpegOptions">
		<xs:sequence>
			<xs:element name="ResolutionsAvailable" type="tt:VideoResolution" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported image sizes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FrameRateRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported frame rate in fps (frames per second).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EncodingIntervalRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported encoding interval range. The encoding interval corresponds to the number of frames devided by the encoded frames. An encoding interval value of "1" means that all frames are encoded.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="JpegOptions2">
		<xs:complexContent>
			<xs:extension base="tt:JpegOptions">
				<xs:sequence>
					<xs:element name="BitrateRange" type="tt:IntRange">
						<xs:annotation>
							<xs:documentation>Supported range of encoded bitrate in kbps.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Mpeg4Options">
		<xs:sequence>
			<xs:element name="ResolutionsAvailable" type="tt:VideoResolution" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported image sizes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="GovLengthRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported group of Video frames length. This value typically corresponds to the I-Frame distance.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FrameRateRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported frame rate in fps (frames per second).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EncodingIntervalRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported encoding interval range. The encoding interval corresponds to the number of frames devided by the encoded frames. An encoding interval value of "1" means that all frames are encoded.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Mpeg4ProfilesSupported" type="tt:Mpeg4Profile" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported MPEG-4 profiles.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Mpeg4Options2">
		<xs:complexContent>
			<xs:extension base="tt:Mpeg4Options">
				<xs:sequence>
					<xs:element name="BitrateRange" type="tt:IntRange">
						<xs:annotation>
							<xs:documentation>Supported range of encoded bitrate in kbps.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="H264Options">
		<xs:sequence>
			<xs:element name="ResolutionsAvailable" type="tt:VideoResolution" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported image sizes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="GovLengthRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported group of Video frames length. This value typically corresponds to the I-Frame distance.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FrameRateRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported frame rate in fps (frames per second).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EncodingIntervalRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported encoding interval range. The encoding interval corresponds to the number of frames devided by the encoded frames. An encoding interval value of "1" means that all frames are encoded.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="H264ProfilesSupported" type="tt:H264Profile" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported H.264 profiles.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="H264Options2">
		<xs:complexContent>
			<xs:extension base="tt:H264Options">
				<xs:sequence>
					<xs:element name="BitrateRange" type="tt:IntRange">
						<xs:annotation>
							<xs:documentation>Supported range of encoded bitrate in kbps.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<!--   VideoEncoder2Configuration   -->
	<!--===============================-->
	<xs:simpleType name="VideoEncodingMimeNames">
		<xs:annotation>
			<xs:documentation>Video Media Subtypes as referenced by IANA (without the leading "video/" Video Media Type).  See also <a href="https://www.iana.org/assignments/media-types/media-types.xhtml#video"> IANA Media Types</a>.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="JPEG"/>
			<xs:enumeration value="MPV4-ES"/>			<!-- MPV4-ES actually references MP4V-ES.  For backward compatibility, it remains misspelled. -->
			<xs:enumeration value="H264"/>
			<xs:enumeration value="H265"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="VideoEncodingProfiles">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Simple"/>			<!-- MPEG4 SP -->
			<xs:enumeration value="AdvancedSimple"/>	<!-- MPEG4 ASP -->
			<xs:enumeration value="Baseline"/>			<!-- H264 Baseline -->
			<xs:enumeration value="Main"/>				<!-- H264 Main, H.265 Main -->
			<xs:enumeration value="Main10"/>			<!-- H265 Main 10 -->
			<xs:enumeration value="Extended"/>			<!-- H264 Extended -->
			<xs:enumeration value="High"/>				<!-- H264 High -->
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="VideoEncoder2Configuration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="Encoding" type="xs:string">
						<xs:annotation>
							<xs:documentation>Video Media Subtype for the video format. For definitions see tt:VideoEncodingMimeNames and <a href="https://www.iana.org/assignments/media-types/media-types.xhtml#video"> IANA Media Types</a>.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Resolution" type="tt:VideoResolution2">
						<xs:annotation>
							<xs:documentation>Configured video resolution</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="RateControl" type="tt:VideoRateControl2" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Optional element to configure rate control related parameters.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Multicast" type="tt:MulticastConfiguration" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Defines the multicast settings that could be used for video streaming.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Quality" type="xs:float">
						<xs:annotation>
							<xs:documentation>Relative value for the video quantizers and the quality of the video. A high value within supported quality range means higher quality</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
				</xs:sequence>
				<xs:attribute name="GovLength" type="xs:int">
					<xs:annotation>
						<xs:documentation>Group of Video frames length. Determines typically the interval in which the I-Frames will be coded. An entry of 1 indicates I-Frames are continuously generated. An entry of 2 indicates that every 2nd image is an I-Frame, and 3 only every 3rd frame, etc. The frames in between are coded as P or B Frames.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="AnchorFrameDistance" type="xs:int">
					<xs:annotation>
						<xs:documentation>Distance between anchor frames of type I-Frame and P-Frame. '1' indicates no B-Frames, '2' indicates that every 2nd frame is encoded as B-Frame, '3' indicates a structure like IBBPBBP..., etc.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Profile" type="xs:string">
					<xs:annotation>
						<xs:documentation>The encoder profile as defined in tt:VideoEncodingProfiles.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="GuaranteedFrameRate" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>
							A value of true indicates that frame rate is a fixed value rather than an upper limit,
							and that the video encoder shall prioritize frame rate over all other adaptable
							configuration values such as bitrate.  Default is false.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="Signed" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Indicates if this stream will be signed according to the Media Signing Specification.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoResolution2">
		<xs:sequence>
			<xs:element name="Width" type="xs:int">
				<xs:annotation>
					<xs:documentation>Number of the columns of the Video image. If there is a 90-degree rotation, this represents the number of lines of the Video image.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Height" type="xs:int">
				<xs:annotation>
					<xs:documentation>Number of the lines of the Video image. If there is a 90-degree rotation, this represents the number of columns of the Video image.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoRateControl2">
		<xs:sequence>
			<xs:element name="FrameRateLimit" type="xs:float">
				<xs:annotation>
					<xs:documentation>Desired frame rate in fps. The actual rate may be lower due to e.g. performance limitations.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BitrateLimit" type="xs:int">
				<xs:annotation>
					<xs:documentation>the maximum output bitrate in kbps</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:attribute name="ConstantBitRate" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Enforce constant bitrate.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoEncoder2ConfigurationOptions">
		<xs:sequence>
			<xs:element name="Encoding" type="xs:string">
				<xs:annotation>
					<xs:documentation>Video Media Subtype for the video format. For definitions see tt:VideoEncodingMimeNames and <a href="https://www.iana.org/assignments/media-types/media-types.xhtml#video"> IANA Media Types</a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="QualityRange" type="tt:FloatRange">
				<xs:annotation>
					<xs:documentation>Range of the quality values. A high value means higher quality.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ResolutionsAvailable" type="tt:VideoResolution2" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported image sizes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BitrateRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported range of encoded bitrate in kbps.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:attribute name="GovLengthRange" type="tt:IntList">
			<xs:annotation>
				<xs:documentation>Exactly two values, which define the Lower and Upper bounds for the supported group of Video frames length. These values typically correspond to the I-Frame distance.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MaxAnchorFrameDistance" type="xs:int">
			<xs:annotation>
				<xs:documentation>Signals support for B-Frames. Upper bound for the supported anchor frame distance (must be larger than one).</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="FrameRatesSupported" type="tt:FloatList">
			<xs:annotation>
				<xs:documentation>List of supported target frame rates in fps (frames per second). The list shall be sorted with highest values first.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ProfilesSupported" type="tt:StringAttrList">
			<xs:annotation>
				<xs:documentation>List of supported encoder profiles as defined in tt::VideoEncodingProfiles.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="ConstantBitRateSupported" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Signal whether enforcing constant bitrate is supported.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="GuaranteedFrameRateSupported" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>
					Indicates the support for the GuaranteedFrameRate attribute on the VideoEncoder2Configuration element.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--    AudioSourceConfiguration   -->
	<!--===============================-->
	<xs:complexType name="AudioSourceConfiguration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="SourceToken" type="tt:ReferenceToken">
						<xs:annotation>
							<xs:documentation>Token of the Audio Source the configuration applies to</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AudioSourceConfigurationOptions">
		<xs:sequence>
			<xs:element name="InputTokensAvailable" type="tt:ReferenceToken" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Tokens of the audio source the configuration can be used for.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:AudioSourceOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AudioSourceOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--   AudioEncoderConfiguration   -->
	<!--===============================-->
	<xs:complexType name="AudioEncoderConfiguration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="Encoding" type="tt:AudioEncoding">
						<xs:annotation>
							<xs:documentation>Audio codec used for encoding the audio input (either G.711, G.726 or AAC)</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Bitrate" type="xs:int">
						<xs:annotation>
							<xs:documentation>The output bitrate in kbps.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="SampleRate" type="xs:int">
						<xs:annotation>
							<xs:documentation>The output sample rate in kHz.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Multicast" type="tt:MulticastConfiguration">
						<xs:annotation>
							<xs:documentation>Defines the multicast settings that could be used for video streaming.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="SessionTimeout" type="xs:duration">
						<xs:annotation>
							<xs:documentation>The rtsp session timeout for the related audio stream</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="AudioEncoding">
		<xs:restriction base="xs:string">
			<xs:enumeration value="G711"/>
			<xs:enumeration value="G726"/>
			<xs:enumeration value="AAC"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="AudioEncoderConfigurationOptions">
		<xs:sequence>
			<xs:element name="Options" type="tt:AudioEncoderConfigurationOption" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>list of supported AudioEncoderConfigurations</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AudioEncoderConfigurationOption">
		<xs:sequence>
			<xs:element name="Encoding" type="tt:AudioEncoding">
				<xs:annotation>
					<xs:documentation>The enoding used for audio data (either G.711, G.726 or AAC)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BitrateList" type="tt:IntItems">
				<xs:annotation>
					<xs:documentation>List of supported bitrates in kbps for the specified Encoding</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SampleRateList" type="tt:IntItems">
				<xs:annotation>
					<xs:documentation>List of supported Sample Rates in kHz for the specified Encoding</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--   AudioEncoder2Configuration   -->
	<!--===============================-->
	<xs:simpleType name="AudioEncodingMimeNames">
		<xs:annotation>
			<xs:documentation>Audio Media Subtypes as referenced by IANA (without the leading "audio/" Audio Media Type and except for the audio types defined in the restriction).  See also <a href="https://www.iana.org/assignments/media-types/media-types.xhtml#audio"> IANA Media Types</a>.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="PCMU"/>		<!-- G.711 uLaw -->
			<xs:enumeration value="G726">
			<xs:annotation><xs:documentation>AudioEncodingMimeName G726 is used to represent G726-16,G726-24,G726-32 and G726-40 defined in the IANA Media Types</xs:documentation></xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MP4A-LATM"/>		<!-- AAC -->
			<xs:enumeration value="mpeg4-generic"/>
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="AudioEncoder2Configuration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="Encoding" type="xs:string">
						<xs:annotation>
							<xs:documentation>Audio Media Subtype for the audio format. For definitions see tt:AudioEncodingMimeNames and <a href="https://www.iana.org/assignments/media-types/media-types.xhtml#audio"> IANA Media Types</a>.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Multicast" type="tt:MulticastConfiguration" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Optional multicast configuration of the audio stream.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Bitrate" type="xs:int">
						<xs:annotation>
							<xs:documentation>The output bitrate in kbps.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="SampleRate" type="xs:int">
						<xs:annotation>
							<xs:documentation>The output sample rate in kHz.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<!-- Options used for both Audio encoder and decoder -->
	<xs:complexType name="AudioEncoder2ConfigurationOptions">
		<xs:sequence>
			<xs:element name="Encoding" type="xs:string">
				<xs:annotation>
					<xs:documentation>Audio Media Subtype for the audio format. For definitions see tt:AudioEncodingMimeNames and <a href="https://www.iana.org/assignments/media-types/media-types.xhtml#audio"> IANA Media Types</a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BitrateList" type="tt:IntItems">
				<xs:annotation>
					<xs:documentation>List of supported bitrates in kbps for the specified Encoding</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SampleRateList" type="tt:IntItems">
				<xs:annotation>
					<xs:documentation>List of supported Sample Rates in kHz for the specified Encoding</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--  VideoAnalyticsConfiguration  -->
	<!--===============================-->
	<xs:complexType name="VideoAnalyticsConfiguration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="AnalyticsEngineConfiguration" type="tt:AnalyticsEngineConfiguration"/>
					<xs:element name="RuleEngineConfiguration" type="tt:RuleEngineConfiguration"/>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<!--    MetadataConfiguration      -->
	<!--===============================-->
	<xs:complexType name="MetadataConfiguration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="PTZStatus" type="tt:PTZFilter" minOccurs="0">
						<xs:annotation>
							<xs:documentation>optional element to configure which PTZ related data is to include in the metadata stream</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Events" type="tt:EventSubscription" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Optional element to configure the streaming of events. A client might be interested in receiving all, 
								none or some of the events produced by the device:<ul>
									<li>To get all events: Include the Events element but do not include a filter.</li>
									<li>To get no events: Do not include the Events element.</li>
									<li>To get only some events: Include the Events element and include a filter in the element.</li>
								</ul>
							</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Analytics" type="xs:boolean" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Defines whether the streamed metadata will include metadata from the analytics engines (video, cell motion, audio etc.)</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Multicast" type="tt:MulticastConfiguration">
						<xs:annotation>
							<xs:documentation>Defines the multicast settings that could be used for video streaming.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="SessionTimeout" type="xs:duration">
						<xs:annotation>
							<xs:documentation>The rtsp session timeout for the related audio stream (when using Media2 Service, this value is deprecated and ignored)</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
					<xs:element name="AnalyticsEngineConfiguration" type="tt:AnalyticsEngineConfiguration" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Indication which AnalyticsModules shall output metadata.
							Note that the streaming behavior is undefined if the list includes items that are not part of the associated AnalyticsConfiguration.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extension" type="tt:MetadataConfigurationExtension" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="CompressionType" type="xs:string">
					<xs:annotation>
						<xs:documentation>Optional parameter to configure compression type of Metadata payload. Use values from enumeration MetadataCompressionType.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="GeoLocation" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Optional parameter to configure if the metadata stream shall contain the Geo Location coordinates of each target.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="ShapePolygon" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Optional parameter to configure if the generated metadata stream should contain shape information as polygon.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MetadataConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZFilter">
		<xs:sequence>
			<xs:element name="Status" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>True if the metadata stream shall contain the PTZ status (IDLE, MOVING or UNKNOWN)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Position" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>True if the metadata stream shall contain the PTZ position</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FieldOfView" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>True if the metadata stream shall contain the field-of-view information</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="EventSubscription">
		<xs:annotation>
			<xs:documentation>Subcription handling in the same way as base notification subscription.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Filter" type="wsnt:FilterType" minOccurs="0"/>
			<xs:element name="SubscriptionPolicy" minOccurs="0">
				<xs:complexType>
					<xs:sequence>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MetadataConfigurationOptions">
		<xs:sequence>
			<xs:element name="PTZStatusFilterOptions" type="tt:PTZStatusFilterOptions"/>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name ="Extension" type="tt:MetadataConfigurationOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="GeoLocation" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>True if the device is able to stream the Geo Located positions of each target.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MaxContentFilterSize" type="xs:int">
			<xs:annotation>
				<xs:documentation>A device signalling support for content filtering shall support expressions with the provided expression size.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MetadataConfigurationOptionsExtension">
		<xs:sequence>
			<xs:element name="CompressionType" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported metadata compression type. Its options shall be chosen from tt:MetadataCompressionType.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:MetadataConfigurationOptionsExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MetadataConfigurationOptionsExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="MetadataCompressionType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="None"/>
			<xs:enumeration value="GZIP"/>
			<xs:enumeration value="EXI"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="PTZStatusFilterOptions">
		<xs:sequence>
			<xs:element name="PanTiltStatusSupported" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>True if the device is able to stream pan or tilt status information.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ZoomStatusSupported" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>True if the device is able to stream zoom status inforamtion.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="PanTiltPositionSupported" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>True if the device is able to stream the pan or tilt position.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ZoomPositionSupported" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>True if the device is able to stream zoom position information.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZStatusFilterOptionsExtension" minOccurs="0"/>
			<xs:element name="FieldOfViewSupported" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>True if the device is able to stream the field-of-view information.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZStatusFilterOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--          VideoOutput            -->
	<!--===============================-->
	<xs:complexType name="VideoOutput">
		<xs:annotation>
			<xs:documentation>Representation of a physical video outputs.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="tt:DeviceEntity">
				<xs:sequence>
					<xs:element name="Layout" type="tt:Layout"/>
					<xs:element name="Resolution" type="tt:VideoResolution" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Resolution of the display in Pixel.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="RefreshRate" type="xs:float" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Refresh rate of the display in Hertz.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="AspectRatio" type="xs:float" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Aspect ratio of the display as physical extent of width divided by height.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extension" type="tt:VideoOutputExtension" minOccurs="0"/>
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoOutputExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--          VideoOutputConfiguration            -->
	<!--===============================-->
	<xs:complexType name="VideoOutputConfiguration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="OutputToken" type="tt:ReferenceToken">
						<xs:annotation>
							<xs:documentation>Token of the Video Output the configuration applies to</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<!--          VideoOutputConfigurationOptions            -->
	<!--===============================-->
	<xs:complexType name="VideoOutputConfigurationOptions">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--          VideoDecoderConfigurationOptions            -->
	<!--===============================-->
	<xs:complexType name="VideoDecoderConfigurationOptions">
		<xs:sequence>
			<xs:element name="JpegDecOptions" type="tt:JpegDecOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the device is able to decode Jpeg streams this element describes the supported codecs and configurations</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="H264DecOptions" type="tt:H264DecOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the device is able to decode H.264 streams this element describes the supported codecs and configurations</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Mpeg4DecOptions" type="tt:Mpeg4DecOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the device is able to decode Mpeg4 streams this element describes the supported codecs and configurations</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:VideoDecoderConfigurationOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="H264DecOptions">
		<xs:sequence>
			<xs:element name="ResolutionsAvailable" type="tt:VideoResolution" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported H.264 Video Resolutions</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SupportedH264Profiles" type="tt:H264Profile" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported H264 Profiles (either baseline, main, extended or high) </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SupportedInputBitrate" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported H.264 bitrate range in kbps</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SupportedFrameRate" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported H.264 framerate range in fps</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="JpegDecOptions">
		<xs:sequence>
			<xs:element name="ResolutionsAvailable" type="tt:VideoResolution" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported Jpeg Video Resolutions</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SupportedInputBitrate" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported Jpeg bitrate range in kbps</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SupportedFrameRate" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported Jpeg framerate range in fps</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Mpeg4DecOptions">
		<xs:sequence>
			<xs:element name="ResolutionsAvailable" type="tt:VideoResolution" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported Mpeg4 Video Resolutions</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SupportedMpeg4Profiles" type="tt:Mpeg4Profile" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported Mpeg4 Profiles (either SP or ASP) </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SupportedInputBitrate" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported Mpeg4 bitrate range in kbps</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SupportedFrameRate" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Supported Mpeg4 framerate range in fps</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoDecoderConfigurationOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--          AudioOutputs            -->
	<!--===============================-->
	<xs:complexType name="AudioOutput">
		<xs:annotation>
			<xs:documentation>Representation of a physical audio outputs.</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="tt:DeviceEntity">
				<xs:sequence>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<!--          AudioOutputConfiguration            -->
	<!--===============================-->
	<xs:complexType name="AudioOutputConfiguration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="OutputToken" type="tt:ReferenceToken">
						<xs:annotation>
							<xs:documentation>Token of the phsycial Audio output.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="SendPrimacy" type="xs:anyURI" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
						An audio channel MAY support different types of audio transmission. While for full duplex
						operation no special handling is required, in half duplex operation the transmission direction
						needs to be switched.
						The optional SendPrimacy parameter inside the AudioOutputConfiguration indicates which
						direction is currently active. An NVC can switch between different modes by setting the
						AudioOutputConfiguration.<br/>
						The following modes for the Send-Primacy are defined:<ul>
									<li>www.onvif.org/ver20/HalfDuplex/Server
						The server is allowed to send audio data to the client. The client shall not send
						audio data via the backchannel to the NVT in this mode.</li>
									<li>www.onvif.org/ver20/HalfDuplex/Client
						The client is allowed to send audio data via the backchannel to the server. The
						NVT shall not send audio data to the client in this mode.</li>
									<li>www.onvif.org/ver20/HalfDuplex/Auto
							It is up to the device how to deal with sending and receiving audio data.</li>
								</ul>
						Acoustic echo cancellation is out of ONVIF scope.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="OutputLevel" type="xs:int">
						<xs:annotation>
							<xs:documentation>Volume setting of the output. The applicable range is defined via the option AudioOutputOptions.OutputLevelRange.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<!--          AudioOutputConfigurationOptions            -->
	<!--===============================-->
	<xs:complexType name="AudioOutputConfigurationOptions">
		<xs:sequence>
			<xs:element name="OutputTokensAvailable" type="tt:ReferenceToken" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Tokens of the physical Audio outputs (typically one).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SendPrimacyOptions" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
				An <b>audio</b> channel MAY support different types of audio transmission. While for full duplex
				operation no special handling is required, in half duplex operation the transmission direction
				needs to be switched.
				The optional SendPrimacy parameter inside the AudioOutputConfiguration indicates which
				direction is currently active. An NVC can switch between different modes by setting the
				AudioOutputConfiguration.<br/>
				The following modes for the Send-Primacy are defined:<ul>
							<li>www.onvif.org/ver20/HalfDuplex/Server
						The server is allowed to send audio data to the client. The client shall not send
						audio data via the backchannel to the NVT in this mode.</li>
							<li>www.onvif.org/ver20/HalfDuplex/Client
						The client is allowed to send audio data via the backchannel to the server. The
						NVT shall not send audio data to the client in this mode.</li>
							<li>www.onvif.org/ver20/HalfDuplex/Auto
						It is up to the device how to deal with sending and receiving audio data.</li>
						</ul>
				Acoustic echo cancellation is out of ONVIF scope.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OutputLevelRange" type="tt:IntRange">
				<xs:annotation>
					<xs:documentation>Minimum and maximum level range supported for this Output.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--          AudioDecoderConfiguration           -->
	<!--===============================-->
	<xs:complexType name="AudioDecoderConfiguration">
		<xs:annotation>
			<xs:documentation>The Audio Decoder Configuration does not contain any that parameter to configure the
decoding .A decoder shall decode every data it receives (according to its capabilities).</xs:documentation>
		</xs:annotation>
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<!--          AudioDecoderConfigurationOptions           -->
	<!--===============================-->
	<xs:complexType name="AudioDecoderConfigurationOptions">
		<xs:sequence>
			<xs:element name="AACDecOptions" type="tt:AACDecOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the device is able to decode AAC encoded audio this section describes the supported configurations</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="G711DecOptions" type="tt:G711DecOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the device is able to decode G711 encoded audio this section describes the supported configurations</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="G726DecOptions" type="tt:G726DecOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the device is able to decode G726 encoded audio this section describes the supported configurations</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:AudioDecoderConfigurationOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="G711DecOptions">
		<xs:sequence>
			<xs:element name="Bitrate" type="tt:IntItems">
				<xs:annotation>
					<xs:documentation>List of supported bitrates in kbps</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SampleRateRange" type="tt:IntItems">
				<xs:annotation>
					<xs:documentation>List of supported sample rates in kHz</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AACDecOptions">
		<xs:sequence>
			<xs:element name="Bitrate" type="tt:IntItems">
				<xs:annotation>
					<xs:documentation>List of supported bitrates in kbps</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SampleRateRange" type="tt:IntItems">
				<xs:annotation>
					<xs:documentation>List of supported sample rates in kHz</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="G726DecOptions">
		<xs:sequence>
			<xs:element name="Bitrate" type="tt:IntItems">
				<xs:annotation>
					<xs:documentation>List of supported bitrates in kbps</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SampleRateRange" type="tt:IntItems">
				<xs:annotation>
					<xs:documentation>List of supported sample rates in kHz</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AudioDecoderConfigurationOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--          Streaming            -->
	<!--===============================-->
	<xs:complexType name="MulticastConfiguration">
		<xs:sequence>
			<xs:element name="Address" type="tt:IPAddress">
				<xs:annotation>
					<xs:documentation>The multicast address (if this address is set to 0 no multicast streaming is enaled)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Port" type="xs:int">
				<xs:annotation>
					<xs:documentation>The RTP mutlicast destination port. A device may support RTCP. In this case the port value shall be even to allow the corresponding RTCP stream to be mapped to the next higher (odd) destination port number as defined in the RTSP specification.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TTL" type="xs:int">
				<xs:annotation>
					<xs:documentation>In case of IPv6 the TTL value is assumed as the hop limit. Note that for IPV6 and administratively scoped IPv4 multicast the primary use for hop limit / TTL is to prevent packets from (endlessly) circulating and not limiting scope. In these cases the address contains the scope.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AutoStart" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Read only property signalling that streaming is persistant. Use the methods StartMulticastStreaming and StopMulticastStreaming to switch its state.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="StreamSetup">
		<xs:sequence>
			<xs:element name="Stream" type="tt:StreamType">
				<xs:annotation>
					<xs:documentation>Defines if a multicast or unicast stream is requested</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Transport" type="tt:Transport"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="StreamType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="RTP-Unicast"/>
			<xs:enumeration value="RTP-Multicast"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="Transport">
		<xs:sequence>
			<xs:element name="Protocol" type="tt:TransportProtocol">
				<xs:annotation>
					<xs:documentation>Defines the network protocol for streaming, either UDP=RTP/UDP, RTSP=RTP/RTSP/TCP or HTTP=RTP/RTSP/HTTP/TCP </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Tunnel" type="tt:Transport" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional element to describe further tunnel options. This element is normally not needed </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="TransportProtocol">
		<xs:restriction base="xs:string">
			<xs:enumeration value="UDP"/>
			<xs:enumeration value="TCP">
				<xs:annotation>
					<xs:documentation>This value is deprecated.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RTSP"/>
			<xs:enumeration value="HTTP"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="MediaUri">
		<xs:sequence>
			<xs:element name="Uri" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>Stable Uri to be used for requesting the media stream</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="InvalidAfterConnect" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates if the Uri is only valid until the connection is established. The value shall be set to "false".</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="InvalidAfterReboot" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates if the Uri is invalid after a reboot of the device. The value shall be set to "false".</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Timeout" type="xs:duration">
				<xs:annotation>
					<xs:documentation>Duration how long the Uri is valid. This parameter shall be set to PT0S to indicate that this stream URI is indefinitely valid even if the profile changes</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--   End, Media Related Types    -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--    Discovery Related Types    -->
	<!--===============================-->
	<xs:simpleType name="ScopeDefinition">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Fixed"/>
			<xs:enumeration value="Configurable"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="Scope">
		<xs:sequence>
			<xs:element name="ScopeDef" type="tt:ScopeDefinition">
				<xs:annotation>
					<xs:documentation>Indicates if the scope is fixed or configurable.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ScopeItem" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>Scope item URI.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="DiscoveryMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Discoverable"/>
			<xs:enumeration value="NonDiscoverable"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<!-- End, Discovery Related Types  -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--     Network Related Types     -->
	<!--===============================-->
	<xs:complexType name="NetworkInterface">
		<xs:complexContent>
			<xs:extension base="tt:DeviceEntity">
				<xs:sequence>
					<xs:element name="Enabled" type="xs:boolean">
						<xs:annotation>
							<xs:documentation>Indicates whether or not an interface is enabled.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Info" type="tt:NetworkInterfaceInfo" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Network interface information</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Link" type="tt:NetworkInterfaceLink" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Link configuration.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="IPv4" type="tt:IPv4NetworkInterface" minOccurs="0">
						<xs:annotation>
							<xs:documentation>IPv4 network interface configuration.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="IPv6" type="tt:IPv6NetworkInterface" minOccurs="0">
						<xs:annotation>
							<xs:documentation>IPv6 network interface configuration.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extension" type="tt:NetworkInterfaceExtension" minOccurs="0"/>
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkInterfaceExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="InterfaceType" type="tt:IANA-IfTypes"/>
			<xs:element name="Dot3" type="tt:Dot3Configuration" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Extension point prepared for future 802.3 configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Dot11" type="tt:Dot11Configuration" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:NetworkInterfaceExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="NetworkInterfaceConfigPriority">
		<xs:restriction base="xs:integer">
			<xs:minInclusive value="0"/>
			<xs:maxInclusive value="31"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="Dot3Configuration">
		<xs:sequence>
			<!-- Placeholder for 802.3 configuration -->
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkInterfaceExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkInterfaceLink">
		<xs:sequence>
			<xs:element name="AdminSettings" type="tt:NetworkInterfaceConnectionSetting">
				<xs:annotation>
					<xs:documentation>Configured link settings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OperSettings" type="tt:NetworkInterfaceConnectionSetting">
				<xs:annotation>
					<xs:documentation>Current active link settings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="InterfaceType" type="tt:IANA-IfTypes">
				<xs:annotation>
					<xs:documentation>Integer indicating interface type, for example: 6 is ethernet.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkInterfaceConnectionSetting">
		<xs:sequence>
			<xs:element name="AutoNegotiation" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Auto negotiation on/off.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Speed" type="xs:int">
				<xs:annotation>
					<xs:documentation>Speed.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Duplex" type="tt:Duplex">
				<xs:annotation>
					<xs:documentation>Duplex type, Half or Full.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="Duplex">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Full"/>
			<xs:enumeration value="Half"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="IANA-IfTypes">
		<xs:restriction base="xs:int">
			<xs:annotation>
				<xs:documentation>
				For valid numbers, please refer to http://www.iana.org/assignments/ianaiftype-mib.
				</xs:documentation>
			</xs:annotation>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="NetworkInterfaceInfo">
		<xs:sequence>
			<xs:element name="Name" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Network interface name, for example eth0.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="HwAddress" type="tt:HwAddress">
				<xs:annotation>
					<xs:documentation>Network interface MAC address.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MTU" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Maximum transmission unit.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IPv6NetworkInterface">
		<xs:sequence>
			<xs:element name="Enabled" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not IPv6 is enabled.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Config" type="tt:IPv6Configuration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>IPv6 configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IPv4NetworkInterface">
		<xs:sequence>
			<xs:element name="Enabled" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not IPv4 is enabled.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Config" type="tt:IPv4Configuration">
				<xs:annotation>
					<xs:documentation>IPv4 configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IPv4Configuration">
		<xs:sequence>
			<xs:element name="Manual" type="tt:PrefixedIPv4Address" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of manually added IPv4 addresses.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="LinkLocal" type="tt:PrefixedIPv4Address" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Link local address.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FromDHCP" type="tt:PrefixedIPv4Address" minOccurs="0">
				<xs:annotation>
					<xs:documentation>IPv4 address configured by using DHCP.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DHCP" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not DHCP is used.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IPv6Configuration">
		<xs:sequence>
			<xs:element name="AcceptRouterAdvert" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether router advertisment is used.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DHCP" type="tt:IPv6DHCPConfiguration">
				<xs:annotation>
					<xs:documentation>DHCP configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Manual" type="tt:PrefixedIPv6Address" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of manually entered IPv6 addresses.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="LinkLocal" type="tt:PrefixedIPv6Address" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of link local IPv6 addresses.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FromDHCP" type="tt:PrefixedIPv6Address" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of IPv6 addresses configured by using DHCP.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FromRA" type="tt:PrefixedIPv6Address" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of IPv6 addresses configured by using router advertisment.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:IPv6ConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IPv6ConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="IPv6DHCPConfiguration">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Auto"/>
			<xs:enumeration value="Stateful"/>
			<xs:enumeration value="Stateless"/>
			<xs:enumeration value="Off"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="NetworkProtocol">
		<xs:sequence>
			<xs:element name="Name" type="tt:NetworkProtocolType">
				<xs:annotation>
					<xs:documentation>Network protocol type string.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates if the protocol is enabled or not.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Port" type="xs:int" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>The port that is used by the protocol.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:NetworkProtocolExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkProtocolExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="NetworkProtocolType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="HTTP"/>
			<xs:enumeration value="HTTPS"/>
			<xs:enumeration value="RTSP"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="NetworkHostType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="IPv4"/>
			<xs:enumeration value="IPv6"/>
			<xs:enumeration value="DNS"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="NetworkHost">
		<xs:sequence>
			<xs:element name="Type" type="tt:NetworkHostType">
				<xs:annotation>
					<xs:documentation>Network host type: IPv4, IPv6 or DNS.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IPv4Address" type="tt:IPv4Address" minOccurs="0">
				<xs:annotation>
					<xs:documentation>IPv4 address.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IPv6Address" type="tt:IPv6Address" minOccurs="0">
				<xs:annotation>
					<xs:documentation>IPv6 address.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DNSname" type="tt:DNSName" minOccurs="0">
				<xs:annotation>
					<xs:documentation>DNS name.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:NetworkHostExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkHostExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IPAddress">
		<xs:sequence>
			<xs:element name="Type" type="tt:IPType">
				<xs:annotation>
					<xs:documentation>Indicates if the address is an IPv4 or IPv6 address.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IPv4Address" type="tt:IPv4Address" minOccurs="0">
				<xs:annotation>
					<xs:documentation>IPv4 address.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IPv6Address" type="tt:IPv6Address" minOccurs="0">
				<xs:annotation>
					<xs:documentation>IPv6 address</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PrefixedIPv4Address">
		<xs:sequence>
			<xs:element name="Address" type="tt:IPv4Address">
				<xs:annotation>
					<xs:documentation>IPv4 address</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PrefixLength" type="xs:int">
				<xs:annotation>
					<xs:documentation>Prefix/submask length</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="IPv4Address">
		<xs:restriction base="xs:token"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="PrefixedIPv6Address">
		<xs:sequence>
			<xs:element name="Address" type="tt:IPv6Address">
				<xs:annotation>
					<xs:documentation>IPv6 address</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PrefixLength" type="xs:int">
				<xs:annotation>
					<xs:documentation>Prefix/submask length</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="IPv6Address">
		<xs:restriction base="xs:token"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="HwAddress">
		<xs:restriction base="xs:token"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="IPType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="IPv4"/>
			<xs:enumeration value="IPv6"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="DNSName">
		<xs:restriction base="xs:token"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="HostnameInformation">
		<xs:sequence>
			<xs:element name="FromDHCP" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether the hostname has been obtained from DHCP or not.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Name" type="xs:token" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates the device hostname or an empty string if no hostname has been assigned.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:HostnameInformationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="HostnameInformationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DNSInformation">
		<xs:sequence>
			<xs:element name="FromDHCP" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not DNS information is retrieved from DHCP.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SearchDomain" type="xs:token" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Search domain.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DNSFromDHCP" type="tt:IPAddress" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of DNS addresses received from DHCP.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DNSManual" type="tt:IPAddress" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of manually entered DNS addresses.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:DNSInformationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DNSInformationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NTPInformation">
		<xs:sequence>
			<xs:element name="FromDHCP" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates if NTP information is to be retrieved by using DHCP.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="NTPFromDHCP" type="tt:NetworkHost" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of NTP addresses retrieved by using DHCP.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="NTPManual" type="tt:NetworkHost" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of manually entered NTP addresses.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:NTPInformationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NTPInformationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="Domain">
		<xs:restriction base="xs:token"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="IPAddressFilterType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Allow"/>
			<xs:enumeration value="Deny"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="DynamicDNSInformation">
		<xs:sequence>
			<xs:element name="Type" type="tt:DynamicDNSType">
				<xs:annotation>
					<xs:documentation>Dynamic DNS type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Name" type="tt:DNSName" minOccurs="0">
				<xs:annotation>
					<xs:documentation>DNS name.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TTL" type="xs:duration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Time to live.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:DynamicDNSInformationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DynamicDNSInformationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="DynamicDNSType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="NoUpdate"/>
			<xs:enumeration value="ClientUpdates"/>
			<xs:enumeration value="ServerUpdates"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="NetworkInterfaceSetConfiguration">
		<xs:sequence>
			<xs:element name="Enabled" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not an interface is enabled.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Link" type="tt:NetworkInterfaceConnectionSetting" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Link configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MTU" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Maximum transmission unit.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IPv4" type="tt:IPv4NetworkInterfaceSetConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>IPv4 network interface configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IPv6" type="tt:IPv6NetworkInterfaceSetConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>IPv6 network interface configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:NetworkInterfaceSetConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkInterfaceSetConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Dot3" type="tt:Dot3Configuration" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Dot11" type="tt:Dot11Configuration" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:NetworkInterfaceSetConfigurationExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IPv6NetworkInterfaceSetConfiguration">
		<xs:sequence>
			<xs:element name="Enabled" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not IPv6 is enabled.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AcceptRouterAdvert" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether router advertisment is used.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Manual" type="tt:PrefixedIPv6Address" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of manually added IPv6 addresses.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DHCP" type="tt:IPv6DHCPConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>DHCP configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IPv4NetworkInterfaceSetConfiguration">
		<xs:sequence>
			<xs:element name="Enabled" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not IPv4 is enabled.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Manual" type="tt:PrefixedIPv4Address" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of manually added IPv4 addresses.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DHCP" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not DHCP is used.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkGateway">
		<xs:sequence>
			<xs:element name="IPv4Address" type="tt:IPv4Address" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>IPv4 address string.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IPv6Address" type="tt:IPv6Address" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>IPv6 address string.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkZeroConfiguration">
		<xs:sequence>
			<xs:element name="InterfaceToken" type="tt:ReferenceToken">
				<xs:annotation>
					<xs:documentation>Unique identifier of network interface.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Enabled" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether the zero-configuration is enabled or not.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Addresses" type="tt:IPv4Address" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>The zero-configuration IPv4 address(es)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:NetworkZeroConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkZeroConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Additional" type="tt:NetworkZeroConfiguration" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Optional array holding the configuration for the second and possibly further interfaces.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:NetworkZeroConfigurationExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkZeroConfigurationExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IPAddressFilter">
		<xs:sequence>
			<xs:element name="Type" type="tt:IPAddressFilterType"/>
			<xs:element name="IPv4Address" type="tt:PrefixedIPv4Address" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="IPv6Address" type="tt:PrefixedIPv6Address" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:IPAddressFilterExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IPAddressFilterExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Dot11Configuration">
		<xs:sequence>
			<xs:element name="SSID" type="tt:Dot11SSIDType"/>
			<xs:element name="Mode" type="tt:Dot11StationMode"/>
			<xs:element name="Alias" type="tt:Name"/>
			<xs:element name="Priority" type="tt:NetworkInterfaceConfigPriority"/>
			<xs:element name="Security" type="tt:Dot11SecurityConfiguration"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="Dot11SSIDType">
		<xs:restriction base="xs:hexBinary">
			<xs:minLength value="1"/>
			<xs:maxLength value="32"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="Dot11StationMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Ad-hoc"/>
			<xs:enumeration value="Infrastructure"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="Dot11SecurityConfiguration">
		<xs:sequence>
			<xs:element name="Mode" type="tt:Dot11SecurityMode"/>
			<xs:element name="Algorithm" type="tt:Dot11Cipher" minOccurs="0"/>
			<xs:element name="PSK" type="tt:Dot11PSKSet" minOccurs="0"/>
			<xs:element name="Dot1X" type="tt:ReferenceToken" minOccurs="0"/>
			<xs:element name="Extension" type="tt:Dot11SecurityConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Dot11SecurityConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="Dot11SecurityMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="None"/>
			<xs:enumeration value="WEP"/>
			<xs:enumeration value="PSK"/>
			<xs:enumeration value="Dot1X"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="Dot11Cipher">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CCMP"/>
			<xs:enumeration value="TKIP"/>
			<xs:enumeration value="Any"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="Dot11PSK">
		<xs:restriction base="xs:hexBinary">
			<xs:length value="32"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="Dot11PSKPassphrase">
		<xs:restriction base="xs:string">
			<xs:pattern value="[ -~]{8,63}"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="Dot11PSKSet">
		<xs:sequence>
			<xs:element name="Key" type="tt:Dot11PSK" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
					According to IEEE802.11-2007 H.4.1 the RSNA PSK consists of 256 bits, or 64 octets when represented in hex<br/>
					Either Key or Passphrase shall be given, if both are supplied Key shall be used by the device and Passphrase ignored.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Passphrase" type="tt:Dot11PSKPassphrase" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
					According to IEEE802.11-2007 H.4.1 a pass-phrase is a sequence of between 8 and 63 ASCII-encoded characters and
					each character in the pass-phrase must have an encoding in the range of 32 to 126 (decimal),inclusive.<br/>
					If only Passpharse is supplied the Key shall be derived using the algorithm described in IEEE802.11-2007 section H.4
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:Dot11PSKSetExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Dot11PSKSetExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkInterfaceSetConfigurationExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Dot11Capabilities">
		<xs:sequence>
			<xs:element name="TKIP" type="xs:boolean"/>
			<xs:element name="ScanAvailableNetworks" type="xs:boolean"/>
			<xs:element name="MultipleConfiguration" type="xs:boolean"/>
			<xs:element name="AdHocStationMode" type="xs:boolean"/>
			<xs:element name="WEP" type="xs:boolean"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="Dot11SignalStrength">
		<xs:restriction base="xs:string">
			<xs:enumeration value="None"/>
			<xs:enumeration value="Very Bad"/>
			<xs:enumeration value="Bad"/>
			<xs:enumeration value="Good"/>
			<xs:enumeration value="Very Good"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="Dot11Status">
		<xs:sequence>
			<xs:element name="SSID" type="tt:Dot11SSIDType"/>
			<xs:element name="BSSID" type="xs:string" minOccurs="0"/>
			<xs:element name="PairCipher" type="tt:Dot11Cipher" minOccurs="0"/>
			<xs:element name="GroupCipher" type="tt:Dot11Cipher" minOccurs="0"/>
			<xs:element name="SignalStrength" type="tt:Dot11SignalStrength" minOccurs="0"/>
			<xs:element name="ActiveConfigAlias" type="tt:ReferenceToken"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="Dot11AuthAndMangementSuite">
		<xs:restriction base="xs:string">
			<xs:enumeration value="None"/>
			<xs:enumeration value="Dot1X"/>
			<xs:enumeration value="PSK"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="Dot11AvailableNetworks">
		<xs:sequence>
			<xs:element name="SSID" type="tt:Dot11SSIDType"/>
			<xs:element name="BSSID" type="xs:string" minOccurs="0"/>
			<xs:element name="AuthAndMangementSuite" type="tt:Dot11AuthAndMangementSuite" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>See IEEE802.11 7.3.2.25.2 for details.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PairCipher" type="tt:Dot11Cipher" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="GroupCipher" type="tt:Dot11Cipher" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="SignalStrength" type="tt:Dot11SignalStrength" minOccurs="0"/>
			<xs:element name="Extension" type="tt:Dot11AvailableNetworksExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Dot11AvailableNetworksExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--===============================-->
	<!--  End, network Related Types   -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--   Capabilities Related Types  -->
	<!--===============================-->
	<xs:simpleType name="CapabilityCategory">
		<xs:restriction base="xs:string">
			<xs:enumeration value="All"/>
			<xs:enumeration value="Analytics"/>
			<xs:enumeration value="Device"/>
			<xs:enumeration value="Events"/>
			<xs:enumeration value="Imaging"/>
			<xs:enumeration value="Media"/>
			<xs:enumeration value="PTZ"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="Capabilities">
		<xs:sequence>
			<xs:element name="Analytics" type="tt:AnalyticsCapabilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Analytics capabilities</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Device" type="tt:DeviceCapabilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Device capabilities</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Events" type="tt:EventCapabilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Event capabilities</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Imaging" type="tt:ImagingCapabilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Imaging capabilities</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Media" type="tt:MediaCapabilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Media capabilities</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PTZ" type="tt:PTZCapabilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation>PTZ capabilities</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:CapabilitiesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="CapabilitiesExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="DeviceIO" type="tt:DeviceIOCapabilities" minOccurs="0"/>
			<xs:element name="Display" type="tt:DisplayCapabilities" minOccurs="0"/>
			<xs:element name="Recording" type="tt:RecordingCapabilities" minOccurs="0"/>
			<xs:element name="Search" type="tt:SearchCapabilities" minOccurs="0"/>
			<xs:element name="Replay" type="tt:ReplayCapabilities" minOccurs="0"/>
			<xs:element name="Receiver" type="tt:ReceiverCapabilities" minOccurs="0"/>
			<xs:element name="AnalyticsDevice" type="tt:AnalyticsDeviceCapabilities" minOccurs="0"/>
			<xs:element name="Extensions" type="tt:CapabilitiesExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="CapabilitiesExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>Analytics service URI.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RuleSupport" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not rules are supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AnalyticsModuleSupport" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not modules are supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DeviceCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>Device service URI.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Network" type="tt:NetworkCapabilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Network capabilities.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="System" type="tt:SystemCapabilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation>System capabilities.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IO" type="tt:IOCapabilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation>I/O capabilities.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Security" type="tt:SecurityCapabilities" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Security capabilities.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:DeviceCapabilitiesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DeviceCapabilitiesExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="EventCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>Event service URI.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WSSubscriptionPolicySupport" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not WS Subscription policy is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WSPullPointSupport" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not WS Pull Point is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WSPausableSubscriptionManagerInterfaceSupport" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not WS Pausable Subscription Manager Interface is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IOCapabilities">
		<xs:sequence>
			<xs:element name="InputConnectors" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Number of input connectors.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RelayOutputs" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Number of relay outputs.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:IOCapabilitiesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IOCapabilitiesExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Auxiliary" type="xs:boolean" minOccurs="0"/>
			<xs:element name="AuxiliaryCommands" type="tt:AuxiliaryData" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:IOCapabilitiesExtension2"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IOCapabilitiesExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MediaCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>Media service URI.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StreamingCapabilities" type="tt:RealTimeStreamingCapabilities">
				<xs:annotation>
					<xs:documentation>Streaming capabilities.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:MediaCapabilitiesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MediaCapabilitiesExtension">
		<xs:sequence>
			<xs:element name="ProfileCapabilities" type="tt:ProfileCapabilities"/>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RealTimeStreamingCapabilities">
		<xs:sequence>
			<xs:element name="RTPMulticast" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not RTP multicast is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RTP_TCP" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not RTP over TCP is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RTP_RTSP_TCP" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not RTP/RTSP/TCP is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:RealTimeStreamingCapabilitiesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RealTimeStreamingCapabilitiesExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ProfileCapabilities">
		<xs:sequence>
			<xs:element name="MaximumNumberOfProfiles" type="xs:int">
				<xs:annotation>
					<xs:documentation>Maximum number of profiles.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkCapabilities">
		<xs:sequence>
			<xs:element name="IPFilter" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not IP filtering is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ZeroConfiguration" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not zeroconf is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IPVersion6" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not IPv6 is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DynDNS" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not  is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:NetworkCapabilitiesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkCapabilitiesExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Dot11Configuration" type="xs:boolean" minOccurs="0"/>
			<xs:element name="Extension" type="tt:NetworkCapabilitiesExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NetworkCapabilitiesExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SecurityCapabilities">
		<xs:sequence>
			<xs:element name="TLS1.1" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not TLS 1.1 is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TLS1.2" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not TLS 1.2 is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="OnboardKeyGeneration" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not onboard key generation is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AccessPolicyConfig" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not access policy configuration is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="X.509Token" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not WS-Security X.509 token is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SAMLToken" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not WS-Security SAML token is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="KerberosToken" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not WS-Security Kerberos token is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RELToken" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not WS-Security REL token is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:SecurityCapabilitiesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SecurityCapabilitiesExtension">
		<xs:sequence>
			<xs:element name="TLS1.0" type="xs:boolean"/>
			<xs:element name="Extension" type="tt:SecurityCapabilitiesExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SecurityCapabilitiesExtension2">
		<xs:sequence>
			<xs:element name="Dot1X" type="xs:boolean"/>
			<xs:element name="SupportedEAPMethod" type="xs:int" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>EAP Methods supported by the device. The int values refer to the <a href="http://www.iana.org/assignments/eap-numbers/eap-numbers.xhtml">IANA EAP Registry</a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RemoteUserHandling" type="xs:boolean"/>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SystemCapabilities">
		<xs:sequence>
			<xs:element name="DiscoveryResolve" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not WS Discovery resolve requests are supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DiscoveryBye" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not WS-Discovery Bye is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RemoteDiscovery" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not remote discovery is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemBackup" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not system backup is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SystemLogging" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not system logging is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FirmwareUpgrade" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not firmware upgrade is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SupportedVersions" type="tt:OnvifVersion" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Indicates supported ONVIF version(s).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:SystemCapabilitiesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SystemCapabilitiesExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="HttpFirmwareUpgrade" type="xs:boolean" minOccurs="0"/>
			<xs:element name="HttpSystemBackup" type="xs:boolean" minOccurs="0"/>
			<xs:element name="HttpSystemLogging" type="xs:boolean" minOccurs="0"/>
			<xs:element name="HttpSupportInformation" type="xs:boolean" minOccurs="0"/>
			<xs:element name="Extension" type="tt:SystemCapabilitiesExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SystemCapabilitiesExtension2">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OnvifVersion">
		<xs:sequence>
			<xs:element name="Major" type="xs:int">
				<xs:annotation>
					<xs:documentation>Major version number.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Minor" type="xs:int">
				<xs:annotation>
					<xs:documentation>
						Two digit minor version number.
						If major version number is less than "16", X.0.1 maps to "01" and X.2.1 maps to "21" where X stands for Major version number.
						Otherwise, minor number is month of release, such as "06" for June.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>Imaging service URI.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>PTZ service URI.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DeviceIOCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI"/>
			<xs:element name="VideoSources" type="xs:int"/>
			<xs:element name="VideoOutputs" type="xs:int"/>
			<xs:element name="AudioSources" type="xs:int"/>
			<xs:element name="AudioOutputs" type="xs:int"/>
			<xs:element name="RelayOutputs" type="xs:int"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DisplayCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI"/>
			<xs:element name="FixedLayout" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indication that the SetLayout command supports only predefined layouts.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI"/>
			<xs:element name="ReceiverSource" type="xs:boolean"/>
			<xs:element name="MediaProfileSource" type="xs:boolean"/>
			<xs:element name="DynamicRecordings" type="xs:boolean"/>
			<xs:element name="DynamicTracks" type="xs:boolean"/>
			<xs:element name="MaxStringLength" type="xs:int"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SearchCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI"/>
			<xs:element name="MetadataSearch" type="xs:boolean"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ReplayCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>The address of the replay service.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ReceiverCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>The address of the receiver service.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RTP_Multicast" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether the device can receive RTP multicast streams.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RTP_TCP" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether the device can receive RTP/TCP streams</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RTP_RTSP_TCP" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether the device can receive RTP/RTSP/TCP streams.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SupportedReceivers" type="xs:int">
				<xs:annotation>
					<xs:documentation>The maximum number of receivers supported by the device.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaximumRTSPURILength" type="xs:int">
				<xs:annotation>
					<xs:documentation>The maximum allowed length for RTSP URIs.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsDeviceCapabilities">
		<xs:sequence>
			<xs:element name="XAddr" type="xs:anyURI"/>
			<xs:element name="RuleSupport" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Obsolete property.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:AnalyticsDeviceExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsDeviceExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--===============================-->
	<!--End, Capabilities Related Types-->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--    System Related Types       -->
	<!--===============================-->
	<xs:simpleType name="SystemLogType">
		<xs:annotation>
			<xs:documentation>Enumeration describing the available system log modes.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="System">
				<xs:annotation>
					<xs:documentation>Indicates that a system log is requested.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Access">
				<xs:annotation>
					<xs:documentation>Indicates that a access log is requested.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="SystemLog">
		<xs:sequence>
			<xs:element name="Binary" type="tt:AttachmentData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The log information as attachment data.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="String" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The log information as character data.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SupportInformation">
		<xs:sequence>
			<xs:element name="Binary" type="tt:AttachmentData" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The support information as attachment data.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="String" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The support information as character data.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="BinaryData">
		<xs:sequence>
			<xs:element name="Data" type="xs:base64Binary" nillable="false">
				<xs:annotation>
					<xs:documentation>base64 encoded binary data.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute ref="xmime:contentType" use="optional"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AttachmentData">
		<xs:sequence>
			<xs:element ref="xop:Include"/>
		</xs:sequence>
		<xs:attribute ref="xmime:contentType" use="optional"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="BackupFile">
		<xs:sequence>
			<xs:element name="Name" type="xs:string"/>
			<xs:element name="Data" type="tt:AttachmentData"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SystemLogUriList">
		<xs:sequence>
			<xs:element name="SystemLog" type="tt:SystemLogUri" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SystemLogUri">
		<xs:sequence>
			<xs:element name="Type" type="tt:SystemLogType"/>
			<xs:element name="Uri" type="xs:anyURI"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="FactoryDefaultType">
		<xs:annotation>
			<xs:documentation>Enumeration describing the available factory default modes.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Hard">
				<xs:annotation>
					<xs:documentation>Indicates that a hard factory default is requested.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Soft">
				<xs:annotation>
					<xs:documentation>Indicates that a soft factory default is requested.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="SetDateTimeType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Manual">
				<xs:annotation>
					<xs:documentation>Indicates that the date and time are set manually.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="NTP">
				<xs:annotation>
					<xs:documentation>Indicates that the date and time are set through NTP</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="SystemDateTime">
		<xs:annotation>
			<xs:documentation>General date time inforamtion returned by the GetSystemDateTime method.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="DateTimeType" type="tt:SetDateTimeType">
				<xs:annotation>
					<xs:documentation>Indicates if the time is set manully or through NTP.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DaylightSavings" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Informative indicator whether daylight savings is currently on/off.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TimeZone" type="tt:TimeZone" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Timezone information in Posix format.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UTCDateTime" type="tt:DateTime" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Current system date and time in UTC format. This field is mandatory since version 2.0.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="LocalDateTime" type="tt:DateTime" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Date and time in local format.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:SystemDateTimeExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SystemDateTimeExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DateTime">
		<xs:sequence>
			<xs:element name="Time" type="tt:Time"/>
			<xs:element name="Date" type="tt:Date"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Date">
		<xs:sequence>
			<xs:element name="Year" type="xs:int"/>
			<xs:element name="Month" type="xs:int">
				<xs:annotation>
					<xs:documentation>Range is 1 to 12.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Day" type="xs:int">
				<xs:annotation>
					<xs:documentation>Range is 1 to 31.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Time">
		<xs:sequence>
			<xs:element name="Hour" type="xs:int">
				<xs:annotation>
					<xs:documentation>Range is 0 to 23.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Minute" type="xs:int">
				<xs:annotation>
					<xs:documentation>Range is 0 to 59.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Second" type="xs:int">
				<xs:annotation>
					<xs:documentation>Range is 0 to 61 (typically 59).</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="TimeZone">
		<xs:annotation>
			<xs:documentation>
				The TZ format is specified by POSIX, please refer to POSIX 1003.1 section 8.3<br/>
				Example: Europe, Paris TZ=CET-1CEST,M3.5.0/2,M10.5.0/3<br/>
				CET = designation for standard time when daylight saving is not in force<br/>
				-1 = offset in hours = negative so 1 hour east of Greenwich meridian<br/>
				CEST = designation when daylight saving is in force ("Central European Summer Time")<br/>
				, = no offset number between code and comma, so default to one hour ahead for daylight saving<br/>
				M3.5.0 = when daylight saving starts = the last Sunday in March (the "5th" week means the last in the month)<br/>
				/2, = the local time when the switch occurs = 2 a.m. in this case<br/>
				M10.5.0 = when daylight saving ends = the last Sunday in October.<br/>
				/3, = the local time when the switch occurs = 3 a.m. in this case<br/>
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="TZ" type="xs:token">
				<xs:annotation>
					<xs:documentation>Posix timezone string.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--   End, System Related Types   -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--   RemoteUser Handling Types    -->
	<!--===============================-->
	<xs:complexType name="RemoteUser">
		<xs:sequence>
			<xs:element name="Username" type="xs:string"/>
			<xs:element name="Password" type="xs:string" minOccurs="0"/>
			<xs:element name="UseDerivedPassword" type="xs:boolean"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--   End, RemoteUser Handling Types    -->
	<!--===============================-->
	<!--===============================-->
	<!--   UserToken Handling Types    -->
	<!--===============================-->
	<xs:simpleType name="UserLevel">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Administrator"/>
			<xs:enumeration value="Operator"/>
			<xs:enumeration value="User"/>
			<xs:enumeration value="Anonymous"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="User">
		<xs:sequence>
			<xs:element name="Username" type="xs:string">
				<xs:annotation>
					<xs:documentation>Username string.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Password" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Password string.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="UserLevel" type="tt:UserLevel">
				<xs:annotation>
					<xs:documentation>User level string.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:UserExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="UserExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!-- End, UserToken Handling Types -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--   Security Management Types   -->
	<!--===============================-->
	<xs:complexType name="CertificateGenerationParameters">
		<xs:sequence>
			<xs:element name="CertificateID" type="xs:token" minOccurs="0"/>
			<xs:element name="Subject" type="xs:string" minOccurs="0"/>
			<xs:element name="ValidNotBefore" type="xs:token" minOccurs="0"/>
			<xs:element name="ValidNotAfter" type="xs:token" minOccurs="0"/>
			<xs:element name="Extension" type="tt:CertificateGenerationParametersExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="CertificateGenerationParametersExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Certificate">
		<xs:sequence>
			<xs:element name="CertificateID" type="xs:token">
				<xs:annotation>
					<xs:documentation>Certificate id.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Certificate" type="tt:BinaryData">
				<xs:annotation>
					<xs:documentation>base64 encoded DER representation of certificate.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="CertificateStatus">
		<xs:sequence>
			<xs:element name="CertificateID" type="xs:token">
				<xs:annotation>
					<xs:documentation>Certificate id.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Status" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not a certificate is used in an HTTPS configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="CertificateWithPrivateKey">
		<xs:sequence>
			<xs:element name="CertificateID" type="xs:token" minOccurs="0"/>
			<xs:element name="Certificate" type="tt:BinaryData"/>
			<xs:element name="PrivateKey" type="tt:BinaryData"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="CertificateInformation">
		<xs:sequence>
			<xs:element name="CertificateID" type="xs:token"/>
			<xs:element name="IssuerDN" type="xs:string" minOccurs="0"/>
			<xs:element name="SubjectDN" type="xs:string" minOccurs="0"/>
			<xs:element name="KeyUsage" type="tt:CertificateUsage" minOccurs="0"/>
			<xs:element name="ExtendedKeyUsage" type="tt:CertificateUsage" minOccurs="0"/>
			<xs:element name="KeyLength" type="xs:int" minOccurs="0"/>
			<xs:element name="Version" type="xs:string" minOccurs="0"/>
			<xs:element name="SerialNum" type="xs:string" minOccurs="0"/>
			<xs:element name="SignatureAlgorithm" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Validity Range is from "NotBefore" to "NotAfter"; the corresponding DateTimeRange is from "From" to "Until"</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Validity" type="tt:DateTimeRange" minOccurs="0"/>
			<xs:element name="Extension" type="tt:CertificateInformationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="CertificateUsage">
		<xs:simpleContent>
			<xs:extension base="xs:string">
				<xs:attribute name="Critical" type="xs:boolean" use="required"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="CertificateInformationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--End, Security management Types -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--   Start Dot1X related Types   -->
	<!--===============================-->
	<xs:complexType name="Dot1XConfiguration">
		<xs:sequence>
			<xs:element name="Dot1XConfigurationToken" type="tt:ReferenceToken"/>
			<xs:element name="Identity" type="xs:string"/>
			<xs:element name="AnonymousID" type="xs:string" minOccurs="0"/>
			<xs:element name="EAPMethod" type="xs:int">
				<xs:annotation>
					<xs:documentation>
				EAP Method type as defined in <a href="http://www.iana.org/assignments/eap-numbers/eap-numbers.xhtml">IANA EAP Registry</a>.
			</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CACertificateID" type="xs:token" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="EAPMethodConfiguration" type="tt:EAPMethodConfiguration" minOccurs="0"/>
			<xs:element name="Extension" type="tt:Dot1XConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Dot1XConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="EAPMethodConfiguration">
		<xs:sequence>
			<xs:element name="TLSConfiguration" type="tt:TLSConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Confgiuration information for TLS Method.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Password" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Password for those EAP Methods that require a password. The password shall never be returned on a get method.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:EapMethodExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="EapMethodExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="TLSConfiguration">
		<xs:sequence>
			<xs:element name="CertificateID" type="xs:token"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="GenericEapPwdConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--End, Dot1X related Types -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--   Start IO management Types   -->
	<!--===============================-->
	<xs:simpleType name="RelayLogicalState">
		<xs:restriction base="xs:string">
			<xs:enumeration value="active"/>
			<xs:enumeration value="inactive"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="RelayIdleState">
		<xs:restriction base="xs:string">
			<xs:enumeration value="closed"/>
			<xs:enumeration value="open"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="RelayOutputSettings">
		<xs:sequence>
			<xs:element name="Mode" type="tt:RelayMode">
				<xs:annotation>
					<xs:documentation>
					'Bistable' or 'Monostable'
					<ul>
							<li>Bistable  After setting the state, the relay remains in this state.</li>
							<li>Monostable  After setting the state, the relay returns to its idle state after the specified time.</li>
						</ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DelayTime" type="xs:duration">
				<xs:annotation>
					<xs:documentation>Time after which the relay returns to its idle state if it is in monostable mode. If the Mode field is set to bistable mode the value of the parameter can be ignored.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IdleState" type="tt:RelayIdleState">
				<xs:annotation>
					<xs:documentation>
			'open' or 'closed'
			<ul>
							<li>'open' means that the relay is open when the relay state is set to 'inactive' through the trigger command and closed when the state is set to 'active' through the same command.</li>
							<li>'closed' means that the relay is closed when the relay state is set to 'inactive' through the trigger command and open when the state is set to 'active' through the same command.</li>
						</ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="RelayMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Monostable"/>
			<xs:enumeration value="Bistable"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="RelayOutput">
		<xs:complexContent>
			<xs:extension base="tt:DeviceEntity">
				<xs:sequence>
					<xs:element name="Properties" type="tt:RelayOutputSettings"/>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="DigitalIdleState">
		<xs:restriction base="xs:string">
			<xs:enumeration value="closed"/>
			<xs:enumeration value="open"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="DigitalInput">
		<xs:complexContent>
			<xs:extension base="tt:DeviceEntity">
				<xs:sequence>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
				</xs:sequence>
				<xs:attribute name="IdleState" type="tt:DigitalIdleState">
					<xs:annotation>
						<xs:documentation>
							Indicate the Digital IdleState status.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<!--   End, IO management Types    -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--    Start PTZ Related Types    -->
	<!--===============================-->
	<xs:complexType name="PTZNode">
		<xs:complexContent>
			<xs:extension base="tt:DeviceEntity">
				<xs:sequence>
					<xs:element name="Name" type="tt:Name" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                A unique identifier that is used to reference PTZ Nodes.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="SupportedPTZSpaces" type="tt:PTZSpaces">
						<xs:annotation>
							<xs:documentation>
                A list of Coordinate Systems available for the PTZ Node. For each Coordinate System, the PTZ Node MUST specify its allowed range.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="MaximumNumberOfPresets" type="xs:int">
						<xs:annotation>
							<xs:documentation>
                All preset operations MUST be available for this PTZ Node if one preset is supported.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="HomeSupported" type="xs:boolean">
						<xs:annotation>
							<xs:documentation>
                A boolean operator specifying the availability of a home position. If set to true, the Home Position Operations MUST be available for this PTZ Node.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="AuxiliaryCommands" type="tt:AuxiliaryData" minOccurs="0" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>
                A list of supported Auxiliary commands. If the list is not empty, the Auxiliary Operations MUST be available for this PTZ Node.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extension" type="tt:PTZNodeExtension" minOccurs="0"/>
				</xs:sequence>
				<xs:attribute name="FixedHomePosition" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>
							Indication whether the HomePosition of a Node is fixed or it can be changed via the SetHomePosition command.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="GeoMove" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>
							Indication whether the Node supports the geo-referenced move command.
						</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZNodeExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="SupportedPresetTour" type="tt:PTZPresetTourSupported" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
            Detail of supported Preset Tour feature.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZNodeExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZNodeExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourSupported">
		<xs:sequence>
			<xs:element name="MaximumNumberOfPresetTours" type="xs:int">
				<xs:annotation>
					<xs:documentation>Indicates number of preset tours that can be created. Required preset tour operations shall be available for this PTZ Node if one or more preset tour is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PTZPresetTourOperation" type="tt:PTZPresetTourOperation" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Indicates which preset tour operations are available for this PTZ Node.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZPresetTourSupportedExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourSupportedExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZConfiguration">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="NodeToken" type="tt:ReferenceToken">
						<xs:annotation>
							<xs:documentation>
                A mandatory reference to the PTZ Node that the PTZ Configuration belongs to.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefaultAbsolutePantTiltPositionSpace" type="xs:anyURI" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                If the PTZ Node supports absolute Pan/Tilt movements, it shall specify one Absolute Pan/Tilt Position Space as default.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefaultAbsoluteZoomPositionSpace" type="xs:anyURI" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                If the PTZ Node supports absolute zoom movements, it shall specify one Absolute Zoom Position Space as default.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefaultRelativePanTiltTranslationSpace" type="xs:anyURI" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                If the PTZ Node supports relative Pan/Tilt movements, it shall specify one RelativePan/Tilt Translation Space as default.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefaultRelativeZoomTranslationSpace" type="xs:anyURI" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                If the PTZ Node supports relative zoom movements, it shall specify one Relative Zoom Translation Space as default.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefaultContinuousPanTiltVelocitySpace" type="xs:anyURI" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                If the PTZ Node supports continuous Pan/Tilt movements, it shall specify one Continuous Pan/Tilt Velocity Space as default.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefaultContinuousZoomVelocitySpace" type="xs:anyURI" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                If the PTZ Node supports continuous zoom movements, it shall specify one Continuous Zoom Velocity Space as default.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefaultPTZSpeed" type="tt:PTZSpeed" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                If the PTZ Node supports absolute or relative PTZ movements, it shall specify corresponding default Pan/Tilt and Zoom speeds.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="DefaultPTZTimeout" type="xs:duration" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                If the PTZ Node supports continuous movements, it shall specify a default timeout, after which the movement stops.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="PanTiltLimits" type="tt:PanTiltLimits" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                The Pan/Tilt limits element should be present for a PTZ Node that supports an absolute Pan/Tilt. If the element is present it signals the support for configurable Pan/Tilt limits. If limits are enabled, the Pan/Tilt movements shall always stay within the specified range. The Pan/Tilt limits are disabled by setting the limits to INF or +INF.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="ZoomLimits" type="tt:ZoomLimits" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
                The Zoom limits element should be present for a PTZ Node that supports absolute zoom. If the element is present it signals the supports for configurable Zoom limits. If limits are enabled the zoom movements shall always stay within the specified range. The Zoom limits are disabled by settings the limits to -INF and +INF.
              </xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extension" type="tt:PTZConfigurationExtension" minOccurs="0">
						<xs:annotation>
							<xs:documentation>
              </xs:documentation>
						</xs:annotation>
					</xs:element>
				</xs:sequence>
				<xs:attribute name="MoveRamp" type="xs:int">
					<xs:annotation>
						<xs:documentation>The optional acceleration ramp used by the device when moving.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="PresetRamp" type="xs:int">
					<xs:annotation>
						<xs:documentation>The optional acceleration ramp used by the device when recalling presets.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:attribute name="PresetTourRamp" type="xs:int">
					<xs:annotation>
						<xs:documentation>The optional acceleration ramp used by the device when executing PresetTours.</xs:documentation>
					</xs:annotation>
				</xs:attribute>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="PTControlDirection" type="tt:PTControlDirection" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional element to configure PT Control Direction related features.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZConfigurationExtension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZConfigurationExtension2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTControlDirection">
		<xs:sequence>
			<xs:element name="EFlip" type="tt:EFlip" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional element to configure related parameters for E-Flip.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Reverse" type="tt:Reverse" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional element to configure related parameters for reversing of PT Control Direction.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTControlDirectionExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTControlDirectionExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="EFlip">
		<xs:sequence>
			<xs:element name="Mode" type="tt:EFlipMode">
				<xs:annotation>
					<xs:documentation>Parameter to enable/disable E-Flip feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Reverse">
		<xs:sequence>
			<xs:element name="Mode" type="tt:ReverseMode">
				<xs:annotation>
					<xs:documentation>Parameter to enable/disable Reverse feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="EFlipMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="OFF"/>
			<xs:enumeration value="ON"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="ReverseMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="OFF"/>
			<xs:enumeration value="ON"/>
			<xs:enumeration value="AUTO"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="PTZConfigurationOptions">
		<xs:sequence>
			<xs:element name="Spaces" type="tt:PTZSpaces">
				<xs:annotation>
					<xs:documentation>
            A list of supported coordinate systems including their range limitations.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PTZTimeout" type="tt:DurationRange">
				<xs:annotation>
					<xs:documentation>
            A timeout Range within which Timeouts are accepted by the PTZ Node.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="PTControlDirection" type="tt:PTControlDirectionOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Supported options for PT Direction Control.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZConfigurationOptions2" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="PTZRamps" type="tt:IntList">
			<xs:annotation>
				<xs:documentation>
					The list of acceleration ramps supported by the device. The
					smallest acceleration value corresponds to the minimal index, the
					highest acceleration corresponds to the maximum index.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZConfigurationOptions2">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTControlDirectionOptions">
		<xs:sequence>
			<xs:element name="EFlip" type="tt:EFlipOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Supported options for EFlip feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Reverse" type="tt:ReverseOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Supported options for Reverse feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTControlDirectionOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTControlDirectionOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="EFlipOptions">
		<xs:sequence>
			<xs:element name="Mode" type="tt:EFlipMode" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Options of EFlip mode parameter.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:EFlipOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="EFlipOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ReverseOptions">
		<xs:sequence>
			<xs:element name="Mode" type="tt:ReverseMode" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Options of Reverse mode parameter.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ReverseOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ReverseOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PanTiltLimits">
		<xs:sequence>
			<xs:element name="Range" type="tt:Space2DDescription">
				<xs:annotation>
					<xs:documentation>
            A range of pan tilt limits.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ZoomLimits">
		<xs:sequence>
			<xs:element name="Range" type="tt:Space1DDescription">
				<xs:annotation>
					<xs:documentation>
            A range of zoom limit
          </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZSpaces">
		<xs:sequence>
			<xs:element name="AbsolutePanTiltPositionSpace" type="tt:Space2DDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
            The Generic Pan/Tilt Position space is provided by every PTZ node that supports absolute Pan/Tilt, since it does not relate to a specific physical range. 
			Instead, the range should be defined as the full range of the PTZ unit normalized to the range -1 to 1 resulting in the following space description.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AbsoluteZoomPositionSpace" type="tt:Space1DDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
            The Generic Zoom Position Space is provided by every PTZ node that supports absolute Zoom, since it does not relate to a specific physical range. 
			Instead, the range should be defined as the full range of the Zoom normalized to the range 0 (wide) to 1 (tele). 
			There is no assumption about how the generic zoom range is mapped to magnification, FOV or other physical zoom dimension.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RelativePanTiltTranslationSpace" type="tt:Space2DDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
            The Generic Pan/Tilt translation space is provided by every PTZ node that supports relative Pan/Tilt, since it does not relate to a specific physical range. 
			Instead, the range should be defined as the full positive and negative translation range of the PTZ unit normalized to the range -1 to 1, 
			where positive translation would mean clockwise rotation or movement in right/up direction resulting in the following space description.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RelativeZoomTranslationSpace" type="tt:Space1DDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
            The Generic Zoom Translation Space is provided by every PTZ node that supports relative Zoom, since it does not relate to a specific physical range. 
			Instead, the corresponding absolute range should be defined as the full positive and negative translation range of the Zoom normalized to the range -1 to1, 
			where a positive translation maps to a movement in TELE direction. The translation is signed to indicate direction (negative is to wide, positive is to tele). 
			There is no assumption about how the generic zoom range is mapped to magnification, FOV or other physical zoom dimension. This results in the following space description.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ContinuousPanTiltVelocitySpace" type="tt:Space2DDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
            The generic Pan/Tilt velocity space shall be provided by every PTZ node, since it does not relate to a specific physical range. 
			Instead, the range should be defined as a range of the PTZ units speed normalized to the range -1 to 1, where a positive velocity would map to clockwise 
			rotation or movement in the right/up direction. A signed speed can be independently specified for the pan and tilt component resulting in the following space description.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ContinuousZoomVelocitySpace" type="tt:Space1DDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
            The generic zoom velocity space specifies a zoom factor velocity without knowing the underlying physical model. The range should be normalized from -1 to 1, 
			where a positive velocity would map to TELE direction. A generic zoom velocity space description resembles the following.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PanTiltSpeedSpace" type="tt:Space1DDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
            The speed space specifies the speed for a Pan/Tilt movement when moving to an absolute position or to a relative translation. 
			In contrast to the velocity spaces, speed spaces do not contain any directional information. The speed of a combined Pan/Tilt 
			movement is represented by a single non-negative scalar value.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ZoomSpeedSpace" type="tt:Space1DDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
            The speed space specifies the speed for a Zoom movement when moving to an absolute position or to a relative translation. 
			In contrast to the velocity spaces, speed spaces do not contain any directional information. 
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZSpacesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZSpacesExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Space2DDescription">
		<xs:sequence>
			<xs:element name="URI" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>
            A URI of coordinate systems.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="XRange" type="tt:FloatRange">
				<xs:annotation>
					<xs:documentation>
            A range of x-axis.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="YRange" type="tt:FloatRange">
				<xs:annotation>
					<xs:documentation>
            A range of y-axis.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Space1DDescription">
		<xs:sequence>
			<xs:element name="URI" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>
            A URI of coordinate systems.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="XRange" type="tt:FloatRange">
				<xs:annotation>
					<xs:documentation>
            A range of x-axis.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZSpeed">
		<xs:sequence>
			<xs:element name="PanTilt" type="tt:Vector2D" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Pan and tilt speed. The x component corresponds to pan and the y component to tilt. If omitted in a request, the current (if any) PanTilt movement should not be affected. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Zoom" type="tt:Vector1D" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
            A zoom speed. If omitted in a request, the current (if any) Zoom movement should not be affected.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPreset">
		<xs:sequence>
			<xs:element name="Name" type="tt:Name" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
            A list of preset position name.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PTZPosition" type="tt:PTZVector" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
            A list of preset position.
          </xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="token" type="tt:ReferenceToken">
			<xs:annotation>
				<xs:documentation>
        </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="AuxiliaryData">
		<xs:restriction base="xs:string">
			<xs:maxLength value="128"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="PTZPresetTourState">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Idle"/>
			<xs:enumeration value="Touring"/>
			<xs:enumeration value="Paused"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="PTZPresetTourDirection">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Forward"/>
			<xs:enumeration value="Backward"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="PTZPresetTourOperation">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Start"/>
			<xs:enumeration value="Stop"/>
			<xs:enumeration value="Pause"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="PresetTour">
		<xs:sequence>
			<xs:element name="Name" type="tt:Name" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Readable name of the preset tour.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Status" type="tt:PTZPresetTourStatus">
				<xs:annotation>
					<xs:documentation>Read only parameters to indicate the status of the preset tour.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AutoStart" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Auto Start flag of the preset tour. True allows the preset tour to be activated always.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StartingCondition" type="tt:PTZPresetTourStartingCondition">
				<xs:annotation>
					<xs:documentation>Parameters to specify the detail behavior of the preset tour.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TourSpot" type="tt:PTZPresetTourSpot" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A list of detail of touring spots including preset positions.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZPresetTourExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="token" type="tt:ReferenceToken">
			<xs:annotation>
				<xs:documentation>Unique identifier of this preset tour.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourSpot">
		<xs:sequence>
			<xs:element name="PresetDetail" type="tt:PTZPresetTourPresetDetail">
				<xs:annotation>
					<xs:documentation>Detail definition of preset position of the tour spot.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Speed" type="tt:PTZSpeed" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional parameter to specify Pan/Tilt and Zoom speed on moving toward this tour spot.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StayTime" type="xs:duration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional parameter to specify time duration of staying on this tour sport.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZPresetTourSpotExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourSpotExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourPresetDetail">
		<xs:sequence>
			<xs:choice>
				<xs:element name="PresetToken" type="tt:ReferenceToken">
					<xs:annotation>
						<xs:documentation>Option to specify the preset position with Preset Token defined in advance.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Home" type="xs:boolean">
					<xs:annotation>
						<xs:documentation>Option to specify the preset position with the home position of this PTZ Node. "False" to this parameter shall be treated as an invalid argument.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="PTZPosition" type="tt:PTZVector">
					<xs:annotation>
						<xs:documentation>Option to specify the preset position with vector of PTZ node directly.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="TypeExtension" type="tt:PTZPresetTourTypeExtension"/>
			</xs:choice>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourTypeExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourStatus">
		<xs:sequence>
			<xs:element name="State" type="tt:PTZPresetTourState">
				<xs:annotation>
					<xs:documentation>Indicates state of this preset tour by Idle/Touring/Paused.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CurrentTourSpot" type="tt:PTZPresetTourSpot" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates a tour spot currently staying.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZPresetTourStatusExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourStatusExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourStartingCondition">
		<xs:sequence>
			<xs:element name="RecurringTime" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional parameter to specify how many times the preset tour is recurred.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RecurringDuration" type="xs:duration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional parameter to specify how long time duration the preset tour is recurred.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Direction" type="tt:PTZPresetTourDirection" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional parameter to choose which direction the preset tour goes. Forward shall be chosen in case it is omitted.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZPresetTourStartingConditionExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="RandomPresetOrder" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Execute presets in random order. If set to true and Direction is also present, Direction will be ignored and presets of the Tour will be recalled randomly.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourStartingConditionExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourOptions">
		<xs:sequence>
			<xs:element name="AutoStart" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not the AutoStart is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StartingCondition" type="tt:PTZPresetTourStartingConditionOptions">
				<xs:annotation>
					<xs:documentation>Supported options for Preset Tour Starting Condition.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TourSpot" type="tt:PTZPresetTourSpotOptions">
				<xs:annotation>
					<xs:documentation>Supported options for Preset Tour Spot.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourSpotOptions">
		<xs:sequence>
			<xs:element name="PresetDetail" type="tt:PTZPresetTourPresetDetailOptions">
				<xs:annotation>
					<xs:documentation>Supported options for detail definition of preset position of the tour spot.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StayTime" type="tt:DurationRange">
				<xs:annotation>
					<xs:documentation>Supported range of stay time for a tour spot.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourPresetDetailOptions">
		<xs:sequence>
			<xs:element name="PresetToken" type="tt:ReferenceToken" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A list of available Preset Tokens for tour spots.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Home" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>An option to indicate Home postion for tour spots.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PanTiltPositionSpace" type="tt:Space2DDescription" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Supported range of Pan and Tilt for tour spots.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ZoomPositionSpace" type="tt:Space1DDescription" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Supported range of Zoom for a tour spot.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZPresetTourPresetDetailOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourPresetDetailOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourStartingConditionOptions">
		<xs:sequence>
			<xs:element name="RecurringTime" type="tt:IntRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Supported range of Recurring Time.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RecurringDuration" type="tt:DurationRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Supported range of Recurring Duration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Direction" type="tt:PTZPresetTourDirection" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Supported options for Direction of Preset Tour.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PTZPresetTourStartingConditionOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPresetTourStartingConditionOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:simpleType name="MoveAndTrackMethod">
		<xs:restriction base="xs:string">
			<xs:enumeration value="PresetToken"/>
			<xs:enumeration value="GeoLocation"/>
			<xs:enumeration value="PTZVector"/>
			<xs:enumeration value="ObjectID"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<!--     End, PTZ Related Types    -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--      Imaging Related Types    -->
	<!--===============================-->
	<xs:complexType name="ImagingStatus">
		<xs:sequence>
			<xs:element name="FocusStatus" type="tt:FocusStatus"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FocusStatus">
		<xs:sequence>
			<xs:element name="Position" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Status of focus position.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MoveStatus" type="tt:MoveStatus">
				<xs:annotation>
					<xs:documentation>
				Status of focus MoveStatus.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Error" type="xs:string">
				<xs:annotation>
					<xs:documentation>
				Error status of focus.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FocusConfiguration">
		<xs:sequence>
			<xs:element name="AutoFocusMode" type="tt:AutoFocusMode"/>
			<xs:element name="DefaultSpeed" type="xs:float"/>
			<xs:element name="NearLimit" type="xs:float">
				<xs:annotation>
					<xs:documentation>Parameter to set autofocus near limit (unit: meter).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FarLimit" type="xs:float">
				<xs:annotation>
					<xs:documentation>Parameter to set autofocus far limit (unit: meter).
If set to 0.0, infinity will be used.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="AutoFocusMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="AUTO"/>
			<xs:enumeration value="MANUAL"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="AFModes">
		<xs:restriction base="xs:string">
			<xs:enumeration value="OnceAfterMove">
				<xs:annotation><xs:documentation>Focus of a moving camera is updated only once after stopping a pan, tilt or zoom movement.</xs:documentation></xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="ImagingSettings">
		<xs:sequence>
			<xs:element name="BacklightCompensation" type="tt:BacklightCompensation" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Enabled/disabled BLC mode (on/off).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Brightness" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Image brightness (unit unspecified).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ColorSaturation" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Color saturation of the image (unit unspecified).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Contrast" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Contrast of the image (unit unspecified).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Exposure" type="tt:Exposure" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Exposure mode of the device.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Focus" type="tt:FocusConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Focus configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IrCutFilter" type="tt:IrCutFilterMode" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Infrared Cutoff Filter settings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Sharpness" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Sharpness of the Video image.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WideDynamicRange" type="tt:WideDynamicRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>WDR settings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WhiteBalance" type="tt:WhiteBalance" minOccurs="0">
				<xs:annotation>
					<xs:documentation>White balance settings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImagingSettingsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingSettingsExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Exposure">
		<xs:sequence>
			<xs:element name="Mode" type="tt:ExposureMode">
				<xs:annotation>
					<xs:documentation>
					Exposure Mode
					<ul>
							<li>Auto  Enabled the exposure algorithm on the NVT.</li>
							<li>Manual  Disabled exposure algorithm on the NVT.</li>
						</ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Priority" type="tt:ExposurePriority">
				<xs:annotation>
					<xs:documentation>
				The exposure priority mode (low noise/framerate).
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Window" type="tt:Rectangle">
				<xs:annotation>
					<xs:documentation>
				Rectangular exposure mask.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MinExposureTime" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Minimum value of exposure time range allowed to be used by the algorithm.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxExposureTime" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Maximum value of exposure time range allowed to be used by the algorithm.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MinGain" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Minimum value of the sensor gain range that is allowed to be used by the algorithm.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxGain" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Maximum value of the sensor gain range that is allowed to be used by the algorithm.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MinIris" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Minimum value of the iris range allowed to be used by the algorithm.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxIris" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Maximum value of the iris range allowed to be used by the algorithm.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ExposureTime" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				The fixed exposure time used by the image sensor (&#956;s).
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Gain" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				The fixed gain used by the image sensor (dB).
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Iris" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				The fixed attenuation of input light affected by the iris (dB). 0dB maps to a fully opened iris.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="WideDynamicMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="OFF"/>
			<xs:enumeration value="ON"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="WideDynamicRange">
		<xs:sequence>
			<xs:element name="Mode" type="tt:WideDynamicMode">
				<xs:annotation>
					<xs:documentation>
				White dynamic range (on/off)
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Optional level parameter (unitless)
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="BacklightCompensationMode">
		<xs:annotation>
			<xs:documentation>Enumeration describing the available backlight compenstation modes.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="OFF">
				<xs:annotation>
					<xs:documentation>Backlight compensation is disabled.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ON">
				<xs:annotation>
					<xs:documentation>Backlight compensation is enabled.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="BacklightCompensation">
		<xs:sequence>
			<xs:element name="Mode" type="tt:BacklightCompensationMode">
				<xs:annotation>
					<xs:documentation>Backlight compensation mode (on/off).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="xs:float">
				<xs:annotation>
					<xs:documentation>Optional level parameter (unit unspecified).</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="ExposurePriority">
		<xs:restriction base="xs:string">
			<xs:enumeration value="LowNoise"/>
			<xs:enumeration value="FrameRate"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="ImagingOptions">
		<xs:sequence>
			<xs:element name="BacklightCompensation" type="tt:BacklightCompensationOptions"/>
			<xs:element name="Brightness" type="tt:FloatRange"/>
			<xs:element name="ColorSaturation" type="tt:FloatRange"/>
			<xs:element name="Contrast" type="tt:FloatRange"/>
			<xs:element name="Exposure" type="tt:ExposureOptions"/>
			<xs:element name="Focus" type="tt:FocusOptions"/>
			<xs:element name="IrCutFilterModes" type="tt:IrCutFilterMode" maxOccurs="unbounded"/>
			<xs:element name="Sharpness" type="tt:FloatRange"/>
			<xs:element name="WideDynamicRange" type="tt:WideDynamicRangeOptions"/>
			<xs:element name="WhiteBalance" type="tt:WhiteBalanceOptions"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="WideDynamicRangeOptions">
		<xs:sequence>
			<xs:element name="Mode" type="tt:WideDynamicMode" maxOccurs="unbounded"/>
			<xs:element name="Level" type="tt:FloatRange"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="BacklightCompensationOptions">
		<xs:sequence>
			<xs:element name="Mode" type="tt:WideDynamicMode" maxOccurs="unbounded"/>
			<xs:element name="Level" type="tt:FloatRange"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FocusOptions">
		<xs:sequence>
			<xs:element name="AutoFocusModes" type="tt:AutoFocusMode" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="DefaultSpeed" type="tt:FloatRange"/>
			<xs:element name="NearLimit" type="tt:FloatRange"/>
			<xs:element name="FarLimit" type="tt:FloatRange"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ExposureOptions">
		<xs:sequence>
			<xs:element name="Mode" type="tt:ExposureMode" maxOccurs="unbounded"/>
			<xs:element name="Priority" type="tt:ExposurePriority" maxOccurs="unbounded"/>
			<xs:element name="MinExposureTime" type="tt:FloatRange"/>
			<xs:element name="MaxExposureTime" type="tt:FloatRange"/>
			<xs:element name="MinGain" type="tt:FloatRange"/>
			<xs:element name="MaxGain" type="tt:FloatRange"/>
			<xs:element name="MinIris" type="tt:FloatRange"/>
			<xs:element name="MaxIris" type="tt:FloatRange"/>
			<xs:element name="ExposureTime" type="tt:FloatRange"/>
			<xs:element name="Gain" type="tt:FloatRange"/>
			<xs:element name="Iris" type="tt:FloatRange"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="WhiteBalanceOptions">
		<xs:sequence>
			<xs:element name="Mode" type="tt:WhiteBalanceMode" maxOccurs="unbounded"/>
			<xs:element name="YrGain" type="tt:FloatRange"/>
			<xs:element name="YbGain" type="tt:FloatRange"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FocusMove">
		<xs:sequence>
			<xs:element name="Absolute" type="tt:AbsoluteFocus" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Parameters for the absolute focus control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Relative" type="tt:RelativeFocus" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Parameters for the relative focus control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Continuous" type="tt:ContinuousFocus" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Parameter for the continuous focus control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AbsoluteFocus">
		<xs:sequence>
			<xs:element name="Position" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Position parameter for the absolute focus control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Speed" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Speed parameter for the absolute focus control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RelativeFocus">
		<xs:sequence>
			<xs:element name="Distance" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Distance parameter for the relative focus control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Speed" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Speed parameter for the relative focus control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ContinuousFocus">
		<xs:sequence>
			<xs:element name="Speed" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Speed parameter for the Continuous focus control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MoveOptions">
		<xs:sequence>
			<xs:element name="Absolute" type="tt:AbsoluteFocusOptions" minOccurs="0"/>
			<xs:element name="Relative" type="tt:RelativeFocusOptions" minOccurs="0"/>
			<xs:element name="Continuous" type="tt:ContinuousFocusOptions" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AbsoluteFocusOptions">
		<xs:sequence>
			<xs:element name="Position" type="tt:FloatRange">
				<xs:annotation>
					<xs:documentation>
				Valid ranges of the position.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Speed" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid ranges of the speed.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RelativeFocusOptions">
		<xs:sequence>
			<xs:element name="Distance" type="tt:FloatRange">
				<xs:annotation>
					<xs:documentation>
				Valid ranges of the distance.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Speed" type="tt:FloatRange">
				<xs:annotation>
					<xs:documentation>
				Valid ranges of the speed.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ContinuousFocusOptions">
		<xs:sequence>
			<xs:element name="Speed" type="tt:FloatRange">
				<xs:annotation>
					<xs:documentation>
				Valid ranges of the speed.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="ExposureMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="AUTO"/>
			<xs:enumeration value="MANUAL"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="Enabled">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ENABLED"/>
			<xs:enumeration value="DISABLED"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="WhiteBalanceMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="AUTO"/>
			<xs:enumeration value="MANUAL"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="IrCutFilterMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="ON"/>
			<xs:enumeration value="OFF"/>
			<xs:enumeration value="AUTO"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="WhiteBalance">
		<xs:sequence>
			<xs:element name="Mode" type="tt:WhiteBalanceMode">
				<xs:annotation>
					<xs:documentation>Auto whitebalancing mode (auto/manual).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CrGain" type="xs:float">
				<xs:annotation>
					<xs:documentation>Rgain (unitless).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CbGain" type="xs:float">
				<xs:annotation>
					<xs:documentation>Bgain (unitless).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--  End, Imaging Related Types   -->
	<!--===============================-->
	<!--===============================-->
	<!--      Imaging Version 2.0 Related Types    -->
	<!--===============================-->
	<xs:complexType name="ImagingStatus20">
		<xs:sequence>
			<xs:element name="FocusStatus20" type="tt:FocusStatus20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Status of focus.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImagingStatus20Extension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingStatus20Extension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FocusStatus20">
		<xs:sequence>
			<xs:element name="Position" type="xs:float">
				<xs:annotation>
					<xs:documentation>
				Status of focus position.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MoveStatus" type="tt:MoveStatus">
				<xs:annotation>
					<xs:documentation>
				Status of focus MoveStatus.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Error" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Error status of focus.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:FocusStatus20Extension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FocusStatus20Extension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingSettings20">
		<xs:annotation>
			<xs:documentation>Type describing the ImagingSettings of a VideoSource. The supported options and ranges can be obtained via the GetOptions command.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="BacklightCompensation" type="tt:BacklightCompensation20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Enabled/disabled BLC mode (on/off).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Brightness" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Image brightness (unit unspecified).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ColorSaturation" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Color saturation of the image (unit unspecified).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Contrast" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Contrast of the image (unit unspecified).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Exposure" type="tt:Exposure20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Exposure mode of the device.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Focus" type="tt:FocusConfiguration20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Focus configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IrCutFilter" type="tt:IrCutFilterMode" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Infrared Cutoff Filter settings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Sharpness" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Sharpness of the Video image.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WideDynamicRange" type="tt:WideDynamicRange20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>WDR settings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WhiteBalance" type="tt:WhiteBalance20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>White balance settings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImagingSettingsExtension20" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingSettingsExtension20">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="ImageStabilization" type="tt:ImageStabilization" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional element to configure Image Stabilization feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImagingSettingsExtension202" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingSettingsExtension202">
		<xs:sequence>
			<xs:element name="IrCutFilterAutoAdjustment" type="tt:IrCutFilterAutoAdjustment" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>An optional parameter applied to only auto mode to adjust timing of toggling Ir cut filter.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImagingSettingsExtension203" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingSettingsExtension203">
		<xs:sequence>
			<xs:element name="ToneCompensation" type="tt:ToneCompensation" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional element to configure Image Contrast Compensation.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Defogging" type="tt:Defogging" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional element to configure Image Defogging.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="NoiseReduction" type="tt:NoiseReduction" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional element to configure Image Noise Reduction.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImagingSettingsExtension204" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingSettingsExtension204">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImageStabilization">
		<xs:sequence>
			<xs:element name="Mode" type="tt:ImageStabilizationMode">
				<xs:annotation>
					<xs:documentation>Parameter to enable/disable Image Stabilization feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional level parameter (unit unspecified)</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImageStabilizationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImageStabilizationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="ImageStabilizationMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="OFF"/>
			<xs:enumeration value="ON"/>
			<xs:enumeration value="AUTO"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="IrCutFilterAutoAdjustment">
		<xs:sequence>
			<xs:element name="BoundaryType" type="xs:string">
				<xs:annotation>
					<xs:documentation>Specifies which boundaries to automatically toggle Ir cut filter following parameters are applied to. Its options shall be chosen from tt:IrCutFilterAutoBoundaryType.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BoundaryOffset" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Adjusts boundary exposure level for toggling Ir cut filter to on/off specified with unitless normalized value from +1.0 to -1.0. Zero is default and -1.0 is the darkest adjustment (Unitless).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ResponseTime" type="xs:duration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Delay time of toggling Ir cut filter to on/off after crossing of the boundary exposure levels.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:IrCutFilterAutoAdjustmentExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax" />
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IrCutFilterAutoAdjustmentExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded" />
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="IrCutFilterAutoBoundaryType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Common" />
			<xs:enumeration value="ToOn" />
			<xs:enumeration value="ToOff" />
			<xs:enumeration value="Extended" />
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="WideDynamicRange20">
		<xs:annotation>
			<xs:documentation>Type describing whether WDR mode is enabled or disabled (on/off).</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Mode" type="tt:WideDynamicMode">
				<xs:annotation>
					<xs:documentation>Wide dynamic range mode (on/off).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional level parameter (unit unspecified).</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="BacklightCompensation20">
		<xs:annotation>
			<xs:documentation>Type describing whether BLC mode is enabled or disabled (on/off).</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Mode" type="tt:BacklightCompensationMode">
				<xs:annotation>
					<xs:documentation>Backlight compensation mode (on/off).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional level parameter (unit unspecified).</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Exposure20">
		<xs:annotation>
			<xs:documentation>Type describing the exposure settings.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Mode" type="tt:ExposureMode">
				<xs:annotation>
					<xs:documentation>
				Exposure Mode
				<ul>
							<li>Auto  Enabled the exposure algorithm on the device.</li>
							<li>Manual  Disabled exposure algorithm on the device.</li>
						</ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Priority" type="tt:ExposurePriority" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				The exposure priority mode (low noise/framerate).
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Window" type="tt:Rectangle" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Rectangular exposure mask.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MinExposureTime" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Minimum value of exposure time range allowed to be used by the algorithm.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxExposureTime" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Maximum value of exposure time range allowed to be used by the algorithm.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MinGain" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Minimum value of the sensor gain range that is allowed to be used by the algorithm.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxGain" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Maximum value of the sensor gain range that is allowed to be used by the algorithm.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MinIris" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Minimum value of the iris range allowed to be used by the algorithm.  0dB maps to a fully opened iris and positive values map to higher attenuation.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxIris" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Maximum value of the iris range allowed to be used by the algorithm. 0dB maps to a fully opened iris and positive values map to higher attenuation.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ExposureTime" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				The fixed exposure time used by the image sensor (&#956;s).
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Gain" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				The fixed gain used by the image sensor (dB).
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Iris" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				The fixed attenuation of input light affected by the iris (dB). 0dB maps to a fully opened iris and positive values map to higher attenuation.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ToneCompensation">
		<xs:sequence>
			<xs:element name="Mode" type="xs:string">
				<xs:annotation>
					<xs:documentation>Parameter to enable/disable or automatic ToneCompensation feature. Its options shall be chosen from tt:ToneCompensationMode Type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional level parameter specified with unitless normalized value from 0.0 to +1.0.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ToneCompensationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ToneCompensationExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded" />
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="ToneCompensationMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="OFF"/>
			<xs:enumeration value="ON"/>
			<xs:enumeration value="AUTO"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="Defogging">
		<xs:sequence>
			<xs:element name="Mode" type="xs:string">
				<xs:annotation>
					<xs:documentation>Parameter to enable/disable or automatic Defogging feature. Its options shall be chosen from tt:DefoggingMode Type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional level parameter specified with unitless normalized value from 0.0 to +1.0.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:DefoggingExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DefoggingExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded" />   <!-- first ONVIF then Vendor -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="DefoggingMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="OFF"/>
			<xs:enumeration value="ON"/>
			<xs:enumeration value="AUTO"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="NoiseReduction">
		<xs:sequence>
			<xs:element name="Level" type="xs:float">
				<xs:annotation>
					<xs:documentation>Level parameter specified with unitless normalized value from 0.0 to +1.0. Level=0 means no noise reduction or minimal noise reduction.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded" />   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingOptions20">
		<xs:sequence>
			<xs:element name="BacklightCompensation" type="tt:BacklightCompensationOptions20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of Backlight Compensation.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Brightness" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of Brightness.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ColorSaturation" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of Color Saturation.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Contrast" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of Contrast.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Exposure" type="tt:ExposureOptions20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of Exposure.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Focus" type="tt:FocusOptions20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of Focus.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IrCutFilterModes" type="tt:IrCutFilterMode" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
				Valid range of IrCutFilterModes.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Sharpness" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of Sharpness.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WideDynamicRange" type="tt:WideDynamicRangeOptions20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of WideDynamicRange.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="WhiteBalance" type="tt:WhiteBalanceOptions20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of WhiteBalance.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImagingOptions20Extension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingOptions20Extension">
		<xs:sequence>
			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="ImageStabilization" type="tt:ImageStabilizationOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Options of parameters for Image Stabilization feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImagingOptions20Extension2" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingOptions20Extension2">
		<xs:sequence>
			<xs:element name="IrCutFilterAutoAdjustment" type="tt:IrCutFilterAutoAdjustmentOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Options of parameters for adjustment of Ir cut filter auto mode.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImagingOptions20Extension3" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingOptions20Extension3">
		<xs:sequence>
			<xs:element name="ToneCompensationOptions" type="tt:ToneCompensationOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Options of parameters for Tone Compensation feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DefoggingOptions" type="tt:DefoggingOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Options of parameters for Defogging feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="NoiseReductionOptions" type="tt:NoiseReductionOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Options of parameter for Noise Reduction feature.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImagingOptions20Extension4" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImagingOptions20Extension4">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImageStabilizationOptions">
		<xs:sequence>
			<xs:element name="Mode" type="tt:ImageStabilizationMode" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Supported options of Image Stabilization mode parameter.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Valid range of the Image Stabilization.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ImageStabilizationOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ImageStabilizationOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IrCutFilterAutoAdjustmentOptions">
		<xs:sequence>
			<xs:element name="BoundaryType" type="xs:string" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Supported options of boundary types for adjustment of Ir cut filter auto mode. The opptions shall be chosen from tt:IrCutFilterAutoBoundaryType. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BoundaryOffset" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Indicates whether or not boundary offset for toggling Ir cut filter is supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ResponseTimeRange" type="tt:DurationRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Supported range of delay time for toggling Ir cut filter.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:IrCutFilterAutoAdjustmentOptionsExtension" minOccurs="0" />
		</xs:sequence>
		<xs:anyAttribute processContents="lax" />
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="IrCutFilterAutoAdjustmentOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded" />
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="WideDynamicRangeOptions20">
		<xs:sequence>
			<xs:element name="Mode" type="tt:WideDynamicMode" maxOccurs="unbounded"/>
			<xs:element name="Level" type="tt:FloatRange" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="BacklightCompensationOptions20">
		<xs:sequence>
			<xs:element name="Mode" type="tt:BacklightCompensationMode" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
				'ON' or 'OFF'
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Level range of BacklightCompensation.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ExposureOptions20">
		<xs:sequence>
			<xs:element name="Mode" type="tt:ExposureMode" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
				Exposure Mode
				<ul>
							<li>Auto  Enabled the exposure algorithm on the device.</li>
							<li>Manual  Disabled exposure algorithm on the device.</li>
						</ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Priority" type="tt:ExposurePriority" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
				The exposure priority mode (low noise/framerate).
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MinExposureTime" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of the Minimum ExposureTime.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxExposureTime" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of the Maximum ExposureTime.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MinGain" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of the Minimum Gain.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxGain" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of the Maximum Gain.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MinIris" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of the Minimum Iris.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxIris" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of the Maximum Iris.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ExposureTime" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of the ExposureTime.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Gain" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of the Gain.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Iris" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid range of the Iris.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MoveOptions20">
		<xs:sequence>
			<xs:element name="Absolute" type="tt:AbsoluteFocusOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid ranges for the absolute control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Relative" type="tt:RelativeFocusOptions20" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid ranges for the relative control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Continuous" type="tt:ContinuousFocusOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid ranges for the continuous control.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RelativeFocusOptions20">
		<xs:sequence>
			<xs:element name="Distance" type="tt:FloatRange">
				<xs:annotation>
					<xs:documentation>
				Valid ranges of the distance.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Speed" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Valid ranges of the speed.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="WhiteBalance20">
		<xs:sequence>
			<xs:element name="Mode" type="tt:WhiteBalanceMode">
				<xs:annotation>
					<xs:documentation>
				'AUTO' or 'MANUAL'
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CrGain" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Rgain (unitless).
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CbGain" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
				Bgain (unitless).
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:WhiteBalance20Extension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="WhiteBalance20Extension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FocusConfiguration20">
		<xs:sequence>
			<xs:element name="AutoFocusMode" type="tt:AutoFocusMode">
				<xs:annotation>
					<xs:documentation>
						Mode of auto focus.
						<ul>
							<li>AUTO - The device automatically adjusts focus.</li>
							<li>MANUAL - The device does not automatically adjust focus.</li>
						</ul>
						Note: for devices supporting both manual and auto operation at the same time manual operation may be supported even if the Mode parameter is set to Auto.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DefaultSpeed" type="xs:float" minOccurs="0"/>
			<xs:element name="NearLimit" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Parameter to set autofocus near limit (unit: meter).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FarLimit" type="xs:float" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Parameter to set autofocus far limit (unit: meter).</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:FocusConfiguration20Extension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="AFMode" type="tt:StringAttrList">
			<xs:annotation>
				<xs:documentation>Zero or more modes as defined in enumeration tt:AFModes.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FocusConfiguration20Extension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="WhiteBalanceOptions20">
		<xs:sequence>
			<xs:element name="Mode" type="tt:WhiteBalanceMode" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
				Mode of WhiteBalance.
				<ul>
							<li>AUTO</li>
							<li>MANUAL</li>
						</ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="YrGain" type="tt:FloatRange" minOccurs="0"/>
			<xs:element name="YbGain" type="tt:FloatRange" minOccurs="0"/>
			<xs:element name="Extension" type="tt:WhiteBalanceOptions20Extension" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="WhiteBalanceOptions20Extension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FocusOptions20">
		<xs:sequence>
			<xs:element name="AutoFocusModes" type="tt:AutoFocusMode" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
					Supported modes for auto focus.
					<ul>
						<li>AUTO - The device supports automatic focus adjustment.</li>
						<li>MANUAL - The device supports manual focus adjustment.</li>
						</ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DefaultSpeed" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
					Valid range of DefaultSpeed.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="NearLimit" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
					Valid range of NearLimit.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FarLimit" type="tt:FloatRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
					Valid range of FarLimit.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:FocusOptions20Extension" minOccurs="0"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FocusOptions20Extension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
			<xs:element name="AFModes" type="tt:StringAttrList"  minOccurs="0">
				<xs:annotation>
					<xs:documentation>Supported options for auto focus. Options shall be chosen from tt:AFModes.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ToneCompensationOptions">
		<xs:sequence>
			<xs:element name="Mode" type="xs:string" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Supported options for Tone Compensation mode. Its options shall be chosen from tt:ToneCompensationMode Type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not support Level parameter for Tone Compensation.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded" />   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="DefoggingOptions">
		<xs:sequence>
			<xs:element name="Mode" type="xs:string" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Supported options for Defogging mode. Its options shall be chosen from tt:DefoggingMode Type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Level" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not support Level parameter for Defogging.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded" />   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="NoiseReductionOptions">
		<xs:sequence>
			<xs:element name="Level" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not support Level parameter for NoiseReduction.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded" />   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--===============================-->
	<!--  End, Imaging Version 2.0 Related Types   -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--  Event and Analytics Types    -->
	<!--===============================-->
	<xs:simpleType name="ImageSendingType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Embedded"/>
			<xs:enumeration value="LocalStorage"/>
			<xs:enumeration value="RemoteStorage"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="PropertyOperation">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Initialized"/>
			<xs:enumeration value="Deleted"/>
			<xs:enumeration value="Changed"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:element name="Message">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Source" type="tt:ItemList" minOccurs="0">
					<xs:annotation>
						<xs:documentation>Token value pairs that triggered this message. Typically only one item is present.</xs:documentation>
					</xs:annotation>
				</xs:element>
				<xs:element name="Key" type="tt:ItemList" minOccurs="0"/>
				<xs:element name="Data" type="tt:ItemList" minOccurs="0"/>
				<xs:element name="Extension" type="tt:MessageExtension" minOccurs="0"/>
			</xs:sequence>
			<xs:attribute name="UtcTime" type="xs:dateTime" use="required"/>
			<xs:attribute name="PropertyOperation" type="tt:PropertyOperation"/>
			<xs:anyAttribute processContents="lax"/>
		</xs:complexType>
	</xs:element>
	<!--===============================-->
	<xs:complexType name="MessageExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ItemList">
		<xs:sequence>
			<xs:element name="SimpleItem" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Value name pair as defined by the corresponding description.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:attribute name="Name" type="xs:string" use="required">
						<xs:annotation>
							<xs:documentation>Item name.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="Value" type="xs:anySimpleType" use="required">
						<xs:annotation>
							<xs:documentation>Item value. The type is defined in the corresponding description.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element name="ElementItem" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Complex value structure.</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:sequence>
						<xs:any namespace="##any" processContents="lax">
							<xs:annotation>
								<xs:documentation>XML tree contiaing the element value as defined in the corresponding description.</xs:documentation>
							</xs:annotation>
						</xs:any>
					</xs:sequence>
					<xs:attribute name="Name" type="xs:string" use="required">
						<xs:annotation>
							<xs:documentation>Item name.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element name="Extension" type="tt:ItemListExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ItemListExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--       Message Description     -->
	<!--===============================-->
	<xs:complexType name="MessageDescription">
		<xs:sequence>
			<xs:element name="Source" type="tt:ItemListDescription" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Set of tokens producing this message. The list may only contain SimpleItemDescription items.
					The set of tokens identify the component within the WS-Endpoint, which is responsible for the producing the message.<br/>
					For analytics events the token set shall include the VideoSourceConfigurationToken, the VideoAnalyticsConfigurationToken
					and the name of the analytics module or rule.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Key" type="tt:ItemListDescription" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Describes optional message payload parameters that may be used as key. E.g. object IDs of tracked objects are conveyed as key.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Data" type="tt:ItemListDescription" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Describes the payload of the message.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:MessageDescriptionExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="IsProperty" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Must be set to true when the described Message relates to a property. An alternative term of "property" is a "state" in contrast to a pure event, which contains relevant information for only a single point in time.<br/>Default is false.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MessageDescriptionExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ItemListDescription">
		<xs:annotation>
			<xs:documentation>
			Describes a list of items. Each item in the list shall have a unique name.
			The list is designed as linear structure without optional or unbounded elements.
			Use ElementItems only when complex structures are inevitable.
		</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="SimpleItemDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Description of a simple item. The type must be of cathegory simpleType (xs:string, xs:integer, xs:float, ...).</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:attribute name="Name" type="xs:string" use="required">
						<xs:annotation>
							<xs:documentation>Item name. Must be unique within a list.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="Type" type="xs:QName" use="required"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="ElementItemDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
            Description of a complex type. The Type must reference a defined type.
          </xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:attribute name="Name" type="xs:string" use="required">
						<xs:annotation>
							<xs:documentation>Item name. Must be unique within a list.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="Type" type="xs:QName" use="required">
						<xs:annotation>
							<xs:documentation>The type of the item. The Type must reference a defined type.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
				</xs:complexType>
			</xs:element>
			<xs:element name="Extension" type="tt:ItemListDescriptionExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ItemListDescriptionExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Polyline">
		<xs:sequence>
			<xs:element name="Point" type="tt:Vector" minOccurs="2" maxOccurs="unbounded"/>
		</xs:sequence>
<!--		<xs:attribute name='dummy'/> uncomment for compilation with Visual Studio --> 
	</xs:complexType>
	<xs:element name="Polyline" type="tt:Polyline"/>
	<!--===============================-->
	
	<xs:simpleType name="Direction">
		<xs:union memberTypes="tt:ExtendedDirection"/>
	</xs:simpleType>
	
	<xs:simpleType name="ExtendedDirection">
		<xs:annotation>
			<xs:documentation>Entering represents object coming into the polygon boundary.</xs:documentation>
			<xs:documentation>Exiting represents object going out of the polygon boundary.</xs:documentation>
			<xs:documentation>Approaching represents distance of object to camera sensor decreasing over time.</xs:documentation>
			<xs:documentation>Departing represents distance of object to camera sensor increasing over time.</xs:documentation>		
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="Left"/>
			<xs:enumeration value="Right"/>
			<xs:enumeration value="Any"/>
			<!-- Add new values -->
			<xs:enumeration value="Entering"/>
			<xs:enumeration value="Exiting"/>
			<xs:enumeration value="Approaching"/>
			<xs:enumeration value="Departing"/>
		</xs:restriction>
	</xs:simpleType>
	
	<!--    Analytics Configuration    -->
	<!--===============================-->
	<xs:complexType name="AnalyticsEngineConfiguration">
		<xs:sequence>
			<xs:element name="AnalyticsModule" type="tt:Config" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:AnalyticsEngineConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsEngineConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RuleEngineConfiguration">
		<xs:sequence>
			<xs:element name="Rule" type="tt:Config" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:RuleEngineConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RuleEngineConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Config">
		<xs:sequence>
			<xs:element name="Parameters" type="tt:ItemList">
				<xs:annotation>
					<xs:documentation>List of configuration parameters as defined in the corresponding description.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="Name" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>Name of the configuration.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Type" type="xs:QName" use="required">
			<xs:annotation>
				<xs:documentation>The Type attribute specifies the type of rule and shall be equal to value of one of Name attributes of ConfigDescription elements returned by GetSupportedRules and GetSupportedAnalyticsModules command.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ConfigDescription">
		<xs:sequence>
			<xs:element name="Parameters" type="tt:ItemListDescription">
				<xs:annotation>
					<xs:documentation>
						List describing the configuration parameters. The names of the parameters must be unique. If possible SimpleItems
						should be used to transport the information to ease parsing of dynamically defined messages by a client
						application.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Messages" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
						The analytics modules and rule engine produce Events, which must be listed within the Analytics Module Description. In order to do so
						the structure of the Message is defined and consists of three groups: Source, Key, and Data. It is recommended to use SimpleItemDescriptions wherever applicable.
						The name of all Items must be unique within all Items contained in any group of this Message.
						Depending on the component multiple parameters or none may be needed to identify the component uniquely.
					</xs:documentation>
				</xs:annotation>
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="tt:MessageDescription">
							<xs:sequence>
								<xs:element name="ParentTopic" type="xs:string">
									<xs:annotation>
										<xs:documentation>
											The topic of the message. For historical reason the element is named ParentTopic, but the full topic is expected.
										</xs:documentation>
									</xs:annotation>
								</xs:element>
							</xs:sequence>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="Extension" type="tt:ConfigDescriptionExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Name" type="xs:QName" use="required">
			<xs:annotation>
				<xs:documentation>The Name attribute (e.g. "tt::LineDetector") uniquely identifies the type of rule, not a type definition in a schema.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="fixed" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>The fixed attribute signals that it is not allowed to add or remove this type of configuration.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="maxInstances" type="xs:integer">
			<xs:annotation>
				<xs:documentation>The maxInstances attribute signals the maximum number of instances per configuration.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ConfigDescriptionExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SupportedRules">
		<xs:sequence>
			<xs:element name="RuleContentSchemaLocation" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Lists the location of all schemas that are referenced in the rules.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RuleDescription" type="tt:ConfigDescription" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of rules supported by the Video Analytics configuration..</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:SupportedRulesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Limit" type="xs:int">
			<xs:annotation>
				<xs:documentation>Maximum number of concurrent instances.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SupportedRulesExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SupportedAnalyticsModules">
		<xs:sequence>
			<xs:element name="AnalyticsModuleContentSchemaLocation" type="xs:anyURI" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>It optionally contains a list of URLs that provide the location of schema files.
					These schema files describe the types and elements used in the analytics module descriptions.
					Analytics module descriptions that reference types or elements imported from any ONVIF defined schema files
					need not explicitly list those schema files.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AnalyticsModuleDescription" type="tt:ConfigDescription" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:SupportedAnalyticsModulesExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="Limit" type="xs:int">
			<xs:annotation>
				<xs:documentation>Maximum number of concurrent instances.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SupportedAnalyticsModulesExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MotionExpression">
		<xs:sequence>
			<xs:element name="Expression" type="xs:string">
				<xs:annotation>
					<xs:documentation>Motion Expression data structure contains motion expression which is based on Scene Descriptor schema with XPATH syntax. The Type argument could allow introduction of different dialects </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:attribute name="Type" type="xs:string"/>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MotionExpressionConfiguration">
		<xs:sequence>
			<xs:element name="MotionExpression" type="tt:MotionExpression">
				<xs:annotation>
					<xs:documentation>Contains Rule MotionExpression configuration</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="CellLayout">
		<xs:sequence>
			<xs:element name="Transformation" type="tt:Transformation">
				<xs:annotation>
					<xs:documentation>Mapping of the cell grid to the Video frame. The cell grid is starting from the upper left corner and x dimension is going from left to right and the y dimension from up to down.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:attribute name="Columns" type="xs:integer" use="required">
			<xs:annotation>
				<xs:documentation>Number of columns of the cell grid (x dimension)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="Rows" type="xs:integer" use="required">
			<xs:annotation>
				<xs:documentation>Number of rows of the cell grid (y dimension)</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--End, Event and Analytics Types -->
	<!--===============================-->
	<!--===============================-->
	<!--      Display Related Types  -->
	<!--===============================-->
	<xs:complexType name="PaneConfiguration">
		<xs:annotation>
			<xs:documentation>Configuration of the streaming and coding settings of a Video window.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="PaneName" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional name of the pane configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AudioOutputToken" type="tt:ReferenceToken" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the device has audio outputs, this element contains a pointer to the audio output that is associated with the pane. A client
can retrieve the available audio outputs of a device using the GetAudioOutputs command of the DeviceIO service.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AudioSourceToken" type="tt:ReferenceToken" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the device has audio sources, this element contains a pointer to the audio source that is associated with this pane.
The audio connection from a decoder device to the NVT is established using the backchannel mechanism. A client can retrieve the available audio sources of a device using the GetAudioSources command of the
DeviceIO service.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AudioEncoderConfiguration" type="tt:AudioEncoderConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The configuration of the audio encoder including codec, bitrate
and sample rate. </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ReceiverToken" type="tt:ReferenceToken" minOccurs="0">
				<xs:annotation>
					<xs:documentation>A pointer to a Receiver that has the necessary information to receive
				data from a Transmitter. This Receiver can be connected and the network video decoder displays the received data on the specified outputs. A client can retrieve the available Receivers using the
				GetReceivers command of the Receiver Service.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Token" type="tt:ReferenceToken">
				<xs:annotation>
					<xs:documentation>A unique identifier in the display device.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PaneLayout">
		<xs:annotation>
			<xs:documentation>A pane layout describes one Video window of a display. It links a pane configuration to a region of the screen.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Pane" type="tt:ReferenceToken">
				<xs:annotation>
					<xs:documentation>Reference to the configuration of the streaming and coding parameters.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Area" type="tt:Rectangle">
				<xs:annotation>
					<xs:documentation>Describes the location and size of the area on the monitor. The area coordinate values are espressed in normalized units [-1.0, 1.0].</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="Layout">
		<xs:annotation>
			<xs:documentation>A layout describes a set of Video windows that are displayed simultaniously on a display. </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="PaneLayout" type="tt:PaneLayout" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of panes assembling the display layout.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:LayoutExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="LayoutExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="CodingCapabilities">
		<xs:annotation>
			<xs:documentation>This type contains the Audio and Video coding capabilities of a display service.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="AudioEncodingCapabilities" type="tt:AudioEncoderConfigurationOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the device supports audio encoding this section describes the supported codecs and their configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AudioDecodingCapabilities" type="tt:AudioDecoderConfigurationOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the device supports audio decoding this section describes the supported codecs and their settings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VideoDecodingCapabilities" type="tt:VideoDecoderConfigurationOptions">
				<xs:annotation>
					<xs:documentation>This section describes the supported video codesc and their configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="LayoutOptions">
		<xs:annotation>
			<xs:documentation>The options supported for a display layout.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="PaneLayoutOptions" type="tt:PaneLayoutOptions" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Lists the possible Pane Layouts of the Video Output</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:LayoutOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="LayoutOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PaneLayoutOptions">
		<xs:annotation>
			<xs:documentation>Description of a pane layout describing a complete display layout.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Area" type="tt:Rectangle" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of areas assembling a layout. Coordinate values are in the range [-1.0, 1.0].</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:PaneOptionExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PaneOptionExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<!--      End, Display Related Types  -->
	<!--===============================-->
	<!--===============================-->
	<!--   Receiver Types              -->
	<!--===============================-->
	<xs:complexType name="Receiver">
		<xs:annotation>
			<xs:documentation>
			Description of a receiver, including its token and configuration.
		</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Token" type="tt:ReferenceToken">
				<xs:annotation>
					<xs:documentation>Unique identifier of the receiver.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Configuration" type="tt:ReceiverConfiguration">
				<xs:annotation>
					<xs:documentation>Describes the configuration of the receiver.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ReceiverConfiguration">
		<xs:annotation>
			<xs:documentation>
			Describes the configuration of a receiver.
		</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Mode" type="tt:ReceiverMode">
				<xs:annotation>
					<xs:documentation>The following connection modes are defined:</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MediaUri" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>Details of the URI to which the receiver should connect.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StreamSetup" type="tt:StreamSetup">
				<xs:annotation>
					<xs:documentation>Stream connection parameters.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="ReceiverMode">
		<xs:annotation>
			<xs:documentation>
			Specifies a receiver connection mode.
		</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="AutoConnect">
				<xs:annotation>
					<xs:documentation>The receiver connects on demand, as required by consumers of the media streams.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AlwaysConnect">
				<xs:annotation>
					<xs:documentation>The receiver attempts to maintain a persistent connection to the configured endpoint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="NeverConnect">
				<xs:annotation>
					<xs:documentation>The receiver does not attempt to connect.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Unknown">
				<xs:annotation>
					<xs:documentation>This case should never happen.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="ReceiverState">
		<xs:annotation>
			<xs:documentation>
			Specifies the current connection state of the receiver.
		</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="NotConnected">
				<xs:annotation>
					<xs:documentation>The receiver is not connected.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Connecting">
				<xs:annotation>
					<xs:documentation>The receiver is attempting to connect.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Connected">
				<xs:annotation>
					<xs:documentation>The receiver is connected.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Unknown">
				<xs:annotation>
					<xs:documentation>This case should never happen.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="ReceiverStateInformation">
		<xs:annotation>
			<xs:documentation>
			Contains information about a receiver's current state.
		</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="State" type="tt:ReceiverState">
				<xs:annotation>
					<xs:documentation>The connection state of the receiver may have one of the following states: </xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AutoCreated" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates whether or not the receiver was created automatically.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--   End, Receiver Types         					  -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--         Storage Types         -->
	<!--===============================-->
	<xs:simpleType name="ReceiverReference">
		<xs:restriction base="tt:ReferenceToken"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="RecordingReference">
		<xs:restriction base="tt:ReferenceToken"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="SourceReference">
		<xs:sequence>
			<xs:element name="Token" type="tt:ReferenceToken"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:attribute name="Type" type="xs:anyURI" use="optional" default="http://www.onvif.org/ver10/schema/Receiver"/>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="TrackReference">
		<xs:restriction base="tt:ReferenceToken"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="Description">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="DateTimeRange">
		<xs:sequence>
			<xs:element name="From" type="xs:dateTime"/>
			<xs:element name="Until" type="xs:dateTime"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingSummary">
		<xs:sequence>
			<xs:element name="DataFrom" type="xs:dateTime">
				<xs:annotation>
					<xs:documentation>The earliest point in time where there is recorded data on the device.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DataUntil" type="xs:dateTime">
				<xs:annotation>
					<xs:documentation>The most recent point in time where there is recorded data on the device.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="NumberRecordings" type="xs:int">
				<xs:annotation>
					<xs:documentation>The device contains this many recordings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SearchScope">
		<xs:annotation>
			<xs:documentation>A structure for defining a limited scope when searching in recorded data.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="IncludedSources" type="tt:SourceReference" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A list of sources that are included in the scope. If this list is included, only data from one of these sources shall be searched.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="IncludedRecordings" type="tt:RecordingReference" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A list of recordings that are included in the scope. If this list is included, only data from one of these recordings shall be searched.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RecordingInformationFilter" type="tt:XPathExpression" minOccurs="0">
				<xs:annotation>
					<xs:documentation>An xpath expression used to specify what recordings to search. Only those recordings with an RecordingInformation structure that matches the filter shall be searched.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:SearchScopeExtension" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Extension point</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SearchScopeExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="EventFilter">
		<xs:complexContent>
			<xs:extension base="wsnt:FilterType">
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="PTZPositionFilter">
		<xs:sequence>
			<xs:element name="MinPosition" type="tt:PTZVector">
				<xs:annotation>
					<xs:documentation>The lower boundary of the PTZ volume to look for.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaxPosition" type="tt:PTZVector">
				<xs:annotation>
					<xs:documentation>The upper boundary of the PTZ volume to look for.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EnterOrExit" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>If true, search for when entering the specified PTZ volume.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MetadataFilter">
		<xs:sequence>
			<xs:element name="MetadataStreamFilter" type="tt:XPathExpression"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="XPathExpression">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="FindRecordingResultList">
		<xs:sequence>
			<xs:element name="SearchState" type="tt:SearchState">
				<xs:annotation>
					<xs:documentation>The state of the search when the result is returned. Indicates if there can be more results, or if the search is completed.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RecordingInformation" type="tt:RecordingInformation" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A RecordingInformation structure for each found recording matching the search.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FindEventResultList">
		<xs:sequence>
			<xs:element name="SearchState" type="tt:SearchState">
				<xs:annotation>
					<xs:documentation>The state of the search when the result is returned. Indicates if there can be more results, or if the search is completed.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Result" type="tt:FindEventResult" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A FindEventResult structure for each found event matching the search.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FindEventResult">
		<xs:sequence>
			<xs:element name="RecordingToken" type="tt:RecordingReference">
				<xs:annotation>
					<xs:documentation>The recording where this event was found. Empty string if no recording is associated with this event.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TrackToken" type="tt:TrackReference">
				<xs:annotation>
					<xs:documentation>A reference to the track where this event was found. Empty string if no track is associated with this event.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Time" type="xs:dateTime">
				<xs:annotation>
					<xs:documentation>The time when the event occured.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Event" type="wsnt:NotificationMessageHolderType">
				<xs:annotation>
					<xs:documentation>The description of the event.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="StartStateEvent" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>If true, indicates that the event is a virtual event generated for this particular search session to give the state of a property at the start time of the search.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FindPTZPositionResultList">
		<xs:sequence>
			<xs:element name="SearchState" type="tt:SearchState">
				<xs:annotation>
					<xs:documentation>The state of the search when the result is returned. Indicates if there can be more results, or if the search is completed.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Result" type="tt:FindPTZPositionResult" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A FindPTZPositionResult structure for each found PTZ position matching the search.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FindPTZPositionResult">
		<xs:sequence>
			<xs:element name="RecordingToken" type="tt:RecordingReference">
				<xs:annotation>
					<xs:documentation>A reference to the recording containing the PTZ position.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TrackToken" type="tt:TrackReference">
				<xs:annotation>
					<xs:documentation>A reference to the metadata track containing the PTZ position.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Time" type="xs:dateTime">
				<xs:annotation>
					<xs:documentation>The time when the PTZ position was valid.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Position" type="tt:PTZVector">
				<xs:annotation>
					<xs:documentation>The PTZ position.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FindMetadataResultList">
		<xs:sequence>
			<xs:element name="SearchState" type="tt:SearchState">
				<xs:annotation>
					<xs:documentation>The state of the search when the result is returned. Indicates if there can be more results, or if the search is completed.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Result" type="tt:FindMetadataResult" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A FindMetadataResult structure for each found set of Metadata matching the search.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="FindMetadataResult">
		<xs:sequence>
			<xs:element name="RecordingToken" type="tt:RecordingReference">
				<xs:annotation>
					<xs:documentation>A reference to the recording containing the metadata.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TrackToken" type="tt:TrackReference">
				<xs:annotation>
					<xs:documentation>A reference to the metadata track containing the matching metadata.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Time" type="xs:dateTime">
				<xs:annotation>
					<xs:documentation>The point in time when the matching metadata occurs in the metadata track.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="SearchState">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Queued">
				<xs:annotation>
					<xs:documentation>The search is queued and not yet started.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Searching">
				<xs:annotation>
					<xs:documentation>The search is underway and not yet completed.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Completed">
				<xs:annotation>
					<xs:documentation>The search has been completed and no new results will be found.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Unknown">
				<xs:annotation>
					<xs:documentation>The state of the search is unknown. (This is not a valid response from GetSearchState.)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="JobToken">
		<xs:restriction base="tt:ReferenceToken"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="RecordingInformation">
		<xs:sequence>
			<xs:element name="RecordingToken" type="tt:RecordingReference"/>
			<xs:element name="Source" type="tt:RecordingSourceInformation">
				<xs:annotation>
					<xs:documentation>
					Information about the source of the recording. This gives a description of where the data in the recording comes from. Since a single
					recording is intended to record related material, there is just one source. It is indicates the physical location or the
					major data source for the recording. Currently the recordingconfiguration cannot describe each individual data source.
				</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="EarliestRecording" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="LatestRecording" type="xs:dateTime" minOccurs="0"/>
			<xs:element name="Content" type="tt:Description"/>
			<xs:element name="Track" type="tt:TrackInformation" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Basic information about the track. Note that a track may represent a single contiguous time span or consist of multiple slices.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="RecordingStatus" type="tt:RecordingStatus"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingSourceInformation">
		<xs:annotation>
			<xs:documentation>
				A set of informative desciptions of a data source. The Search searvice allows a client to filter on recordings based on information in this structure.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="SourceId" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>
				Identifier for the source chosen by the client that creates the structure.
				This identifier is opaque to the device. Clients may use any type of URI for this field. A device shall support at least 128 characters.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Name" type="tt:Name">
				<xs:annotation>
					<xs:documentation>Informative user readable name of the source, e.g. "Camera23". A device shall support at least 20 characters.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Location" type="tt:Description">
				<xs:annotation>
					<xs:documentation>Informative description of the physical location of the source, e.g. the coordinates on a map.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Description" type="tt:Description">
				<xs:annotation>
					<xs:documentation>Informative description of the source.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Address" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>URI provided by the service supplying data to be recorded. A device shall support at least 128 characters.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="TargetFormat">
		<xs:restriction base="xs:string">
			<xs:enumeration value="MP4">
				<xs:annotation>
					<xs:documentation>
						MP4 files with all tracks in a single file.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="CMAF">
				<xs:annotation>
					<xs:documentation>
						CMAF compliant MP4 files with 1 track per file.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:simpleType name="EncryptionMode">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CENC">
				<xs:annotation>
					<xs:documentation>
						AES-CTR mode full sample and video NAL Subsample encryption, defined in ISO/IEC 23001-7.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="CBCS">
				<xs:annotation>
					<xs:documentation>
						AES-CBC mode partial video NAL pattern encryption, defined in ISO/IEC 23001-7.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="RecordingEncryption">
		<xs:sequence>
			<xs:element name="KID" type="xs:string">
				<xs:annotation>
					<xs:documentation>Key ID of the associated key for encryption.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Key" type="xs:hexBinary" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						Key for encrypting content.
						The device shall not include this parameter when reading.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Track" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
						Optional list of track tokens to be encrypted.
						If no track tokens are specified, all tracks are encrypted and no other encryption configurations shall exist for the recording.
						Each track shall only be contained in one encryption configuration.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:attribute name="Mode" type="xs:string" use="required">
			<xs:annotation>
				<xs:documentation>
					Mode of encryption.
					See tt:EncryptionMode for a list of definitions and capability trc:SupportedEncryptionModes for the supported encryption modes.
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingTargetConfiguration">
		<xs:sequence>
			<xs:element name="Storage" type="tt:ReferenceToken">
				<xs:annotation>
					<xs:documentation>Token of a storage configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Format" type="xs:string">
				<xs:annotation>
					<xs:documentation>
						Format of the recording.
						See tt:TargetFormat for a list of definitions and capability trc:SupportedTargetFormats for the supported formats.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Prefix" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Path prefix to be inserted in the object key.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Postfix" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Path postfix to be inserted in the object key.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SpanDuration" type="xs:duration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Maximum duration of a span.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="SegmentDuration" type="xs:duration">
				<xs:annotation>
					<xs:documentation>Maximum duration of a segment.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Encryption" type="tt:RecordingEncryption" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>
						Optional encryption configuration.
						See capability trc:EncryptionEntryLimit for the number of supported entries.
						By specifying multiple encryption entries per recording, different tracks can be encrypted with different configurations.
						Each track shall only be contained in one encryption configuration.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="RecordingStatus">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Initiated"/>
			<xs:enumeration value="Recording"/>
			<xs:enumeration value="Stopped"/>
			<xs:enumeration value="Removing"/>
			<xs:enumeration value="Removed"/>
			<xs:enumeration value="Unknown">
				<xs:annotation>
					<xs:documentation>This case should never happen.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="TrackInformation">
		<xs:sequence>
			<xs:element name="TrackToken" type="tt:TrackReference"/>
			<xs:element name="TrackType" type="tt:TrackType">
				<xs:annotation>
					<xs:documentation>Type of the track: "Video", "Audio" or "Metadata".
					The track shall only be able to hold data of that type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Description" type="tt:Description">
				<xs:annotation>
					<xs:documentation>Informative description of the contents of the track.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DataFrom" type="xs:dateTime">
				<xs:annotation>
					<xs:documentation>The start date and time of the oldest recorded data in the track.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DataTo" type="xs:dateTime">
				<xs:annotation>
					<xs:documentation>The stop date and time of the newest recorded data in the track.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="TrackType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Video"/>
			<xs:enumeration value="Audio"/>
			<xs:enumeration value="Metadata"/>
			<xs:enumeration value="Extended">
				<xs:annotation>
					<xs:documentation>Placeholder for future extension.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="MediaAttributes">
		<xs:annotation>
			<xs:documentation>A set of media attributes valid for a recording at a point in time or for a time interval.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RecordingToken" type="tt:RecordingReference">
				<xs:annotation>
					<xs:documentation>A reference to the recording that has these attributes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TrackAttributes" type="tt:TrackAttributes" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>A set of attributes for each track.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="From" type="xs:dateTime">
				<xs:annotation>
					<xs:documentation>The attributes are valid from this point in time in the recording.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Until" type="xs:dateTime">
				<xs:annotation>
					<xs:documentation>The attributes are valid until this point in time in the recording. Can be equal to 'From' to indicate that the attributes are only known to be valid for this particular point in time.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="TrackAttributes">
		<xs:sequence>
			<xs:element name="TrackInformation" type="tt:TrackInformation">
				<xs:annotation>
					<xs:documentation>The basic information about the track. Note that a track may represent a single contiguous time span or consist of multiple slices.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="VideoAttributes" type="tt:VideoAttributes" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the track is a video track, exactly one of this structure shall be present and contain the video attributes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AudioAttributes" type="tt:AudioAttributes" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the track is an audio track, exactly one of this structure shall be present and contain the audio attributes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MetadataAttributes" type="tt:MetadataAttributes" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If the track is an metadata track, exactly one of this structure shall be present and contain the metadata attributes.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:TrackAttributesExtension" minOccurs="0">
				<xs:annotation>
					<xs:documentation/>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="TrackAttributesExtension">
		<xs:sequence>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="VideoAttributes">
		<xs:sequence>
			<xs:element name="Bitrate" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Average bitrate in kbps.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Width" type="xs:int">
				<xs:annotation>
					<xs:documentation>The width of the video in pixels.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Height" type="xs:int">
				<xs:annotation>
					<xs:documentation>The height of the video in pixels.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Encoding" type="xs:string">
				<xs:annotation>
					<xs:documentation>Video encoding of the track.  Use value from tt:VideoEncoding for MPEG4. Otherwise use values from tt:VideoEncodingMimeNames and <a href="https://www.iana.org/assignments/media-types/media-types.xhtml#video"> IANA Media Types</a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Framerate" type="xs:float">
				<xs:annotation>
					<xs:documentation>Average framerate in frames per second.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AudioAttributes">
		<xs:sequence>
			<xs:element name="Bitrate" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The bitrate in kbps.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Encoding" type="xs:string">
				<xs:annotation>
					<xs:documentation>Audio encoding of the track.  Use values from tt:AudioEncoding for G711 and AAC. Otherwise use values from tt:AudioEncodingMimeNames and <a href="https://www.iana.org/assignments/media-types/media-types.xhtml#audio"> IANA Media Types</a>.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Samplerate" type="xs:int">
				<xs:annotation>
					<xs:documentation>The sample rate in kHz.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MetadataAttributes">
		<xs:sequence>
			<xs:element name="CanContainPTZ" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates that there can be PTZ data in the metadata track in the specified time interval.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CanContainAnalytics" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates that there can be analytics data in the metadata track in the specified time interval.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="CanContainNotifications" type="xs:boolean">
				<xs:annotation>
					<xs:documentation>Indicates that there can be notifications in the metadata track in the specified time interval.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="PtzSpaces" type="tt:StringAttrList">
			<xs:annotation>
				<xs:documentation>List of all PTZ spaces active for recording. Note that events are only recorded on position changes and the actual point of recording may not necessarily contain an event of the specified type. </xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--         RecordingService Types         		  -->
	<!--===============================-->
	<!--===============================-->
	<xs:simpleType name="RecordingJobReference">
		<xs:restriction base="tt:ReferenceToken"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="RecordingConfiguration">
		<xs:sequence>
			<xs:element name="Source" type="tt:RecordingSourceInformation">
				<xs:annotation>
					<xs:documentation>Information about the source of the recording.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Content" type="tt:Description">
				<xs:annotation>
					<xs:documentation>Informative description of the source.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="MaximumRetentionTime" type="xs:duration">
				<xs:annotation>
					<xs:documentation>Sspecifies the maximum time that data in any track within the
				recording shall be stored. The device shall delete any data older than the maximum retention
				time. Such data shall not be accessible anymore. If the MaximumRetentionPeriod is set to 0,
				the device shall not limit the retention time of stored data, except by resource constraints.
				Whatever the value of MaximumRetentionTime, the device may automatically delete
				recordings to free up storage space for new recordings.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Target" type="tt:RecordingTargetConfiguration" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional external storage target configuration.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="TrackConfiguration">
		<xs:sequence>
			<xs:element name="TrackType" type="tt:TrackType">
				<xs:annotation>
					<xs:documentation>Type of the track. It shall be equal to the strings Video,
				Audio or Metadata. The track shall only be able to hold data of that type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Description" type="tt:Description">
				<xs:annotation>
					<xs:documentation>Informative description of the track.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="GetRecordingsResponseItem">
		<xs:sequence>
			<xs:element name="RecordingToken" type="tt:RecordingReference">
				<xs:annotation>
					<xs:documentation>Token of the recording.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Configuration" type="tt:RecordingConfiguration">
				<xs:annotation>
					<xs:documentation>Configuration of the recording.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Tracks" type="tt:GetTracksResponseList">
				<xs:annotation>
					<xs:documentation>List of tracks.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="GetTracksResponseList">
		<xs:sequence>
			<xs:element name="Track" type="tt:GetTracksResponseItem" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Configuration of a track.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="GetTracksResponseItem">
		<xs:sequence>
			<xs:element name="TrackToken" type="tt:TrackReference">
				<xs:annotation>
					<xs:documentation>Token of the track.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Configuration" type="tt:TrackConfiguration">
				<xs:annotation>
					<xs:documentation>Configuration of the track.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingJobConfiguration">
		<xs:sequence>
			<xs:element name="RecordingToken" type="tt:RecordingReference">
				<xs:annotation>
					<xs:documentation>Identifies the recording to which this job shall store the received data.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Mode" type="tt:RecordingJobMode">
				<xs:annotation>
					<xs:documentation>The mode of the job. If it is idle, nothing shall happen. If it is active, the device shall try
				to obtain data from the receivers. A client shall use GetRecordingJobState to determine if data transfer is really taking place.<br/>
				The only valid values for Mode shall be Idle and Active.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Priority" type="xs:int">
				<xs:annotation>
					<xs:documentation>This shall be a non-negative number. If there are multiple recording jobs that store data to
				the same track, the device will only store the data for the recording job with the highest
				priority. The priority is specified per recording job, but the device shall determine the priority
				of each track individually. If there are two recording jobs with the same priority, the device
				shall record the data corresponding to the recording job that was activated the latest.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Source" type="tt:RecordingJobSource" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Source of the recording.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:RecordingJobConfigurationExtension" minOccurs="0"/>
			<xs:element name="EventFilter" type="tt:RecordingEventFilter" minOccurs="0">
				<xs:annotation><xs:documentation>Optional filter defining on which event condition a recording job gets active.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- reserved for ONVIF -->
		</xs:sequence>
		<xs:attribute name="ScheduleToken">
			<xs:annotation>
				<xs:documentation>This attribute adds an additional requirement for activating the recording job. 
				If this optional field is provided the job shall only record if the schedule exists and is active. 
				</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>

	<xs:complexType name="RecordingEventFilter">
		<xs:sequence>
			<xs:element name="Filter" maxOccurs="unbounded">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Topic" type="xs:string">
							<xs:annotation><xs:documentation>Topic filter as defined in section 9.6.3 of the ONVIF Core Specification.</xs:documentation></xs:annotation>
						</xs:element>
						<xs:element name="Source" type="xs:string" minOccurs="0">
							<xs:annotation><xs:documentation>Optional message source content filter as defined in section 9.4.4 of the ONVIF Core Specification.</xs:documentation></xs:annotation>
						</xs:element>
						<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then vendor -->
					</xs:sequence>
					<xs:anyAttribute processContents="lax"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="Before" type="xs:duration" minOccurs="0">
				<xs:annotation><xs:documentation>Optional timespan to record before the actual event condition became active.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:element name="After" type="xs:duration" minOccurs="0">
				<xs:annotation><xs:documentation>Optional timespan to record after the actual event condition becomes inactive.</xs:documentation></xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then vendor -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="RecordingJobMode">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="RecordingJobConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- Vendor only -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingJobSource">
		<xs:sequence>
			<xs:element name="SourceToken" type="tt:SourceReference" minOccurs="0">
				<xs:annotation>
					<xs:documentation>This field shall be a reference to the source of the data. The type of the source
				is determined by the attribute Type in the SourceToken structure. If Type is
				http://www.onvif.org/ver10/schema/Receiver, the token is a ReceiverReference. In this case
				the device shall receive the data over the network. If Type is
				http://www.onvif.org/ver10/schema/Profile, the token identifies a media profile, instructing the
				device to obtain data from a profile that exists on the local device.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="AutoCreateReceiver" type="xs:boolean" minOccurs="0">
				<xs:annotation>
					<xs:documentation>If this field is TRUE, and if the SourceToken is omitted, the device
				shall create a receiver object (through the receiver service) and assign the
				ReceiverReference to the SourceToken field. When retrieving the RecordingJobConfiguration
				from the device, the AutoCreateReceiver field shall never be present.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Tracks" type="tt:RecordingJobTrack" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of tracks associated with the recording.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:RecordingJobSourceExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingJobSourceExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingJobTrack">
		<xs:sequence>
			<xs:element name="SourceTag" type="xs:string">
				<xs:annotation>
					<xs:documentation>If the received RTSP stream contains multiple tracks of the same type, the
						SourceTag differentiates between those Tracks. This field can be ignored in case of recording a local source.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Destination" type="tt:TrackReference">
				<xs:annotation>
					<xs:documentation>The destination is the tracktoken of the track to which the device shall store the
				received data.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingJobStateInformation">
		<xs:sequence>
			<xs:element name="RecordingToken" type="tt:RecordingReference">
				<xs:annotation>
					<xs:documentation>Identification of the recording that the recording job records to.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="State" type="tt:RecordingJobState">
				<xs:annotation>
					<xs:documentation>Holds the aggregated state over the whole RecordingJobInformation structure.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Sources" type="tt:RecordingJobStateSource" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Identifies the data source of the recording job.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:RecordingJobStateInformationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingJobStateInformationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="RecordingJobState">
		<xs:restriction base="xs:string"/>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="RecordingJobStateSource">
		<xs:sequence>
			<xs:element name="SourceToken" type="tt:SourceReference">
				<xs:annotation>
					<xs:documentation>Identifies the data source of the recording job.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="State" type="tt:RecordingJobState">
				<xs:annotation>
					<xs:documentation>Holds the aggregated state over all substructures of RecordingJobStateSource.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Tracks" type="tt:RecordingJobStateTracks">
				<xs:annotation>
					<xs:documentation>List of track items.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingJobStateTracks">
		<xs:sequence>
			<xs:element name="Track" type="tt:RecordingJobStateTrack" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="RecordingJobStateTrack">
		<xs:sequence>
			<xs:element name="SourceTag" type="xs:string">
				<xs:annotation>
					<xs:documentation>Identifies the track of the data source that provides the data.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Destination" type="tt:TrackReference">
				<xs:annotation>
					<xs:documentation>Indicates the destination track.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Error" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optionally holds an implementation defined string value that describes the error.
				The string should be in the English language.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="State" type="tt:RecordingJobState">
				<xs:annotation>
					<xs:documentation>Provides the job state of the track. The valid
				values of state shall be Idle, Active and Error. If state equals Error, the Error field may be filled in with an implementation defined value.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="GetRecordingJobsResponseItem">
		<xs:sequence>
			<xs:element name="JobToken" type="tt:RecordingJobReference"/>
			<xs:element name="JobConfiguration" type="tt:RecordingJobConfiguration"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--         End, RecordingService Types         		  -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--         Replay Types         		  -->
	<!--===============================-->
	<xs:complexType name="ReplayConfiguration">
		<xs:annotation>
			<xs:documentation>
      Configuration parameters for the replay service.
    </xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="SessionTimeout" type="xs:duration">
				<xs:annotation>
					<xs:documentation>The RTSP session timeout.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--         End, Replay Types         		  -->
	<!--===============================-->
	<!--===============================-->
	<!--===============================-->
	<!--         Analytics Device Types         -->
	<!--===============================-->
	<xs:complexType name="AnalyticsEngine">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="AnalyticsEngineConfiguration" type="tt:AnalyticsDeviceEngineConfiguration"/>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsDeviceEngineConfiguration">
		<xs:sequence>
			<xs:element name="EngineConfiguration" type="tt:EngineConfiguration" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:AnalyticsDeviceEngineConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsDeviceEngineConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="EngineConfiguration">
		<xs:sequence>
			<xs:element name="VideoAnalyticsConfiguration" type="tt:VideoAnalyticsConfiguration"/>
			<xs:element name="AnalyticsEngineInputInfo" type="tt:AnalyticsEngineInputInfo"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsEngineInputInfo">
		<xs:sequence>
			<xs:element name="InputInfo" type="tt:Config" minOccurs="0"/>
			<xs:element name="Extension" type="tt:AnalyticsEngineInputInfoExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsEngineInputInfoExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsEngineInput">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="SourceIdentification" type="tt:SourceIdentification"/>
					<xs:element name="VideoInput" type="tt:VideoEncoderConfiguration"/>
					<xs:element name="MetadataInput" type="tt:MetadataInput"/>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SourceIdentification">
		<xs:sequence>
			<xs:element name="Name" type="xs:string"/>
			<xs:element name="Token" type="tt:ReferenceToken" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:SourceIdentificationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="SourceIdentificationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MetadataInput">
		<xs:sequence>
			<xs:element name="MetadataConfig" type="tt:Config" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:MetadataInputExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MetadataInputExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsEngineControl">
		<xs:complexContent>
			<xs:extension base="tt:ConfigurationEntity">
				<xs:sequence>
					<xs:element name="EngineToken" type="tt:ReferenceToken">
						<xs:annotation>
							<xs:documentation>Token of the analytics engine (AnalyticsEngine) being controlled.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="EngineConfigToken" type="tt:ReferenceToken">
						<xs:annotation>
							<xs:documentation>Token of the analytics engine configuration (VideoAnalyticsConfiguration) in effect.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="InputToken" type="tt:ReferenceToken" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Tokens of the input (AnalyticsEngineInput) configuration applied.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="ReceiverToken" type="tt:ReferenceToken" maxOccurs="unbounded">
						<xs:annotation>
							<xs:documentation>Tokens of the receiver providing media input data. The order of ReceiverToken shall exactly match the order of InputToken.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Multicast" type="tt:MulticastConfiguration" minOccurs="0"/>
					<xs:element name="Subscription" type="tt:Config"/>
					<xs:element name="Mode" type="tt:ModeOfOperation"/>
					<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="ModeOfOperation">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Idle"/>
			<xs:enumeration value="Active"/>
			<xs:enumeration value="Unknown">
				<xs:annotation>
					<xs:documentation>This case should never happen.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="AnalyticsStateInformation">
		<xs:sequence>
			<xs:element name="AnalyticsEngineControlToken" type="tt:ReferenceToken">
				<xs:annotation>
					<xs:documentation>Token of the control object whose status is requested.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="State" type="tt:AnalyticsState"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="AnalyticsState">
		<xs:sequence>
			<xs:element name="Error" type="xs:string" minOccurs="0"/>
			<xs:element name="State" type="xs:string"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<!--         End, Analytics Device Types         -->
	<!--===============================-->
	<!--=========================================-->
	<!--  Action event payload Types   -->
	<!--=========================================-->
	<!--===============================-->
	<xs:complexType name="ActionEngineEventPayload">
		<xs:annotation>
			<xs:documentation>Action Engine Event Payload data structure contains the information about the ONVIF command invocations. Since this event could be generated by other or proprietary actions, the command invocation specific fields are defined as optional and additional extension mechanism is provided for future or additional action definitions.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="RequestInfo" type="soapenv:Envelope" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>Request Message</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ResponseInfo" type="soapenv:Envelope" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>Response Message</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Fault" type="soapenv:Fault" minOccurs="0" maxOccurs="1">
				<xs:annotation>
					<xs:documentation>Fault Message</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:ActionEngineEventPayloadExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ActionEngineEventPayloadExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--=========================================-->
	<!--  End, Action event payload Types   -->
	<!--=========================================-->
        <!--=========================================-->
	<!--  Begin, Audio event types               -->
	<!--=========================================-->
	<!-- Old audio classification types, non-extensible. -->
	<xs:simpleType name="AudioClassType">
		<xs:annotation>
		<xs:documentation>
		  AudioClassType acceptable values are;
		   gun_shot, scream, glass_breaking, tire_screech
		</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="gun_shot"/>
			<xs:enumeration value="scream"/>
			<xs:enumeration value="glass_breaking"/>
			<xs:enumeration value="tire_screech"/>
		</xs:restriction>
	</xs:simpleType>

	<!-- New audio classification types, extensible, for documentation purpose only. -->
	<xs:simpleType name="AudioClassification">
		<xs:restriction base="xs:string">
			<xs:enumeration value="GunShot"/>
			<xs:enumeration value="Scream"/>
			<xs:enumeration value="GlassBreaking"/>
			<xs:enumeration value="TireScreech"/>
			<xs:enumeration value="Alarm"/>
		</xs:restriction>
	</xs:simpleType>

	<xs:complexType name="AudioClassCandidate">
	<xs:sequence>
		<xs:element name="Type" type="tt:AudioClassType">
			<xs:annotation>
			<xs:documentation>Indicates audio class label</xs:documentation>
			</xs:annotation>
		</xs:element> 
 		<xs:element name="Likelihood" type="xs:float">
			<xs:annotation>
			<xs:documentation>A likelihood/probability that the corresponding audio event belongs to this class. The sum of the likelihoods shall NOT exceed 1</xs:documentation>
			</xs:annotation>
		</xs:element>
		<xs:any namespace="##targetNamespace" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
	</xs:sequence>
	<xs:anyAttribute processContents="lax"/>
	</xs:complexType>

	<xs:complexType name="AudioClassDescriptor">
	<xs:sequence>
		<xs:element name="ClassCandidate" type="tt:AudioClassCandidate" minOccurs="0" maxOccurs="unbounded">
			<xs:annotation>
			<xs:documentation>Array of audio class label and class probability</xs:documentation>
			</xs:annotation>
		</xs:element>
		<xs:element name="Extension" type="tt:AudioClassDescriptorExtension" minOccurs="0"/>
	</xs:sequence>
	<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<xs:complexType name="AudioClassDescriptorExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--=========================================-->
	<!--  End, Audio event types                 -->
	<!--=========================================-->
	<!--=========================================-->
	<!--  Begin, Media event types               -->
	<!--=========================================-->
	<xs:complexType name="ActiveConnection">
		<xs:sequence>
			<xs:element name="CurrentBitrate" type="xs:float"/>
			<xs:element name="CurrentFps" type="xs:float"/>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ProfileStatus">
		<xs:sequence>
			<xs:element name="ActiveConnections" type="tt:ActiveConnection" minOccurs="0" maxOccurs="unbounded"/>
			<xs:element name="Extension" type="tt:ProfileStatusExtension" minOccurs="0" />
		</xs:sequence>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ProfileStatusExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--=========================================-->
	<!--  End, Media event types                 -->
	<!--=========================================-->
	<!--==================================-->
	<!--  Begin, OSD Device Types         -->
	<!--==================================-->
	<xs:complexType name="OSDReference">
		<xs:simpleContent>
			<xs:extension base="tt:ReferenceToken">
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:simpleContent>
	</xs:complexType>
	<!--===============================-->
	<xs:simpleType name="OSDType">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Text"/>
			<xs:enumeration value="Image"/>
			<xs:enumeration value="Extended"/>
		</xs:restriction>
	</xs:simpleType>
	<!--===============================-->
	<xs:complexType name="OSDPosConfiguration">
		<xs:sequence>
			<xs:element name="Type" type="xs:string">
				<xs:annotation>
					<xs:documentation>For OSD position type, following are the pre-defined: <ul><li>UpperLeft</li>
						<li>UpperRight</li>
						<li>LowerLeft</li>
						<li>LowerRight</li>
						<li>Custom</li></ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Pos" type="tt:Vector" minOccurs="0"/>
			<xs:element name="Extension" type="tt:OSDPosConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDPosConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDColor">
		<xs:annotation>
			<xs:documentation>The value range of "Transparent" could be defined by vendors only should follow this rule: the minimum value means non-transparent and the maximum value maens fully transparent.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Color" type="tt:Color"/>
		</xs:sequence>
		<xs:attribute name="Transparent" type="xs:int" use="optional"/>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDTextConfiguration">
		<xs:sequence>
			<xs:element name="Type" type="xs:string">
				<xs:annotation>
					<xs:documentation>
						The following OSD Text Type are defined:<ul>
							<li>Plain - The Plain type means the OSD is shown as a text string which defined in the "PlainText" item.</li>
							<li>Date - The Date type means the OSD is shown as a date, format of which should be present in the "DateFormat" item.</li>
							<li>Time - The Time type means the OSD is shown as a time, format of which should be present in the "TimeFormat" item.</li>
							<li>DateAndTime - The DateAndTime type means the OSD is shown as date and time, format of which should be present in the "DateFormat" and the "TimeFormat" item.</li>
						</ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DateFormat" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						List of supported OSD date formats. This element shall be present when the value of Type field has Date or DateAndTime. The following DateFormat are defined:<ul>
							<li>M/d/yyyy - e.g. 3/6/2013</li>
							<li>MM/dd/yyyy - e.g. 03/06/2013</li>
							<li>dd/MM/yyyy - e.g. 06/03/2013</li>
							<li>yyyy/MM/dd - e.g. 2013/03/06</li>
							<li>yyyy-MM-dd - e.g. 2013-06-03</li>
							<li>dddd, MMMM dd, yyyy - e.g. Wednesday, March 06, 2013</li>
							<li>MMMM dd, yyyy - e.g. March 06, 2013</li>
							<li>dd MMMM, yyyy - e.g. 06 March, 2013</li>
						</ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TimeFormat" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>
						List of supported OSD time formats. This element shall be present when the value of Type field has Time or DateAndTime. The following TimeFormat are defined:<ul>
							<li>h:mm:ss tt - e.g. 2:14:21 PM</li>
							<li>hh:mm:ss tt - e.g. 02:14:21 PM</li>
							<li>H:mm:ss - e.g. 14:14:21</li>
							<li>HH:mm:ss - e.g. 14:14:21</li>
						</ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FontSize" type="xs:int" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Font size of the text in pt.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FontColor" type="tt:OSDColor" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Font color of the text.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BackgroundColor" type="tt:OSDColor" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Background color of the text.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PlainText" type="xs:string" minOccurs="0">
				<xs:annotation>
					<xs:documentation>The content of text to be displayed.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:OSDTextConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="IsPersistentText" type="xs:boolean" use="optional">
			<xs:annotation><xs:documentation>This flag is applicable for Type Plain and defaults to true. When set to false the PlainText content will not be persistent across device reboots. </xs:documentation></xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDTextConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDImgConfiguration">
		<xs:sequence>
			<xs:element name="ImgPath" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>The URI of the image which to be displayed.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:OSDImgConfigurationExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDImgConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ColorspaceRange">
		<xs:sequence>
			<xs:element name="X" type="tt:FloatRange"/>
			<xs:element name="Y" type="tt:FloatRange"/>
			<xs:element name="Z" type="tt:FloatRange"/>
			<xs:element name="Colorspace" type="xs:anyURI">
				<xs:annotation>
					<xs:documentation>
						Acceptable values are the same as in tt:Color.
					</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="ColorOptions">
		<xs:annotation>
			<xs:documentation>
				Describe the colors supported. Either list each color or define the range of color values.
			</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="ColorList" type="tt:Color" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List the supported color.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ColorspaceRange" type="tt:ColorspaceRange" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>Define the range of color supported.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDColorOptions">
		<xs:annotation>
			<xs:documentation>Describe the option of the color and its transparency.</xs:documentation>
		</xs:annotation>
		<xs:sequence>
			<xs:element name="Color" type="tt:ColorOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Optional list of supported colors.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Transparent" type="tt:IntRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Range of the transparent level. Larger means more tranparent.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:OSDColorOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDColorOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDTextOptions">
		<xs:sequence>
			<xs:element name="Type" type="xs:string" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported OSD text type. When a device indicates the supported number relating to Text type in MaximumNumberOfOSDs, the type shall be presented.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FontSizeRange" type="tt:IntRange" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Range of the font size value.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="DateFormat" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported date format.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TimeFormat" type="xs:string" minOccurs="0" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of supported time format.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="FontColor" type="tt:OSDColorOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>List of supported font color.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="BackgroundColor" type="tt:OSDColorOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>List of supported background color.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:OSDTextOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDTextOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDImgOptions">
		<xs:sequence>
			<xs:element name="ImagePath" type="xs:anyURI" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List of available image URIs.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:OSDImgOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:attribute name="FormatsSupported" type="tt:StringAttrList">
			<xs:annotation>
				<xs:documentation>List of supported image MIME types, such as "image/png".</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MaxSize" type="xs:int">
			<xs:annotation>
				<xs:documentation>The maximum size (in bytes) of the image that can be uploaded.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MaxWidth" type="xs:int">
			<xs:annotation>
				<xs:documentation>The maximum width (in pixels) of the image that can be uploaded.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="MaxHeight" type="xs:int">
			<xs:annotation>
				<xs:documentation>The maximum height (in pixels) of the image that can be uploaded.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDImgOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDConfiguration">
		<xs:complexContent>
			<xs:extension base="tt:DeviceEntity">
				<xs:sequence>
					<xs:element name="VideoSourceConfigurationToken" type="tt:OSDReference">
						<xs:annotation>
							<xs:documentation>Reference to the video source configuration.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Type" type="tt:OSDType">
						<xs:annotation>
							<xs:documentation>Type of OSD.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Position" type="tt:OSDPosConfiguration">
						<xs:annotation>
							<xs:documentation>Position configuration of OSD.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="TextString" type="tt:OSDTextConfiguration" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Text configuration of OSD. It shall be present when the value of Type field is Text.</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Image" type="tt:OSDImgConfiguration" minOccurs="0">
						<xs:annotation>
							<xs:documentation>Image configuration of OSD. It shall be present when the value of Type field is Image</xs:documentation>
						</xs:annotation>
					</xs:element>
					<xs:element name="Extension" type="tt:OSDConfigurationExtension" minOccurs="0"/>
				</xs:sequence>
				<xs:anyAttribute processContents="lax"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDConfigurationExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="MaximumNumberOfOSDs">
		<xs:attribute name="Total" type="xs:int" use="required"/>
		<xs:attribute name="Image" type="xs:int"/>
		<xs:attribute name="PlainText" type="xs:int"/>
		<xs:attribute name="Date" type="xs:int"/>
		<xs:attribute name="Time" type="xs:int"/>
		<xs:attribute name="DateAndTime" type="xs:int"/>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDConfigurationOptions">
		<xs:sequence>
			<xs:element name="MaximumNumberOfOSDs" type="tt:MaximumNumberOfOSDs">
				<xs:annotation>
					<xs:documentation>The maximum number of OSD configurations supported for the specified video source configuration. If the configuration does not support OSDs, this value shall be zero and the Type and PositionOption elements are ignored. If a device limits the number of instances by OSDType, it shall indicate the supported number for each type via the related attribute.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Type" type="tt:OSDType" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List supported type of OSD configuration. When a device indicates the supported number for each types in MaximumNumberOfOSDs, related type shall be presented. A device shall return Option element relating to listed type.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="PositionOption" type="xs:string" maxOccurs="unbounded">
				<xs:annotation>
					<xs:documentation>List available OSD position type. Following are the pre-defined:<ul><li>UpperLeft</li>
						<li>UpperRight</li>
						<li>LowerLeft</li>
						<li>LowerRight</li>
						<li>Custom</li></ul>
					</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="TextOption" type="tt:OSDTextOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Option of the OSD text configuration. This element shall be returned if the device is signaling the support for Text.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="ImageOption" type="tt:OSDImgOptions" minOccurs="0">
				<xs:annotation>
					<xs:documentation>Option of the OSD image configuration. This element shall be returned if the device is signaling the support for Image.</xs:documentation>
				</xs:annotation>
			</xs:element>
			<xs:element name="Extension" type="tt:OSDConfigurationOptionsExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--===============================-->
	<xs:complexType name="OSDConfigurationOptionsExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--=========================================-->
	<!--  End, OSD Device Types                  -->
	<!--=========================================-->

	<!--=========================================-->
	<!--  Begin, StorageConfiguration            -->
	<!--=========================================-->
	<xs:complexType name="FileProgress">
    	<xs:sequence>
    		<xs:element name="FileName" type="xs:string">
    			<xs:annotation>
    				<xs:documentation>Exported file name</xs:documentation>
    			</xs:annotation>
    		</xs:element>
    		<xs:element name="Progress" type="xs:float">
    			<xs:annotation>
    				<xs:documentation>Normalized percentage completion for uploading the exported file</xs:documentation>
    			</xs:annotation>
    		</xs:element>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
    </xs:complexType>

	<xs:complexType name="ArrayOfFileProgress">
    	<xs:sequence>
    		<xs:element name="FileProgress" type="tt:FileProgress" minOccurs="0" maxOccurs="unbounded">
    			<xs:annotation>
    				<xs:documentation>Exported file name and export progress information</xs:documentation>
    			</xs:annotation>
    		</xs:element>
			<xs:element name="Extension" type="tt:ArrayOfFileProgressExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
    </xs:complexType>
	<xs:complexType name="ArrayOfFileProgressExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>

	<xs:complexType name="StorageReferencePath">
    	<xs:sequence>
    		<xs:element name="StorageToken" type="tt:ReferenceToken">
    			<xs:annotation>
    				<xs:documentation>identifier of an existing Storage Configuration.</xs:documentation>
    			</xs:annotation>
    		</xs:element>
    		<xs:element name="RelativePath" type="xs:string" minOccurs="0">
    			<xs:annotation>
    				<xs:documentation>gives the relative directory path on the storage</xs:documentation>
    			</xs:annotation>
    		</xs:element>
			<xs:element name="Extension" type="tt:StorageReferencePathExtension" minOccurs="0"/>
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
    </xs:complexType>
	<xs:complexType name="StorageReferencePathExtension">
		<xs:sequence>
			<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first Vendor then ONVIF -->
		</xs:sequence>
		<xs:anyAttribute processContents="lax"/>
	</xs:complexType>
	<!--=========================================-->
	<!--  End, StorageConfiguration              -->
	<!--=========================================-->
	
<xs:element name="PolygonOptions" type="tt:PolygonOptions"/>
 
<xs:complexType name="PolygonOptions">
	<xs:sequence>
		<xs:element name="RectangleOnly" type="xs:boolean" minOccurs="0">
			<xs:annotation>
				<xs:documentation>
True if the device supports defining a region only using Rectangle.
The rectangle points are still passed using a Polygon element if the device does not support polygon regions. In this case, the points provided in the Polygon element shall represent a rectangle.
				</xs:documentation>
			</xs:annotation>
		</xs:element>
		<xs:element name="VertexLimits" type="tt:IntRange" minOccurs="0">
			<xs:annotation>
				<xs:documentation>
Provides the minimum and maximum number of points that can be defined in the Polygon.
If RectangleOnly is not set to true, this parameter is required.
				</xs:documentation>
			</xs:annotation>
		</xs:element>
		<xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>   <!-- first ONVIF then Vendor -->
	</xs:sequence>
	<xs:anyAttribute processContents="lax"/>
</xs:complexType>

</xs:schema>
</file>

<file path="wsdl/vendor/soap-envelope.xsd">
<!-- Schema defined in the SOAP Version 1.2 Part 1 specification
     Recommendation:
     http://www.w3.org/TR/2003/REC-soap12-part1-20030624/
     $Id: soap-envelope.xsd,v 1.2 2006/12/20 20:43:36 ylafon Exp $

     Copyright (C)2003 W3C(R) (MIT, ERCIM, Keio), All Rights Reserved.
     W3C viability, trademark, document use and software licensing rules
     apply.
     http://www.w3.org/Consortium/Legal/

     This document is governed by the W3C Software License [1] as
     described in the FAQ [2].

     [1] http://www.w3.org/Consortium/Legal/copyright-software-19980720
     [2] http://www.w3.org/Consortium/Legal/IPR-FAQ-20000620.html#DTD
-->

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:tns="http://www.w3.org/2003/05/soap-envelope"
           targetNamespace="http://www.w3.org/2003/05/soap-envelope" 
		   elementFormDefault="qualified" >

  <xs:import namespace="http://www.w3.org/XML/1998/namespace" 
             schemaLocation="http://www.w3.org/2001/xml.xsd"/>

  <!-- Envelope, header and body -->
  <xs:element name="Envelope" type="tns:Envelope" />
  <xs:complexType name="Envelope" >
    <xs:sequence>
      <xs:element ref="tns:Header" minOccurs="0" />
      <xs:element ref="tns:Body" minOccurs="1" />
    </xs:sequence>
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <xs:element name="Header" type="tns:Header" />
  <xs:complexType name="Header" >
    <xs:annotation>
	  <xs:documentation>
	  Elements replacing the wildcard MUST be namespace qualified, but can be in the targetNamespace
	  </xs:documentation>
	</xs:annotation>
    <xs:sequence>
      <xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"  />
    </xs:sequence>
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>
  
  <xs:element name="Body" type="tns:Body" />
  <xs:complexType name="Body" >
    <xs:sequence>
      <xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:anyAttribute namespace="##other" processContents="lax" />
  </xs:complexType>

  <!-- Global Attributes.  The following attributes are intended to be
  usable via qualified attribute names on any complex type referencing
  them.  -->
  <xs:attribute name="mustUnderstand" type="xs:boolean" default="0" />
  <xs:attribute name="relay" type="xs:boolean" default="0" />
  <xs:attribute name="role" type="xs:anyURI" />

  <!-- 'encodingStyle' indicates any canonicalization conventions
  followed in the contents of the containing element.  For example, the
  value 'http://www.w3.org/2003/05/soap-encoding' indicates the pattern
  described in the SOAP Version 1.2 Part 2: Adjuncts Recommendation -->

  <xs:attribute name="encodingStyle" type="xs:anyURI" />

  <xs:element name="Fault" type="tns:Fault" />
  <xs:complexType name="Fault" final="extension" >
    <xs:annotation>
	  <xs:documentation>
	    Fault reporting structure
	  </xs:documentation>
	</xs:annotation>
    <xs:sequence>
      <xs:element name="Code" type="tns:faultcode" />
      <xs:element name="Reason" type="tns:faultreason" />
      <xs:element name="Node" type="xs:anyURI" minOccurs="0" />
	  <xs:element name="Role" type="xs:anyURI" minOccurs="0" />
      <xs:element name="Detail" type="tns:detail" minOccurs="0" />
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="faultreason" >
    <xs:sequence>
	  <xs:element name="Text" type="tns:reasontext" 
                  minOccurs="1"  maxOccurs="unbounded" />
	</xs:sequence>
  </xs:complexType>

  <xs:complexType name="reasontext" >
    <xs:simpleContent>
	  <xs:extension base="xs:string" >
	    <xs:attribute ref="xml:lang" use="required" />
	  </xs:extension>
	</xs:simpleContent>
  </xs:complexType>
  
  <xs:complexType name="faultcode">
    <xs:sequence>
      <xs:element name="Value"
                  type="tns:faultcodeEnum"/>
      <xs:element name="Subcode"
                  type="tns:subcode"
                  minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:simpleType name="faultcodeEnum">
    <xs:restriction base="xs:QName">
      <xs:enumeration value="tns:DataEncodingUnknown"/>
      <xs:enumeration value="tns:MustUnderstand"/>
      <xs:enumeration value="tns:Receiver"/>
      <xs:enumeration value="tns:Sender"/>
      <xs:enumeration value="tns:VersionMismatch"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="subcode">
    <xs:sequence>
      <xs:element name="Value"
                  type="xs:QName"/>
      <xs:element name="Subcode"
                  type="tns:subcode"
                  minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="detail">
    <xs:sequence>
      <xs:any namespace="##any" processContents="lax" minOccurs="0" maxOccurs="unbounded"  />
    </xs:sequence>
    <xs:anyAttribute namespace="##other" processContents="lax" /> 
  </xs:complexType>

  <!-- Global element declaration and complex type definition for header entry returned due to a mustUnderstand fault -->
  <xs:element name="NotUnderstood" type="tns:NotUnderstoodType" />
  <xs:complexType name="NotUnderstoodType" >
    <xs:attribute name="qname" type="xs:QName" use="required" />
  </xs:complexType>


  <!-- Global element and associated types for managing version transition as described in Appendix A of the SOAP Version 1.2 Part 1 Recommendation  -->  <xs:complexType name="SupportedEnvType" >
    <xs:attribute name="qname" type="xs:QName" use="required" />
  </xs:complexType>

  <xs:element name="Upgrade" type="tns:UpgradeType" />
  <xs:complexType name="UpgradeType" >
    <xs:sequence>
	  <xs:element name="SupportedEnvelope" type="tns:SupportedEnvType" minOccurs="1" maxOccurs="unbounded" />
	</xs:sequence>
  </xs:complexType>


</xs:schema>
</file>

<file path="wsdl/vendor/xmlmime.xsd">
<?xml version="1.0" ?>
<!-- 
   W3C XML Schema defined in the Describing Media Content of Binary Data in XML
   specification
     http://www.w3.org/TR/xml-media-types

   Copyright  2005 World Wide Web Consortium,
  
   (Massachusetts Institute of Technology, European Research Consortium for
   Informatics and Mathematics, Keio University). All Rights Reserved. This
   work is distributed under the W3C Software License [1] in the hope that
   it will be useful, but WITHOUT ANY WARRANTY; without even the implied
   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  
   [1] http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231

   $Id: xmlmime.xsd,v 1.1 2005/04/25 17:08:35 hugo Exp $
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:xmime="http://www.w3.org/2005/05/xmlmime"
           targetNamespace="http://www.w3.org/2005/05/xmlmime" >

  <xs:attribute name="contentType">
    <xs:simpleType>
      <xs:restriction base="xs:string" >
      <xs:minLength value="3" />
      </xs:restriction>
    </xs:simpleType>
  </xs:attribute>

  <xs:attribute name="expectedContentTypes" type="xs:string" />

  <xs:complexType name="base64Binary" >
    <xs:simpleContent>
        <xs:extension base="xs:base64Binary" >
            <xs:attribute ref="xmime:contentType" />
        </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="hexBinary" >
    <xs:simpleContent>
        <xs:extension base="xs:hexBinary" >
            <xs:attribute ref="xmime:contentType" />
        </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

</xs:schema>
</file>

<file path=".clinerules">
# ONVIF Server Project Rules & Patterns

## Code Structure

1. **Module Exports Pattern**
   - Core server functionality is in `src/onvif-server.js`
   - Configuration utilities in `src/config-builder.js`
   - Main application entry in `main.js`
   - Helper scripts in project root

2. **Configuration Approach**
   - YAML is used for all configuration files
   - Individual NVR configs: `config-<ip>.yaml`
   - Combined NVR config: `config-combined.yaml`
   - Network scripts generated alongside configs

3. **Naming Conventions**
   - Network interfaces: `onv<index>_<shortMac>`
   - Static IPs: `192.168.6.<2+index>`
   - Server ports start at 8081 and increment
   - Proxy ports: RTSP (8554+) and Snapshot (8580+)

## Technical Patterns

1. **Network Interface Management**
   - Virtual interfaces use macvlan mode bridge
   - ARP settings configuration required
   - Static IP assignment is preferred over DHCP
   - MAC addresses are deterministically generated

2. **Proxy Port Assignment**
   - Ports are assigned per NVR to avoid conflicts
   - RTSP ports increment by 2 (for RTCP)
   - Snapshot ports increment by 1
   - Base ports: RTSP=8554, Snapshot=8580

3. **Error Handling**
   - Use `try/catch` blocks for SOAP operations
   - Socket errors should be caught and handled gracefully
   - Prefer disabling problematic features over crash prevention
   - Debug mode for verbose logging

4. **ONVIF Protocol Implementation**
   - Device and Media services are required
   - WSDL files are vendored locally in `wsdl/` directory
   - SOAP 1.2 headers are enforced

## Testing & Deployment

1. **Testing Flow**
   - Generate network interfaces first
   - Start server with debug flag
   - Verify port assignments in logs
   - Test camera adoption in UniFi Protect
   - Monitor logs for errors

2. **Deployment Requirements**
   - Linux with macvlan support
   - Root access for network configuration
   - Node.js environment
   - Scripts must be executable (`chmod +x`)

## Common Issues

1. **Network Interface Problems**
   - Interfaces don't persist across reboots
   - IP assignment might be delayed
   - Interface names limited to 15 characters
   - ARP configuration needed for proper routing

2. **Port Conflicts**
   - Multiple server instances cause EADDRINUSE on discovery port
   - RTSP and Snapshot ports must be unique per NVR
   - Server ports must be unique per camera

3. **ONVIF Discovery**
   - UDP multicasting can be unreliable
   - Some NVRs don't use standard discovery
   - Manual camera addition might be needed

## Development Workflow

1. Create or modify configuration with `--create-config`
2. Apply network configuration with setup script
3. Start server with `node main.js <config>`
4. Debug with `--debug` flag when issues occur
5. Update both configuration and scripts when adding cameras
</file>

<file path="create-test-config.js">
const configBuilder = require('./src/config-builder');

// Check if command line arguments are provided
if (process.argv.length < 5) {
  console.log('Usage: node create-test-config.js <hostname> <username> <password>');
  console.log('Example: node create-test-config.js 192.168.6.219 admin password');
  process.exit(1);
}

const hostname = process.argv[2];
const username = process.argv[3];
const password = process.argv[4];

console.log(`Creating test config for ${hostname} with one camera...`);

// Call the createTestConfig function
configBuilder.createTestConfig(hostname, username, password)
  .then(config => {
    if (config) {
      console.log('Test config created successfully!');
      console.log('You can now run:');
      console.log(`  sudo ./setup-network-test-${hostname}.sh`);
      console.log(`  node main.js config-test-${hostname}.yaml`);
    } else {
      console.error('Failed to create test config.');
    }
  })
  .catch(err => {
    console.error('Error creating test config:', err);
  });
</file>

<file path="extract_resolutions.js">
const fs = require('fs');
const yaml = require('yaml');

// Read MAC-to-IP mapping from mac_to_interface.txt
function readMacToIpMap(filename) {
    const map = {};
    try {
        const lines = fs.readFileSync(filename, 'utf8').split('\n');
        for (const line of lines) {
            const parts = line.trim().split(/\s+/);
            if (parts.length === 3) {
                const [mac, iface, ip] = parts;
                map[mac.toLowerCase()] = ip;
            }
        }
    } catch (e) {
        console.error(`Error reading or parsing ${filename}: ${e.message}`);
    }
    return map;
}

// Read config and print IP + Resolution
function printResolutions(configFile, macToIpMap) {
    try {
        const configText = fs.readFileSync(configFile, 'utf8');
        const config = yaml.parse(configText);

        if (!config || !Array.isArray(config.onvif)) {
            console.error(`Invalid or missing 'onvif' array in ${configFile}`);
            return;
        }

        console.log("IP Address       - High Quality Resolution");
        console.log("-----------------------------------------");

        for (const cam of config.onvif) {
            const mac = cam.mac ? cam.mac.toLowerCase() : null;
            const ip = mac ? macToIpMap[mac] : 'N/A';
            let resolution = 'N/A';

            if (cam.highQuality && cam.highQuality.width && cam.highQuality.height) {
                resolution = `${cam.highQuality.width}x${cam.highQuality.height}`;
            }

            console.log(`${ip.padEnd(16)} - ${resolution}`);
        }
    } catch (e) {
        console.error(`Error reading or parsing ${configFile}: ${e.message}`);
    }
}

// --- Main ---
const macMapFile = 'mac_to_interface.txt';
const configFile = 'config-combined.yaml';

const macToIp = readMacToIpMap(macMapFile);
if (Object.keys(macToIp).length === 0) {
    console.error(`Could not load MAC-to-IP mapping from ${macMapFile}. Exiting.`);
    process.exit(1);
}

printResolutions(configFile, macToIp);
</file>

<file path="extract-test-config.js">
const fs = require('fs');
const yaml = require('yaml');
const path = require('path');

// Check if command line arguments are provided
if (process.argv.length < 3) {
  console.log('Usage: node extract-test-config.js <nvr-ip>');
  console.log('Example: node extract-test-config.js 192.168.6.219');
  process.exit(1);
}

const nvrIp = process.argv[2];
const sourceConfigFile = `config-${nvrIp}.yaml`;
const testConfigFile = `config-test-${nvrIp}.yaml`;
const testScriptFile = `setup-network-test-${nvrIp}.sh`;

console.log(`Creating test config for ${nvrIp} with one camera...`);

try {
  // Read the existing config file
  const configData = fs.readFileSync(sourceConfigFile, 'utf8');
  const config = yaml.parse(configData);
  
  if (!config || !config.onvif || !config.onvif.length) {
    console.error(`No cameras found in ${sourceConfigFile}`);
    process.exit(1);
  }
  
  // Create a new config with just the first camera
  const testConfig = {
    onvif: [config.onvif[0]]
  };
  
  // Save the test config
  fs.writeFileSync(testConfigFile, yaml.stringify(testConfig), 'utf8');
  console.log(`Test config saved to ${testConfigFile}`);
  
  // Create a network setup script for the test config
  const macAddress = testConfig.onvif[0].mac;
  // Generate a short interface name (max 15 chars)
  const shortMac = macAddress.replace(/:/g, '').slice(-4);
  const interfaceName = `onv1_${shortMac}`;
  
  let script = `#!/bin/bash\n\n`;
  script += `# Test network setup script for ONVIF virtual interface\n`;
  script += `# Generated for NVR: ${nvrIp} (test with one camera)\n`;
  script += `# Generated on: ${new Date().toISOString()}\n\n`;
  
  script += `# Get the physical interface name (look for the interface with the host IP)\n`;
  script += `HOST_IP=$(hostname -I | awk '{print $1}')\n`;
  script += `PHYS_IFACE=$(ip -o addr show | grep "$HOST_IP" | grep -v macvlan | awk '{print $2}' | cut -d':' -f1)\n`;
  script += `if [ -z "$PHYS_IFACE" ]; then\n`;
  script += `    echo "Error: Could not determine physical interface"\n`;
  script += `    exit 1\n`;
  script += `fi\n`;
  script += `echo "Using physical interface: $PHYS_IFACE"\n\n`;
  
  script += `# Check if dhclient is installed\n`;
  script += `if ! command -v dhclient &> /dev/null; then\n`;
  script += `    echo "dhclient not found. Please install it with:"\n`;
  script += `    echo "  sudo apt-get install isc-dhcp-client    (for Debian/Ubuntu)"\n`;
  script += `    echo "  sudo yum install dhcp-client            (for CentOS/RHEL)"\n`;
  script += `    exit 1\n`;
  script += `fi\n\n`;
  
  // Generate a static IP for the test interface
  const staticIp = `192.168.6.${2 + 1}`; // Use 192.168.6.3 for the test interface
  
  script += `# Create a mapping file for MAC to interface name and IP\n`;
  script += `cat > mac_to_interface.txt << EOF\n`;
  script += `${macAddress} ${interfaceName} ${staticIp}\n`;
  script += `EOF\n\n`;
  
  script += `# Parse command line arguments\n`;
  script += `USE_DHCP=true\n`;
  script += `while [[ "$#" -gt 0 ]]; do\n`;
  script += `    case $1 in\n`;
  script += `        --static) USE_DHCP=false ;;\n`;
  script += `        *) echo "Unknown parameter: $1"; exit 1 ;;\n`;
  script += `    esac\n`;
  script += `    shift\n`;
  script += `done\n\n`;
  
  script += `# Check if dhclient is installed when using DHCP\n`;
  script += `if [ "$USE_DHCP" = true ] && ! command -v dhclient &> /dev/null; then\n`;
  script += `    echo "dhclient not found. Please install it with:"\n`;
  script += `    echo "  sudo apt-get install isc-dhcp-client    (for Debian/Ubuntu)"\n`;
  script += `    echo "  sudo yum install dhcp-client            (for CentOS/RHEL)"\n`;
  script += `    echo "Or use --static to assign static IPs instead."\n`;
  script += `    exit 1\n`;
  script += `fi\n\n`;
  
  script += `# Remove any existing interface\n`;
  script += `ip link show ${interfaceName} > /dev/null 2>&1 && ip link delete ${interfaceName}\n\n`;
  
  script += `# Create new macvlan interface as specified in the README\n`;
  script += `echo "Creating macvlan interface ${interfaceName}..."\n`;
  script += `ip link add ${interfaceName} link $PHYS_IFACE address ${macAddress} type macvlan mode bridge\n`;
  script += `ip link set ${interfaceName} up\n`;
  
  script += `# Assign IP address based on mode\n`;
  script += `if [ "$USE_DHCP" = true ]; then\n`;
  script += `    echo "Requesting IP address for ${interfaceName} via DHCP..."\n`;
  script += `    dhclient -v ${interfaceName} &\n`;
  script += `else\n`;
  script += `    echo "Assigning static IP ${staticIp}/24 to ${interfaceName}..."\n`;
  script += `    ip addr add ${staticIp}/24 dev ${interfaceName}\n`;
  script += `fi\n`;
  
  script += `# Configure ARP to prevent issues with multiple interfaces\n`;
  script += `echo "Configuring ARP settings..."\n`;
  script += `echo 1 > /proc/sys/net/ipv4/conf/${interfaceName}/arp_ignore\n`;
  script += `echo 2 > /proc/sys/net/ipv4/conf/${interfaceName}/arp_announce\n\n`;
  
  script += `# Wait for IP assignment to complete and display IP address\n`;
  script += `sleep 3\n`;
  script += `echo "Virtual interface IP address:"\n`;
  script += `ip -4 addr show | grep -A 2 "${interfaceName}" | grep -v "valid_lft"\n`;
  
  script += `\necho "To use static IP addresses instead of DHCP, run: sudo $0 --static"\n`;
  
  // Save the network script
  fs.writeFileSync(testScriptFile, script, 'utf8');
  fs.chmodSync(testScriptFile, '0755'); // Make executable
  console.log(`Test network setup script saved to ${testScriptFile}`);
  
  console.log('\nTo test with one camera:');
  console.log(`1. Run: sudo ./${testScriptFile}`);
  console.log(`2. Run: node main.js ${testConfigFile}`);
  
} catch (err) {
  console.error('Error creating test config:', err);
}
</file>

<file path="generate-dynamic-config.js">
const fs = require('fs');
const yaml = require('yaml');
const { execSync } = require('child_process');

// Get all onv* interfaces with their MAC and IPv4 addresses
function getOnvifMacIpMap() {
    const map = {};
    const ipAddrLines = execSync('ip -o -4 addr show | grep "onv"').toString().split('\n');
    for (const line of ipAddrLines) {
        if (!line.trim()) continue;
        const parts = line.trim().split(/\s+/);
        const iface = parts[1];
        const ip = parts[3].split('/')[0];
        try {
            const macLine = execSync(`ip link show ${iface} | grep ether`).toString();
            const mac = macLine.trim().split(/\s+/)[1].toLowerCase();
            map[mac] = ip;
        } catch (e) {
            console.warn(`Could not get MAC for interface ${iface}`);
        }
    }
    return map;
}

// Update YAML config with dynamic hostnames
function updateConfigWithHostnames(configFile, macToIpMap, outputFile) {
    const configText = fs.readFileSync(configFile, 'utf8');
    const config = yaml.parse(configText);

    if (!Array.isArray(config.onvif)) {
        throw new Error('Invalid config: missing onvif array');
    }

    for (const cam of config.onvif) {
        if (cam.mac && macToIpMap[cam.mac.toLowerCase()]) {
            cam.hostname = macToIpMap[cam.mac.toLowerCase()];
        } else {
            console.warn(`No IP found for MAC ${cam.mac}, leaving hostname unchanged.`);
        }
    }

    const newYaml = yaml.stringify(config);
    fs.writeFileSync(outputFile, newYaml, 'utf8');
    console.log(`Updated config written to ${outputFile}`);
}

// Main
const args = process.argv.slice(2);
if (args.length < 2) {
    console.log('Usage: node generate-dynamic-config.js <input-config.yaml> <output-config.yaml>');
    process.exit(1);
}
const [inputConfig, outputConfig] = args;
const macToIp = getOnvifMacIpMap();
updateConfigWithHostnames(inputConfig, macToIp, outputConfig);
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Daniela Hasenbring

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="mac_to_interface.txt">
02:28:5c:53:db:b4 onv1_dbb4 192.168.6.3
02:ca:fe:ba:62:8d onv2_628d 192.168.6.4
02:b0:82:62:fa:d9 onv3_fad9 192.168.6.5
02:09:84:94:24:75 onv4_2475 192.168.6.6
02:20:5c:60:50:93 onv5_5093 192.168.6.7
02:6f:cb:19:cb:b4 onv6_cbb4 192.168.6.8
02:8e:81:a6:21:cb onv7_21cb 192.168.6.9
02:0b:70:bd:69:e3 onv8_69e3 192.168.6.10
02:7e:32:58:29:12 onv9_2912 192.168.6.11
02:cd:47:13:1b:73 onv10_1b73 192.168.6.12
02:af:df:dd:a6:fc onv11_a6fc 192.168.6.13
02:0e:71:51:f9:b6 onv12_f9b6 192.168.6.14
02:dd:ac:2e:c6:b4 onv13_c6b4 192.168.6.15
02:59:a5:04:df:d2 onv14_dfd2 192.168.6.16
02:fd:fc:0e:8e:96 onv15_8e96 192.168.6.17
02:a1:ef:84:32:1b onv16_321b 192.168.6.18
02:1f:4a:4d:dc:b2 onv17_dcb2 192.168.6.19
02:6c:df:c2:8a:e4 onv18_8ae4 192.168.6.20
02:78:5d:1d:93:13 onv19_9313 192.168.6.21
02:72:0e:1c:6c:12 onv20_6c12 192.168.6.22
02:aa:e1:92:ad:20 onv21_ad20 192.168.6.23
02:e6:59:ae:f7:cb onv22_f7cb 192.168.6.24
02:4a:b7:ec:94:0e onv23_940e 192.168.6.25
02:1c:0c:6f:7e:17 onv24_7e17 192.168.6.26
02:f7:53:82:11:5b onv25_115b 192.168.6.27
02:a4:c8:2a:a6:14 onv26_a614 192.168.6.28
02:53:98:1d:1e:db onv27_1edb 192.168.6.29
02:d7:88:0d:33:6f onv28_336f 192.168.6.30
02:c3:5b:fb:ec:72 onv29_ec72 192.168.6.31
02:29:3d:11:bc:3a onv30_bc3a 192.168.6.32
02:0f:dc:bc:54:b3 onv31_54b3 192.168.6.33
02:d0:19:ba:5b:68 onv32_5b68 192.168.6.34
</file>

<file path="ONVIF-SERVER-GUIDE.md">
# ONVIF Server Implementation Guide

This document provides a comprehensive guide to the implementation and operation of the Virtual ONVIF Server for Unifi Protect integration. It details the technical aspects, configuration process, and operational procedures.

## Table of Contents

1. [Overview](#overview)
2. [Technical Architecture](#technical-architecture)
3. [Network Configuration](#network-configuration)
4. [Installation and Setup](#installation-and-setup)
5. [Running the ONVIF Server](#running-the-onvif-server)
6. [Troubleshooting](#troubleshooting)
7. [Advanced Configuration](#advanced-configuration)

## Overview

The Virtual ONVIF Server creates virtual ONVIF-compatible devices that proxy RTSP streams from existing cameras or NVRs. This allows systems like Unifi Protect to integrate with multi-channel NVRs or cameras that aren't directly supported.

Key features:
- Creates virtual network interfaces with unique MAC addresses
- Implements ONVIF Profile S for live streaming
- Supports both high and low-quality streams
- Proxies RTSP streams and snapshot requests

## Technical Architecture

### Components

1. **Node.js Application**: The core server that implements the ONVIF protocol
2. **MacVLAN Interfaces**: Virtual network interfaces that allow multiple MAC addresses on a single physical interface
3. **TCP Proxy**: Forwards RTSP and snapshot requests to the actual camera/NVR
4. **SOAP Protocol**: Used for ONVIF communication
5. **DHCP Client**: Obtains IP addresses for the virtual interfaces

### Technologies Used

- **Node.js**: Runtime environment for the server
- **SOAP**: Protocol for ONVIF communication
- **MacVLAN**: Linux kernel feature for creating virtual network interfaces
- **DHCP**: Dynamic Host Configuration Protocol for IP address assignment
- **YAML**: Configuration file format
- **RTSP**: Real-Time Streaming Protocol for video streams

## Network Configuration

### MacVLAN Interfaces

The system uses MacVLAN interfaces to create virtual network interfaces with unique MAC addresses. This is crucial for Unifi Protect to recognize each virtual camera as a separate device.

MacVLAN interfaces are created as follows:
```bash
ip link add [NAME] link [PHYSICAL_INTERFACE] address [MAC_ADDRESS] type macvlan mode bridge
```

### ARP Configuration

To prevent ARP conflicts with multiple interfaces on the same subnet, we configure ARP settings for each interface:
```bash
echo 1 > /proc/sys/net/ipv4/conf/[INTERFACE]/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/[INTERFACE]/arp_announce
```

### IP Address Assignment

IP addresses can be assigned either via DHCP or statically:
- **DHCP**: The system uses `dhclient` to request IP addresses from the DHCP server
- **Static**: IP addresses can be manually assigned with the `--static` flag

## Installation and Setup

### Prerequisites

- Node.js v16 or higher
- Linux system with support for MacVLAN interfaces
- DHCP server on the network (optional, for dynamic IP assignment)

### Configuration Generation

The system can automatically generate configuration by connecting to an existing ONVIF camera or NVR:

```bash
node main.js --create-config
```

This will:
1. Connect to the specified ONVIF device
2. Retrieve all available video profiles
3. Generate a YAML configuration file
4. Create network setup scripts

### Configuration Files

The system generates several configuration files:
- `config-[IP].yaml`: Configuration for a specific NVR
- `config-test-[IP].yaml`: Test configuration with a single camera
- `config-combined.yaml`: Combined configuration for multiple NVRs
- `setup-network-[IP].sh`: Network setup script for a specific NVR
- `setup-network-test-[IP].sh`: Test network setup script with a single camera
- `setup-network-combined.sh`: Combined network setup script for multiple NVRs

## Running the ONVIF Server

### Testing with a Single Camera

For initial testing, it's recommended to start with a single camera:

```bash
# Generate test configuration
node extract-test-config.js 192.168.6.219

# Set up the network interface
sudo ./setup-network-test-192.168.6.219.sh

# Run the ONVIF server
node main.js config-test-192.168.6.219.yaml
```

### Running the Full Configuration

Once testing is successful, you can run the full configuration:

```bash
# Set up all network interfaces
sudo ./setup-network-192.168.6.219.sh

# Run the ONVIF server
node main.js config-192.168.6.219.yaml
```

### Running in Background

To run the server in the background, you can use one of these methods:

#### Using nohup

```bash
# Kill any existing processes first
pkill -f "node main.js config"

# Set up the network interfaces
sudo ./setup-network-192.168.6.219.sh

# Run the server detached with nohup
nohup node main.js config-192.168.6.219.yaml > onvif-server.log 2>&1 &
```

#### Using screen

```bash
# Install screen if not already installed
sudo apt-get install screen

# Create a named screen session
screen -S onvif-server

# Inside the screen session, run:
sudo ./setup-network-192.168.6.219.sh
node main.js config-192.168.6.219.yaml

# Detach from the screen session with Ctrl+A followed by D
# You can later reattach with:
screen -r onvif-server
```

#### Using systemd

Create a systemd service file:

```bash
sudo nano /etc/systemd/system/onvif-server.service
```

Add the following content:

```
[Unit]
Description=ONVIF Virtual Server
After=network.target

[Service]
Type=simple
User=molesza
WorkingDirectory=/home/molesza/onvif-server
ExecStartPre=/bin/bash -c '/home/molesza/onvif-server/setup-network-192.168.6.219.sh'
ExecStart=/usr/bin/node /home/molesza/onvif-server/main.js /home/molesza/onvif-server/config-192.168.6.219.yaml
Restart=on-failure
RestartSec=10

[Install]
WantedBy=multi-user.target
```

Then enable and start the service:

```bash
sudo systemctl daemon-reload
sudo systemctl enable onvif-server
sudo systemctl start onvif-server
```

## Troubleshooting

### Interface Detection Issues

If the system has trouble detecting the physical interface, it now uses a more robust method:

```bash
HOST_IP=$(hostname -I | awk '{print $1}')
PHYS_IFACE=$(ip -o addr show | grep "$HOST_IP" | grep -v macvlan | awk '{print $2}' | cut -d':' -f1)
```

This looks for the interface with the host's IP address, excluding macvlan interfaces.

### Port Conflicts

If you see errors like `EADDRINUSE: address already in use`, ensure you're not running multiple instances of the server. Use:

```bash
pkill -f "node main.js config"
```

to stop any existing instances.

### ARP Conflicts

If cameras are showing the same video stream in Unifi Protect, ensure the ARP settings are properly configured:

```bash
echo 1 > /proc/sys/net/ipv4/conf/all/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/all/arp_announce
```

### ONVIF Authentication Issues

If you see "Wsse authorized time check failed" errors, ensure your system time is synchronized with the camera/NVR.

### Slow ONVIF Discovery

ONVIF discovery can be slow, and it may take time for all devices to appear in Unifi Protect or other ONVIF-compatible systems. This is normal behavior as ONVIF discovery relies on multicast/broadcast messages that can sometimes be delayed in the network.

If not all cameras appear immediately:
1. Wait 5-10 minutes for the discovery process to complete
2. Restart the Unifi Protect service or refresh the discovery page
3. Ensure that multicast traffic is allowed on your network
4. Check that the ONVIF server is running for all interfaces (use the test-camera-ips.sh script)

You can also manually add cameras by IP address if they don't appear in the discovery list.

## Advanced Configuration

### Custom MAC Addresses

You can customize the MAC addresses in the configuration files. Ensure they follow the locally administered MAC address format (first byte has bit 1 set).

### Stream Selection

The system automatically selects the best streams based on quality and resolution. You can manually adjust this in the configuration files.

### Multiple NVRs

To combine cameras from multiple NVRs:

1. Generate configurations for each NVR
2. Use the combined configuration and network script
3. Run the server with the combined configuration

```bash
node main.js config-combined.yaml
```

### Custom RTSP Paths

For cameras with non-standard RTSP paths, you can manually edit the configuration file to specify the correct paths.
</file>

<file path="SETUP-GUIDE.md">
# ONVIF Server Setup Guide

This guide provides step-by-step instructions for setting up and running the ONVIF server to proxy IP cameras to UniFi Protect or other NVRs.

## Prerequisites

- **Operating System**: Linux (with macvlan support)
- **Node.js**: Installed and working
- **Root Access**: Required for network configuration
- **IP Cameras**: Accessible via RTSP streams
- **NVR**: UniFi Protect or other compatible NVR system

## Installation

1. Clone the repository:
   ```bash
   git clone https://github.com/molesza/onvif-camera-proxy.git
   cd onvif-camera-proxy
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

## Configuration

### 1. Create Configuration

Create a configuration file by using the `--create-config` option:

```bash
node main.js --create-config
```

You'll be prompted to enter:
- NVR/Camera Server IP or hostname
- Onvif Username
- Onvif Password

This will:
1. Generate a YAML configuration file (`config-<ip>.yaml`)
2. Create a network setup script (`setup-network-<ip>.sh`)
3. Update the combined configuration and setup script

### 2. Multiple NVRs (Optional)

To add cameras from additional NVRs, run the same command for each NVR:

```bash
node main.js --create-config
```

The script will automatically:
- Create individual config files for each NVR
- Update the combined configuration (`config-combined.yaml`)
- Update the combined network script (`setup-network-combined.sh`)

## Deployment

### 1. Set Up Network Interfaces

The most crucial step is to create the virtual network interfaces. This **must** be done before starting the server.

```bash
sudo ./setup-network-combined.sh
```

After running the script, verify that the interfaces were created successfully:

```bash
ip -4 addr show | grep 192.168.6
```

You should see all the expected IP addresses (192.168.6.3 through 192.168.6.50) associated with interfaces named `onv1_` through `onv48_`.

**Troubleshooting Interface Creation:**

If some interfaces are missing:
- Ensure you ran the script with `sudo` (root privileges)
- Check for any error messages during script execution
- Try running the script again

> **Note**: The error message `Error: listen EADDRNOTAVAIL: address not available 192.168.6.xx` indicates that the particular virtual interface for that IP address was not created successfully.
> 
> **Important**: These virtual interfaces don't persist across system reboots. You'll need to run this script again after each reboot.

### 2. Start the ONVIF Server

After setting up the network interfaces, start the server:

```bash
node main.js config-combined.yaml --debug
```

The `--debug` flag enables detailed logging, which is helpful for troubleshooting.

You should see output showing:
- Port assignments for each NVR
- Startup of virtual ONVIF servers for each camera
- TCP proxy setups for RTSP and snapshot ports

### 3. Add Cameras to Your NVR

Now you can add the cameras to your NVR:

#### For UniFi Protect:
1. Go to the UniFi Protect interface
2. Select "Add Devices" or "Adopt" 
3. Use the "Manual Add" option if automatic discovery doesn't work
4. Enter the static IP addresses shown in the server logs
5. Use the default ONVIF username/password you specified during configuration

## Troubleshooting

### Network Interface Issues

- **Error: `listen EADDRNOTAVAIL: address not available`**: Indicates the virtual network interfaces haven't been created or were created incompletely. This specific error points to exactly which IP address is missing. Run the setup script with root privileges and verify all interfaces exist.

- **Interfaces disappear after reboot**: Normal behavior. Run the setup script again after each system reboot.

- **Interface creation fails**: Ensure you're running with sudo/root privileges and your system supports macvlan. Check the output of the setup script for any error messages.

- **Interface exists but IP binding fails**: Sometimes the interfaces might exist but not have the proper IP configuration. You can verify with:
  ```bash
  ip addr show | grep 192.168.6
  ```

### Camera Discovery Issues

- **Cameras not discovered by NVR**: Try manual addition using the static IPs.

- **Discovery port conflicts**: The server disables UDP discovery by default. This is intentional to avoid port conflicts.

### Port Conflicts

- **RTSP/Snapshot port conflicts**: The server automatically assigns unique ports for each NVR. Check the logs for the assigned ports.

## Advanced Usage

### Testing with a Single Camera

For initial testing, you can create a test configuration with just one camera:

```bash
node create-test-config.js
```

### Running as a Service

To run the server automatically at startup, create a systemd service:

1. Create a service file:
   ```bash
   sudo nano /etc/systemd/system/onvif-server.service
   ```

2. Add the following content (adjust paths as needed):
   ```
   [Unit]
   Description=ONVIF Server Proxy
   After=network.target

   [Service]
   Type=simple
   User=root
   WorkingDirectory=/path/to/onvif-server
   ExecStartPre=/path/to/onvif-server/setup-network-combined.sh
   ExecStart=/usr/bin/node /path/to/onvif-server/main.js config-combined.yaml
   Restart=on-failure

   [Install]
   WantedBy=multi-user.target
   ```

3. Enable and start the service:
   ```bash
   sudo systemctl enable onvif-server
   sudo systemctl start onvif-server
   ```

## Common Issues & Solutions

1. **Missing WSDL Files**: The project includes vendored WSDL/XSD files. If you encounter issues, ensure the `wsdl` directory is intact.

2. **UniFi Protect Adoption Timeout**: Try manually adding cameras with the static IPs assigned by the setup script.

3. **Camera Stream Quality**: The configuration extracts both high and low-quality streams if available. Check the generated configuration file.

4. **Resource Limitations**: Running many virtual cameras can consume significant system resources. Consider limiting the number of cameras if you encounter performance issues.
</file>

<file path="test-camera-ips.sh">
#!/bin/bash

# This script tests connectivity to all camera IP addresses defined in the config file

# Check if yaml parser is available
if ! command -v yq &> /dev/null; then
  echo "yq command not found. Using grep/awk instead for YAML parsing."
  YAML_PARSER="grep"
else
  YAML_PARSER="yq"
fi

# Default config file
CONFIG_FILE="config-192.168.6.219.yaml"

# Allow specifying a different config file
if [ "$1" != "" ]; then
  CONFIG_FILE="$1"
fi

echo "Using config file: $CONFIG_FILE"

if [ ! -f "$CONFIG_FILE" ]; then
  echo "Error: Config file $CONFIG_FILE not found!"
  echo "Usage: $0 [config-file.yaml]"
  exit 1
fi

# Extract target hostname from config file
if [ "$YAML_PARSER" == "yq" ]; then
  TARGET_HOST=$(yq '.onvif[0].target.hostname' "$CONFIG_FILE")
else
  TARGET_HOST=$(grep -A 5 "target:" "$CONFIG_FILE" | grep "hostname:" | head -1 | awk '{print $2}')
fi

echo "Target camera/NVR: $TARGET_HOST"

# Extract camera IPs and ports from config file
echo "Extracting camera configurations from $CONFIG_FILE..."

# Get camera count
if [ "$YAML_PARSER" == "yq" ]; then
  CAMERA_COUNT=$(yq '.onvif | length' "$CONFIG_FILE")
else
  CAMERA_COUNT=$(grep -c "mac:" "$CONFIG_FILE")
fi

echo "Found $CAMERA_COUNT cameras in config"

# Test target camera/NVR connectivity
echo ""
echo "Testing connectivity to target camera/NVR ($TARGET_HOST)..."
ping -c 1 -W 2 "$TARGET_HOST" > /dev/null
if [ $? -eq 0 ]; then
  echo " Target camera/NVR is reachable"
else
  echo " Target camera/NVR is NOT reachable"
  echo "  This may prevent the ONVIF server from working properly."
fi

# Extract RTSP and HTTP ports
if [ "$YAML_PARSER" == "yq" ]; then
  RTSP_PORT=$(yq '.onvif[0].target.ports.rtsp' "$CONFIG_FILE")
  HTTP_PORT=$(yq '.onvif[0].target.ports.snapshot' "$CONFIG_FILE")
else
  # More robust parsing
  RTSP_PORT=$(grep -A 10 "target:" "$CONFIG_FILE" | grep -A 3 "ports:" | grep "rtsp:" | head -1 | awk '{print $2}')
  HTTP_PORT=$(grep -A 10 "target:" "$CONFIG_FILE" | grep -A 3 "ports:" | grep "snapshot:" | head -1 | awk '{print $2}')
fi

echo ""
echo "Testing RTSP port on target camera/NVR..."
nc -z -w 2 "$TARGET_HOST" "$RTSP_PORT"
if [ $? -eq 0 ]; then
  echo " RTSP port ($RTSP_PORT) is open on target camera/NVR"
else
  echo " RTSP port ($RTSP_PORT) is NOT open on target camera/NVR"
  echo "  This may prevent video streaming from working."
fi

echo ""
echo "Testing HTTP port on target camera/NVR..."
nc -z -w 2 "$TARGET_HOST" "$HTTP_PORT"
if [ $? -eq 0 ]; then
  echo " HTTP port ($HTTP_PORT) is open on target camera/NVR"
else
  echo " HTTP port ($HTTP_PORT) is NOT open on target camera/NVR"
  echo "  This may prevent snapshot functionality from working."
fi

echo ""
echo "Testing virtual camera interfaces..."

# Read the entire config file into a variable for easier parsing
CONFIG_CONTENT=$(cat "$CONFIG_FILE")

# Extract all MAC addresses
MAC_ADDRESSES=($(grep -E "^\s*- mac:" "$CONFIG_FILE" | awk '{print $3}'))
NAMES=($(grep -E "^\s*name:" "$CONFIG_FILE" | awk '{print $2}'))
SERVER_PORTS=($(grep -E "^\s*server:" "$CONFIG_FILE" | awk '{print $2}'))

# Loop through each camera in the config
for ((i=0; i<CAMERA_COUNT; i++)); do
  if [ "$YAML_PARSER" == "yq" ]; then
    MAC=$(yq ".onvif[$i].mac" "$CONFIG_FILE")
    NAME=$(yq ".onvif[$i].name" "$CONFIG_FILE")
    SERVER_PORT=$(yq ".onvif[$i].ports.server" "$CONFIG_FILE")
  else
    # Use the arrays we extracted
    MAC="${MAC_ADDRESSES[$i]}"
    NAME="${NAMES[$i]}"
    SERVER_PORT="${SERVER_PORTS[$i]}"
  fi
  
  # Generate interface name from MAC
  SHORT_MAC=$(echo "$MAC" | tr -d ':' | tail -c 5)
  if [ -z "$SHORT_MAC" ]; then
    # If MAC parsing failed, use a fallback
    SHORT_MAC=$(printf "%04x" $i)
  fi
  IFACE="onv$((i+1))_$SHORT_MAC"
  
  echo "Camera $((i+1)): $NAME (MAC: $MAC, Interface: $IFACE, Port: $SERVER_PORT)"
  
  # Check if interface exists
  if ip link show "$IFACE" &> /dev/null; then
    echo "   Interface $IFACE exists"
    
    # Get IP address
    IP=$(ip -4 addr show dev "$IFACE" 2>/dev/null | grep inet | awk '{print $2}' | cut -d'/' -f1)
    if [ -n "$IP" ]; then
      echo "   IP address assigned: $IP"
      
      # Test ONVIF server port
      nc -z -w 1 "$IP" "$SERVER_PORT" > /dev/null 2>&1
      if [ $? -eq 0 ]; then
        echo "   ONVIF server is running on $IP:$SERVER_PORT"
      else
        echo "   ONVIF server is NOT running on $IP:$SERVER_PORT"
      fi
    else
      echo "   No IP address assigned to $IFACE"
    fi
  else
    echo "   Interface $IFACE does not exist"
  fi
  
  echo ""
done

echo "Testing if cameras are discoverable via ONVIF..."
echo "Note: This requires onvif-discovery tool. If not installed, you can install it with:"
echo "npm install -g onvif-discovery"

if command -v onvif-discovery &> /dev/null; then
  echo "Running ONVIF discovery (this may take a few seconds)..."
  onvif-discovery | grep -E "192\.168\.6\.(2[0-9][0-9]|[0-9][0-9]|[0-9])"
else
  echo "onvif-discovery tool not found. Skipping ONVIF discovery test."
  echo "You can install it with: npm install -g onvif-discovery"
fi

echo ""
echo "Test complete!"
</file>

<file path="todo.md">
# ONVIF Server Troubleshooting Summary & TODO

This document summarizes the troubleshooting steps taken for the virtual ONVIF server and outlines the remaining issues.

## Completed Steps & Fixes

1.  **EADDRINUSE Crash:**
    *   **Problem:** Server crashed after 10-20 minutes due to `Error: bind EADDRINUSE 0.0.0.0`.
    *   **Cause:** Multiple virtual server instances were attempting to bind to the same UDP port (3702) for WS-Discovery.
    *   **Fix:**
        *   Modified `main.js` to ensure only the first server instance calls `startDiscovery()`.
        *   Added error handling to the UDP discovery socket in `src/onvif-server.js` to prevent unhandled errors.

2.  **Dynamic IP Configuration:**
    *   **Problem:** When using DHCP, the server config didn't reflect the actual IPs assigned to virtual interfaces, preventing cameras from being found.
    *   **Fix:**
        *   Created `generate-dynamic-config.js` script. This script reads the actual IPs assigned to `onv*` interfaces (using `ip addr show`) and updates a specified YAML config file (e.g., `config-combined.yaml`), writing the result with correct `hostname` fields to an output file (e.g., `config-dynamic-combined.yaml`).
        *   Modified `src/config-builder.js` (specifically `generateCombinedNetworkScript`) to generate network setup scripts (`setup-network-*.sh`) that request DHCP addresses sequentially for each interface, preventing router flooding and improving reliability.

3.  **Static IP Configuration:**
    *   **Clarification:** Confirmed that when using static IPs (`setup-network-*.sh --static`), the `generate-dynamic-config.js` script is *not* needed, provided the main config file (e.g., `config-combined.yaml`) has the correct static IPs manually entered in the `hostname` field for each camera.

## Current Issue: Manual Adoption Failure for Specific Cameras (Static IP)

*   **Problem:** Despite using static IPs and confirming interfaces/servers are running correctly, specific cameras cannot be manually adopted in UniFi Protect. The non-working IPs are those ending in: `.19`, `.22`, `.25`, `.27`, `.28`, `.33`. Other cameras (e.g., 192.168.6.3) adopt successfully.
*   **Troubleshooting Performed:**
    *   Confirmed all `onv*` interfaces are UP with correct static IPs via `ifconfig` / `ip addr show`.
    *   Confirmed interfaces are pingable.
    *   Confirmed Node.js server process is `LISTEN`ing on the correct static IP and ONVIF port for all cameras via `netstat`.
    *   Confirmed direct RTSP stream from the source DVR works for affected channels (e.g., Ch 26 for IP .28) via `ffprobe`.
    *   Confirmed basic HTTP connectivity to the virtual ONVIF server endpoint works for affected cameras (e.g., IP .28) via `curl`.
    *   Extracted and compared high-quality resolutions; confirmed that resolutions used by non-working cameras (960x1080, 1280x720) are also used by *working* cameras. Resolution incompatibility is unlikely the primary cause.
    *   Restarted interfaces and the ONVIF server with `--debug` logging enabled.

*   **Current Status:** Manual adoption of 192.168.6.28 still fails even after interface restart and with debug logging enabled on the server. The root cause seems specific to the UniFi adoption process for these cameras, despite the virtual servers appearing functional.

## Next Steps (TODO)

1.  **Analyze Debug Logs:**
    *   User needs to confirm they attempted manual adoption of 192.168.6.28 while the server was running with `--debug`.
    *   Examine the detailed ONVIF SOAP messages logged to the terminal/log file during the failed adoption attempt. Look for specific errors, malformed requests/responses, or differences compared to successful adoptions.
2.  **Investigate UniFi Side:**
    *   Check UniFi Protect logs for errors related to adopting these specific IPs.
    *   Try restarting the UniFi Protect application or the controller hardware.
    *   Verify UniFi network/firewall settings aren't blocking these specific IPs differently.
    *   Double-check credentials used during manual adoption.
3.  **Compare ONVIF Profiles:** If debug logs don't reveal errors, consider programmatically comparing the full ONVIF `GetProfiles` response between a working and non-working virtual camera instance to identify subtle differences UniFi might be sensitive to.
</file>

<file path="wsdl/device_service.wsdl">
<?xml version="1.0" encoding="utf-8" ?>
<wsdl:definitions xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:i0="http://www.onvif.org/ver10/device/wsdl" xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:tns="http://tempuri.org/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" targetNamespace="http://tempuri.org/">
  <wsdl:import namespace="http://www.onvif.org/ver10/device/wsdl" location="vendor/devicemgmt.wsdl"/>
  <wsdl:service name="DeviceService">
    <wsdl:port name="Device" binding="i0:DeviceBinding">
      <soap:address location="http://localhost:8000/onvif/device_service"/>
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>
</file>

<file path="wsdl/media_service.wsdl">
<?xml version="1.0" encoding="utf-8" ?>
<wsdl:definitions xmlns:s="http://www.w3.org/2001/XMLSchema" xmlns:i0="http://www.onvif.org/ver10/device/wsdl" xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap12/" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:tns="http://tempuri.org/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tm="http://microsoft.com/wsdl/mime/textMatching/" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" targetNamespace="http://tempuri.org/">
  <wsdl:import namespace="http://www.onvif.org/ver10/media/wsdl" location="vendor/media.wsdl"/>
  <wsdl:service name="MediaService">
    <wsdl:port name="Media" binding="i0:MediaBinding">
      <soap:address location="http://localhost:8000/onvif/media_service" />
    </wsdl:port>
  </wsdl:service>
</wsdl:definitions>
</file>

<file path=".gitignore">
node_modules
package-lock.json
.DS_Store
</file>

<file path="config-192.168.6.201.yaml">
onvif:
  - mac: 02:28:5c:53:db:b4
    ports:
      server: 8081
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel1
    uuid: 781619aa-0551-47b8-be20-694a8efdf47b
    highQuality:
      rtsp: /cam/realmonitor?channel=1&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=1&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=1&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=1&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:ca:fe:ba:62:8d
    ports:
      server: 8082
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel2
    uuid: 7735054f-c069-418f-935c-bfbe6d83f5cd
    highQuality:
      rtsp: /cam/realmonitor?channel=2&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=2&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=2&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=2&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:b0:82:62:fa:d9
    ports:
      server: 8083
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel3
    uuid: ef4852c1-210f-447e-b0ef-55f901e2ae36
    highQuality:
      rtsp: /cam/realmonitor?channel=3&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=3&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=3&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=3&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:09:84:94:24:75
    ports:
      server: 8084
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel4
    uuid: 8eb41b78-f5ba-4aec-91b8-eacb18886eed
    highQuality:
      rtsp: /cam/realmonitor?channel=4&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=4&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=4&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=4&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:20:5c:60:50:93
    ports:
      server: 8085
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel5
    uuid: 331fe59d-f445-4a18-ad73-713d5ad930c0
    highQuality:
      rtsp: /cam/realmonitor?channel=5&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=5&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=5&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=5&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:6f:cb:19:cb:b4
    ports:
      server: 8086
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel6
    uuid: 5d98340e-64ee-483e-a9ec-cce57895ecee
    highQuality:
      rtsp: /cam/realmonitor?channel=6&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=6&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=6&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=6&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:8e:81:a6:21:cb
    ports:
      server: 8087
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel7
    uuid: f9acdb73-60dd-40ec-89e2-2fc5f626498b
    highQuality:
      rtsp: /cam/realmonitor?channel=7&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=7&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=7&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=7&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:0b:70:bd:69:e3
    ports:
      server: 8088
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel8
    uuid: d57cc2c6-ed4f-41a5-9f44-0629bbc2d7a4
    highQuality:
      rtsp: /cam/realmonitor?channel=8&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=8&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=8&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=8&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:7e:32:58:29:12
    ports:
      server: 8089
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel9
    uuid: 6750d31b-e60c-4c1a-b228-d8193aea0416
    highQuality:
      rtsp: /cam/realmonitor?channel=9&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=9&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=9&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=9&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:cd:47:13:1b:73
    ports:
      server: 8090
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel10
    uuid: 40302eb9-682e-48be-abf3-352711aa084e
    highQuality:
      rtsp: /cam/realmonitor?channel=10&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=10&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=10&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=10&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:af:df:dd:a6:fc
    ports:
      server: 8091
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel11
    uuid: cb03b702-77e0-48a3-8255-de41ad377f6b
    highQuality:
      rtsp: /cam/realmonitor?channel=11&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=11&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=11&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=11&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:0e:71:51:f9:b6
    ports:
      server: 8092
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel12
    uuid: 160d736a-afa6-49ae-84c0-60b3df6cc556
    highQuality:
      rtsp: /cam/realmonitor?channel=12&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=12&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=12&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=12&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:dd:ac:2e:c6:b4
    ports:
      server: 8093
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel13
    uuid: 174728d2-4e51-4096-ab70-f13a79b7ea93
    highQuality:
      rtsp: /cam/realmonitor?channel=13&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=13&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=13&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=13&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:59:a5:04:df:d2
    ports:
      server: 8094
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel14
    uuid: 418e815e-b233-475d-8e6a-04f60dba4235
    highQuality:
      rtsp: /cam/realmonitor?channel=14&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=14&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=14&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=14&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:fd:fc:0e:8e:96
    ports:
      server: 8095
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel15
    uuid: 05460c5b-7ee9-4903-8043-5e8ee257bee5
    highQuality:
      rtsp: /cam/realmonitor?channel=15&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=15&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=15&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=15&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:a1:ef:84:32:1b
    ports:
      server: 8096
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel16
    uuid: 601fcdbd-9622-4867-bf3e-86ab1ba3d5ac
    highQuality:
      rtsp: /cam/realmonitor?channel=16&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=16&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=16&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=16&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:1f:4a:4d:dc:b2
    ports:
      server: 8097
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel17
    uuid: fa588c30-4ffa-49a0-9dd0-38c68a349c21
    highQuality:
      rtsp: /cam/realmonitor?channel=17&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=17&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=17&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=17&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:6c:df:c2:8a:e4
    ports:
      server: 8098
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel18
    uuid: e71db794-3ffa-41d9-ac48-80c6a8981645
    highQuality:
      rtsp: /cam/realmonitor?channel=18&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=18&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=18&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=18&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:78:5d:1d:93:13
    ports:
      server: 8099
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel19
    uuid: 8c6ce679-aba1-4a3e-863c-8d4af7902d10
    highQuality:
      rtsp: /cam/realmonitor?channel=19&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=19&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=19&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=19&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:72:0e:1c:6c:12
    ports:
      server: 8100
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel20
    uuid: 110c9023-6272-473e-89f0-634d00f32ecb
    highQuality:
      rtsp: /cam/realmonitor?channel=20&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=20&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=20&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=20&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:aa:e1:92:ad:20
    ports:
      server: 8101
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel21
    uuid: bf54a75f-8ed6-4e48-b7f1-2b468803d9ab
    highQuality:
      rtsp: /cam/realmonitor?channel=21&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=21&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=21&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=21&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:e6:59:ae:f7:cb
    ports:
      server: 8102
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel22
    uuid: 4f7aa653-bbbb-4850-8c21-aa536a372313
    highQuality:
      rtsp: /cam/realmonitor?channel=22&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=22&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=22&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=22&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:4a:b7:ec:94:0e
    ports:
      server: 8103
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel23
    uuid: e67d61db-dc24-421d-8708-73bfd29572ea
    highQuality:
      rtsp: /cam/realmonitor?channel=23&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=23&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=23&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=23&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:1c:0c:6f:7e:17
    ports:
      server: 8104
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel24
    uuid: 26cecdee-101a-4023-b58f-cd3a1ffedcb3
    highQuality:
      rtsp: /cam/realmonitor?channel=24&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=24&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=24&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=24&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:f7:53:82:11:5b
    ports:
      server: 8105
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel25
    uuid: d1dc60ad-a3dd-496f-b1de-6570a48c979f
    highQuality:
      rtsp: /cam/realmonitor?channel=25&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=25&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=25&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=25&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:a4:c8:2a:a6:14
    ports:
      server: 8106
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel26
    uuid: f229428a-074b-44f4-b3c7-df2864da9892
    highQuality:
      rtsp: /cam/realmonitor?channel=26&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=26&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=26&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=26&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:53:98:1d:1e:db
    ports:
      server: 8107
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel27
    uuid: 392dca09-f22c-456a-b4e4-74719a2f9a9c
    highQuality:
      rtsp: /cam/realmonitor?channel=27&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=27&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=27&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=27&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:d7:88:0d:33:6f
    ports:
      server: 8108
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel28
    uuid: 48021ee7-0766-4009-aa5e-c32beb9092ce
    highQuality:
      rtsp: /cam/realmonitor?channel=28&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=28&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=28&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=28&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:c3:5b:fb:ec:72
    ports:
      server: 8109
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel29
    uuid: 4df2e726-b4f1-4756-accc-1bd17955176a
    highQuality:
      rtsp: /cam/realmonitor?channel=29&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=29&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=29&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=29&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:29:3d:11:bc:3a
    ports:
      server: 8110
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel30
    uuid: c4da97e0-ad44-412e-8a9f-dab70d71caea
    highQuality:
      rtsp: /cam/realmonitor?channel=30&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=30&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=30&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=30&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:0f:dc:bc:54:b3
    ports:
      server: 8111
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel31
    uuid: 90b53d06-d815-40ab-9f20-20875ed54529
    highQuality:
      rtsp: /cam/realmonitor?channel=31&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=31&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=31&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=31&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:d0:19:ba:5b:68
    ports:
      server: 8112
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel32
    uuid: 7883577f-76fd-474f-bfb7-1297e49572eb
    highQuality:
      rtsp: /cam/realmonitor?channel=32&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=32&subtype=0
      width: 1280
      height: 720
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=32&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=32&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
</file>

<file path="config-combined.yaml">
onvif:
  - mac: 02:28:5c:53:db:b4
    ports:
      server: 8081
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel1
    uuid: e2a4a77e-5076-4ab6-92ab-729421ebe78b
    highQuality:
      rtsp: /cam/realmonitor?channel=1&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=1&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=1&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=1&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:ca:fe:ba:62:8d
    ports:
      server: 8082
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel2
    uuid: 67b2c9d5-a5fc-4b9e-8303-8365e116606f
    highQuality:
      rtsp: /cam/realmonitor?channel=2&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=2&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=2&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=2&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:b0:82:62:fa:d9
    ports:
      server: 8083
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel3
    uuid: 153b4e5e-7143-4b9d-a53d-73736756b242
    highQuality:
      rtsp: /cam/realmonitor?channel=3&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=3&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=3&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=3&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:09:84:94:24:75
    ports:
      server: 8084
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel4
    uuid: ab5a1029-b623-4cf4-9a64-0fcdd3b37f6e
    highQuality:
      rtsp: /cam/realmonitor?channel=4&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=4&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=4&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=4&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:20:5c:60:50:93
    ports:
      server: 8085
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel5
    uuid: a61419d0-bc55-4a3e-bc30-7596d8abe54d
    highQuality:
      rtsp: /cam/realmonitor?channel=5&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=5&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=5&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=5&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:6f:cb:19:cb:b4
    ports:
      server: 8086
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel6
    uuid: b6b21b73-6af0-4666-bdcd-81ad3d7d99e4
    highQuality:
      rtsp: /cam/realmonitor?channel=6&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=6&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=6&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=6&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:8e:81:a6:21:cb
    ports:
      server: 8087
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel7
    uuid: 511fcb56-1fe3-45b1-b29e-76126759bf27
    highQuality:
      rtsp: /cam/realmonitor?channel=7&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=7&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=7&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=7&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:0b:70:bd:69:e3
    ports:
      server: 8088
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel8
    uuid: 3e63a25e-d76f-41b7-9c3b-4744658547b3
    highQuality:
      rtsp: /cam/realmonitor?channel=8&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=8&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=8&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=8&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:7e:32:58:29:12
    ports:
      server: 8089
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel9
    uuid: d9e64501-478b-4f27-a103-961939122070
    highQuality:
      rtsp: /cam/realmonitor?channel=9&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=9&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=9&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=9&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:cd:47:13:1b:73
    ports:
      server: 8090
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel10
    uuid: bb45bc92-7b61-4933-891c-436de864e4bb
    highQuality:
      rtsp: /cam/realmonitor?channel=10&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=10&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=10&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=10&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:af:df:dd:a6:fc
    ports:
      server: 8091
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel11
    uuid: 344bc212-371a-424b-9374-a78125bcc14f
    highQuality:
      rtsp: /cam/realmonitor?channel=11&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=11&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=11&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=11&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:0e:71:51:f9:b6
    ports:
      server: 8092
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel12
    uuid: b4a4f6ae-cfb7-4853-8381-804724a5fd96
    highQuality:
      rtsp: /cam/realmonitor?channel=12&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=12&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=12&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=12&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:dd:ac:2e:c6:b4
    ports:
      server: 8093
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel13
    uuid: 5cb40532-dad8-456d-b285-22b8c72fb17e
    highQuality:
      rtsp: /cam/realmonitor?channel=13&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=13&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=13&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=13&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:59:a5:04:df:d2
    ports:
      server: 8094
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel14
    uuid: 66a73315-db51-4ceb-820a-426f9b02d860
    highQuality:
      rtsp: /cam/realmonitor?channel=14&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=14&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=14&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=14&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:fd:fc:0e:8e:96
    ports:
      server: 8095
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel15
    uuid: a3bf901a-31be-4b6a-bb36-dfd03a79154d
    highQuality:
      rtsp: /cam/realmonitor?channel=15&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=15&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=15&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=15&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:a1:ef:84:32:1b
    ports:
      server: 8096
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel16
    uuid: 5720f359-f23b-4350-98fa-9b3f25c51b41
    highQuality:
      rtsp: /cam/realmonitor?channel=16&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=16&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=16&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=16&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:1f:4a:4d:dc:b2
    ports:
      server: 8097
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel17
    uuid: 77a1bce2-7eec-484e-be6b-42f32189c34e
    highQuality:
      rtsp: /cam/realmonitor?channel=17&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=17&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=17&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=17&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:6c:df:c2:8a:e4
    ports:
      server: 8098
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel18
    uuid: bbf70441-95da-4f18-8071-d34b7210d33e
    highQuality:
      rtsp: /cam/realmonitor?channel=18&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=18&subtype=0
      width: 960
      height: 576
      framerate: 25
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=18&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=18&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:78:5d:1d:93:13
    ports:
      server: 8099
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel19
    uuid: 7e6edf29-8aa6-495d-81b6-7461db4bc61e
    highQuality:
      rtsp: /cam/realmonitor?channel=19&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=19&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=19&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=19&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:72:0e:1c:6c:12
    ports:
      server: 8100
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel20
    uuid: 29e0d899-8be7-4183-8777-b7f07084fade
    highQuality:
      rtsp: /cam/realmonitor?channel=20&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=20&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=20&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=20&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:aa:e1:92:ad:20
    ports:
      server: 8101
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel21
    uuid: 924855b7-555d-4bc5-a354-fc3b8e6c1b81
    highQuality:
      rtsp: /cam/realmonitor?channel=21&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=21&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=21&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=21&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:e6:59:ae:f7:cb
    ports:
      server: 8102
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel22
    uuid: f0f83c95-a875-4f93-a724-0ae87d30284a
    highQuality:
      rtsp: /cam/realmonitor?channel=22&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=22&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=22&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=22&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:4a:b7:ec:94:0e
    ports:
      server: 8103
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel23
    uuid: 60cfc1af-07da-4ff0-a3af-7cf62d5d0780
    highQuality:
      rtsp: /cam/realmonitor?channel=23&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=23&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=23&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=23&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:1c:0c:6f:7e:17
    ports:
      server: 8104
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel24
    uuid: 0eb1a769-bed0-4b5b-934c-f59ecadfc7f9
    highQuality:
      rtsp: /cam/realmonitor?channel=24&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=24&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=24&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=24&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:f7:53:82:11:5b
    ports:
      server: 8105
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel25
    uuid: b001dea0-226c-4cc1-8bc9-37e1ba7a01ea
    highQuality:
      rtsp: /cam/realmonitor?channel=25&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=25&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=25&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=25&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:a4:c8:2a:a6:14
    ports:
      server: 8106
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel26
    uuid: 29d793d8-5c79-418c-ace1-bed09fc75208
    highQuality:
      rtsp: /cam/realmonitor?channel=26&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=26&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=26&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=26&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:53:98:1d:1e:db
    ports:
      server: 8107
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel27
    uuid: beb947ef-7592-40b1-bb25-5d2d0d423b72
    highQuality:
      rtsp: /cam/realmonitor?channel=27&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=27&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=27&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=27&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:d7:88:0d:33:6f
    ports:
      server: 8108
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel28
    uuid: a21f41e2-ad3a-4887-915f-697aebe02e56
    highQuality:
      rtsp: /cam/realmonitor?channel=28&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=28&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=28&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=28&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:c3:5b:fb:ec:72
    ports:
      server: 8109
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel29
    uuid: b0e89a96-fa32-460e-84bd-113219fa98ab
    highQuality:
      rtsp: /cam/realmonitor?channel=29&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=29&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=29&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=29&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:29:3d:11:bc:3a
    ports:
      server: 8110
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel30
    uuid: 0f36f3a0-7cee-4f90-b6bb-fec9ca7d2241
    highQuality:
      rtsp: /cam/realmonitor?channel=30&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=30&subtype=0
      width: 960
      height: 1080
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=30&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=30&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:0f:dc:bc:54:b3
    ports:
      server: 8111
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel31
    uuid: a4a37688-94c8-4c3d-bb63-6e7ac1a6ef71
    highQuality:
      rtsp: /cam/realmonitor?channel=31&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=31&subtype=0
      width: 960
      height: 576
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=31&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=31&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
  - mac: 02:d0:19:ba:5b:68
    ports:
      server: 8112
      rtsp: 8554
      snapshot: 8580
    name: VideoSourceConfig_Channel32
    uuid: a8c58a2b-4fef-46b3-a5ce-f9b115501828
    highQuality:
      rtsp: /cam/realmonitor?channel=32&subtype=0&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=32&subtype=0
      width: 1280
      height: 720
      framerate: 15
      bitrate: 1024
      quality: 4
    lowQuality:
      rtsp: /cam/realmonitor?channel=32&subtype=1&unicast=true&proto=Onvif
      snapshot: /onvifsnapshot/media_service/snapshot?channel=32&subtype=1
      width: 352
      height: 288
      framerate: 7
      bitrate: 160
      quality: 1
    target:
      hostname: 192.168.6.201
      ports:
        rtsp: 554
        snapshot: 80
</file>

<file path="Dockerfile">
FROM node:22-alpine

ADD . /app
WORKDIR /app
RUN npm install

ENTRYPOINT node main.js /onvif.yaml
</file>

<file path="package.json">
{
  "name": "onvif-proxy",
  "version": "1.0.0",
  "description": "Onvif Proxy",
  "main": "main.js",
  "license": "MIT",
  "author": {
    "name": "Daniela Hasenbring",
    "email": "daniela@koshigaya.de"
  },
  "dependencies": {
    "soap": "1.1.5",
    "xml2js": "0.4.23",
    "node-tcp-proxy": "0.0.28",
    "node-uuid": "1.4.8",
    "argparse": "2.0.1",
    "yaml": "2.5.1",
    "simple-node-logger": "^21.8.12"
  }
}
</file>

<file path="setup-network-192.168.6.201.sh">
#!/bin/bash

# Network setup script for ONVIF virtual interfaces
# Generated for NVR: 192.168.6.201
# Generated on: 2025-04-17T14:25:05.273Z

# Get the physical interface name (look for the interface with the host IP)
HOST_IP=$(hostname -I | awk '{print $1}')
PHYS_IFACE=$(ip -o addr show | grep "$HOST_IP" | grep -v macvlan | awk '{print $2}' | cut -d':' -f1)
if [ -z "$PHYS_IFACE" ]; then
    echo "Error: Could not determine physical interface"
    exit 1
fi
echo "Using physical interface: $PHYS_IFACE"
# Configure ARP settings for physical interface
echo "Configuring ARP settings for physical interface $PHYS_IFACE..."
echo 1 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_announce

# Parse command line arguments
USE_DHCP=false # Default to static IPs
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --dhcp) USE_DHCP=true ;;
        *) echo "Unknown parameter: $1"; exit 1 ;;
    esac
    shift
done

# Check if dhclient is installed when using DHCP
if [ "$USE_DHCP" = true ] && ! command -v dhclient &> /dev/null; then
    echo "dhclient not found. Please install it with:"
    echo "  sudo apt-get install isc-dhcp-client    (for Debian/Ubuntu)"
    echo "  sudo yum install dhcp-client            (for CentOS/RHEL)"
    echo "Or use --static to assign static IPs instead."
    exit 1
fi

# Create a mapping file for MAC to interface name and IP
cat > mac_to_interface.txt << EOF
02:28:5c:53:db:b4 onv1_dbb4 192.168.6.3
02:ca:fe:ba:62:8d onv2_628d 192.168.6.4
02:b0:82:62:fa:d9 onv3_fad9 192.168.6.5
02:09:84:94:24:75 onv4_2475 192.168.6.6
02:20:5c:60:50:93 onv5_5093 192.168.6.7
02:6f:cb:19:cb:b4 onv6_cbb4 192.168.6.8
02:8e:81:a6:21:cb onv7_21cb 192.168.6.9
02:0b:70:bd:69:e3 onv8_69e3 192.168.6.10
02:7e:32:58:29:12 onv9_2912 192.168.6.11
02:cd:47:13:1b:73 onv10_1b73 192.168.6.12
02:af:df:dd:a6:fc onv11_a6fc 192.168.6.13
02:0e:71:51:f9:b6 onv12_f9b6 192.168.6.14
02:dd:ac:2e:c6:b4 onv13_c6b4 192.168.6.15
02:59:a5:04:df:d2 onv14_dfd2 192.168.6.16
02:fd:fc:0e:8e:96 onv15_8e96 192.168.6.17
02:a1:ef:84:32:1b onv16_321b 192.168.6.18
02:1f:4a:4d:dc:b2 onv17_dcb2 192.168.6.19
02:6c:df:c2:8a:e4 onv18_8ae4 192.168.6.20
02:78:5d:1d:93:13 onv19_9313 192.168.6.21
02:72:0e:1c:6c:12 onv20_6c12 192.168.6.22
02:aa:e1:92:ad:20 onv21_ad20 192.168.6.23
02:e6:59:ae:f7:cb onv22_f7cb 192.168.6.24
02:4a:b7:ec:94:0e onv23_940e 192.168.6.25
02:1c:0c:6f:7e:17 onv24_7e17 192.168.6.26
02:f7:53:82:11:5b onv25_115b 192.168.6.27
02:a4:c8:2a:a6:14 onv26_a614 192.168.6.28
02:53:98:1d:1e:db onv27_1edb 192.168.6.29
02:d7:88:0d:33:6f onv28_336f 192.168.6.30
02:c3:5b:fb:ec:72 onv29_ec72 192.168.6.31
02:29:3d:11:bc:3a onv30_bc3a 192.168.6.32
02:0f:dc:bc:54:b3 onv31_54b3 192.168.6.33
02:d0:19:ba:5b:68 onv32_5b68 192.168.6.34
EOF

# Remove any existing interfaces first
ip link show onv1_dbb4 > /dev/null 2>&1 && ip link delete onv1_dbb4
ip link show onv2_628d > /dev/null 2>&1 && ip link delete onv2_628d
ip link show onv3_fad9 > /dev/null 2>&1 && ip link delete onv3_fad9
ip link show onv4_2475 > /dev/null 2>&1 && ip link delete onv4_2475
ip link show onv5_5093 > /dev/null 2>&1 && ip link delete onv5_5093
ip link show onv6_cbb4 > /dev/null 2>&1 && ip link delete onv6_cbb4
ip link show onv7_21cb > /dev/null 2>&1 && ip link delete onv7_21cb
ip link show onv8_69e3 > /dev/null 2>&1 && ip link delete onv8_69e3
ip link show onv9_2912 > /dev/null 2>&1 && ip link delete onv9_2912
ip link show onv10_1b73 > /dev/null 2>&1 && ip link delete onv10_1b73
ip link show onv11_a6fc > /dev/null 2>&1 && ip link delete onv11_a6fc
ip link show onv12_f9b6 > /dev/null 2>&1 && ip link delete onv12_f9b6
ip link show onv13_c6b4 > /dev/null 2>&1 && ip link delete onv13_c6b4
ip link show onv14_dfd2 > /dev/null 2>&1 && ip link delete onv14_dfd2
ip link show onv15_8e96 > /dev/null 2>&1 && ip link delete onv15_8e96
ip link show onv16_321b > /dev/null 2>&1 && ip link delete onv16_321b
ip link show onv17_dcb2 > /dev/null 2>&1 && ip link delete onv17_dcb2
ip link show onv18_8ae4 > /dev/null 2>&1 && ip link delete onv18_8ae4
ip link show onv19_9313 > /dev/null 2>&1 && ip link delete onv19_9313
ip link show onv20_6c12 > /dev/null 2>&1 && ip link delete onv20_6c12
ip link show onv21_ad20 > /dev/null 2>&1 && ip link delete onv21_ad20
ip link show onv22_f7cb > /dev/null 2>&1 && ip link delete onv22_f7cb
ip link show onv23_940e > /dev/null 2>&1 && ip link delete onv23_940e
ip link show onv24_7e17 > /dev/null 2>&1 && ip link delete onv24_7e17
ip link show onv25_115b > /dev/null 2>&1 && ip link delete onv25_115b
ip link show onv26_a614 > /dev/null 2>&1 && ip link delete onv26_a614
ip link show onv27_1edb > /dev/null 2>&1 && ip link delete onv27_1edb
ip link show onv28_336f > /dev/null 2>&1 && ip link delete onv28_336f
ip link show onv29_ec72 > /dev/null 2>&1 && ip link delete onv29_ec72
ip link show onv30_bc3a > /dev/null 2>&1 && ip link delete onv30_bc3a
ip link show onv31_54b3 > /dev/null 2>&1 && ip link delete onv31_54b3
ip link show onv32_5b68 > /dev/null 2>&1 && ip link delete onv32_5b68

# Create new virtual interfaces
echo "Creating macvlan interface onv1_dbb4..."
ip link add onv1_dbb4 link $PHYS_IFACE address 02:28:5c:53:db:b4 type macvlan mode bridge
ip link set onv1_dbb4 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv1_dbb4 via DHCP..."
    dhclient -v onv1_dbb4 &
else
    echo "Assigning static IP 192.168.6.3/24 to onv1_dbb4..."
    ip addr add 192.168.6.3/24 dev onv1_dbb4
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv1_dbb4/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv1_dbb4/arp_announce

echo "Creating macvlan interface onv2_628d..."
ip link add onv2_628d link $PHYS_IFACE address 02:ca:fe:ba:62:8d type macvlan mode bridge
ip link set onv2_628d up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv2_628d via DHCP..."
    dhclient -v onv2_628d &
else
    echo "Assigning static IP 192.168.6.4/24 to onv2_628d..."
    ip addr add 192.168.6.4/24 dev onv2_628d
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv2_628d/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv2_628d/arp_announce

echo "Creating macvlan interface onv3_fad9..."
ip link add onv3_fad9 link $PHYS_IFACE address 02:b0:82:62:fa:d9 type macvlan mode bridge
ip link set onv3_fad9 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv3_fad9 via DHCP..."
    dhclient -v onv3_fad9 &
else
    echo "Assigning static IP 192.168.6.5/24 to onv3_fad9..."
    ip addr add 192.168.6.5/24 dev onv3_fad9
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv3_fad9/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv3_fad9/arp_announce

echo "Creating macvlan interface onv4_2475..."
ip link add onv4_2475 link $PHYS_IFACE address 02:09:84:94:24:75 type macvlan mode bridge
ip link set onv4_2475 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv4_2475 via DHCP..."
    dhclient -v onv4_2475 &
else
    echo "Assigning static IP 192.168.6.6/24 to onv4_2475..."
    ip addr add 192.168.6.6/24 dev onv4_2475
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv4_2475/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv4_2475/arp_announce

echo "Creating macvlan interface onv5_5093..."
ip link add onv5_5093 link $PHYS_IFACE address 02:20:5c:60:50:93 type macvlan mode bridge
ip link set onv5_5093 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv5_5093 via DHCP..."
    dhclient -v onv5_5093 &
else
    echo "Assigning static IP 192.168.6.7/24 to onv5_5093..."
    ip addr add 192.168.6.7/24 dev onv5_5093
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv5_5093/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv5_5093/arp_announce

echo "Creating macvlan interface onv6_cbb4..."
ip link add onv6_cbb4 link $PHYS_IFACE address 02:6f:cb:19:cb:b4 type macvlan mode bridge
ip link set onv6_cbb4 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv6_cbb4 via DHCP..."
    dhclient -v onv6_cbb4 &
else
    echo "Assigning static IP 192.168.6.8/24 to onv6_cbb4..."
    ip addr add 192.168.6.8/24 dev onv6_cbb4
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv6_cbb4/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv6_cbb4/arp_announce

echo "Creating macvlan interface onv7_21cb..."
ip link add onv7_21cb link $PHYS_IFACE address 02:8e:81:a6:21:cb type macvlan mode bridge
ip link set onv7_21cb up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv7_21cb via DHCP..."
    dhclient -v onv7_21cb &
else
    echo "Assigning static IP 192.168.6.9/24 to onv7_21cb..."
    ip addr add 192.168.6.9/24 dev onv7_21cb
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv7_21cb/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv7_21cb/arp_announce

echo "Creating macvlan interface onv8_69e3..."
ip link add onv8_69e3 link $PHYS_IFACE address 02:0b:70:bd:69:e3 type macvlan mode bridge
ip link set onv8_69e3 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv8_69e3 via DHCP..."
    dhclient -v onv8_69e3 &
else
    echo "Assigning static IP 192.168.6.10/24 to onv8_69e3..."
    ip addr add 192.168.6.10/24 dev onv8_69e3
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv8_69e3/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv8_69e3/arp_announce

echo "Creating macvlan interface onv9_2912..."
ip link add onv9_2912 link $PHYS_IFACE address 02:7e:32:58:29:12 type macvlan mode bridge
ip link set onv9_2912 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv9_2912 via DHCP..."
    dhclient -v onv9_2912 &
else
    echo "Assigning static IP 192.168.6.11/24 to onv9_2912..."
    ip addr add 192.168.6.11/24 dev onv9_2912
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv9_2912/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv9_2912/arp_announce

echo "Creating macvlan interface onv10_1b73..."
ip link add onv10_1b73 link $PHYS_IFACE address 02:cd:47:13:1b:73 type macvlan mode bridge
ip link set onv10_1b73 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv10_1b73 via DHCP..."
    dhclient -v onv10_1b73 &
else
    echo "Assigning static IP 192.168.6.12/24 to onv10_1b73..."
    ip addr add 192.168.6.12/24 dev onv10_1b73
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv10_1b73/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv10_1b73/arp_announce

echo "Creating macvlan interface onv11_a6fc..."
ip link add onv11_a6fc link $PHYS_IFACE address 02:af:df:dd:a6:fc type macvlan mode bridge
ip link set onv11_a6fc up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv11_a6fc via DHCP..."
    dhclient -v onv11_a6fc &
else
    echo "Assigning static IP 192.168.6.13/24 to onv11_a6fc..."
    ip addr add 192.168.6.13/24 dev onv11_a6fc
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv11_a6fc/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv11_a6fc/arp_announce

echo "Creating macvlan interface onv12_f9b6..."
ip link add onv12_f9b6 link $PHYS_IFACE address 02:0e:71:51:f9:b6 type macvlan mode bridge
ip link set onv12_f9b6 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv12_f9b6 via DHCP..."
    dhclient -v onv12_f9b6 &
else
    echo "Assigning static IP 192.168.6.14/24 to onv12_f9b6..."
    ip addr add 192.168.6.14/24 dev onv12_f9b6
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv12_f9b6/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv12_f9b6/arp_announce

echo "Creating macvlan interface onv13_c6b4..."
ip link add onv13_c6b4 link $PHYS_IFACE address 02:dd:ac:2e:c6:b4 type macvlan mode bridge
ip link set onv13_c6b4 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv13_c6b4 via DHCP..."
    dhclient -v onv13_c6b4 &
else
    echo "Assigning static IP 192.168.6.15/24 to onv13_c6b4..."
    ip addr add 192.168.6.15/24 dev onv13_c6b4
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv13_c6b4/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv13_c6b4/arp_announce

echo "Creating macvlan interface onv14_dfd2..."
ip link add onv14_dfd2 link $PHYS_IFACE address 02:59:a5:04:df:d2 type macvlan mode bridge
ip link set onv14_dfd2 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv14_dfd2 via DHCP..."
    dhclient -v onv14_dfd2 &
else
    echo "Assigning static IP 192.168.6.16/24 to onv14_dfd2..."
    ip addr add 192.168.6.16/24 dev onv14_dfd2
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv14_dfd2/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv14_dfd2/arp_announce

echo "Creating macvlan interface onv15_8e96..."
ip link add onv15_8e96 link $PHYS_IFACE address 02:fd:fc:0e:8e:96 type macvlan mode bridge
ip link set onv15_8e96 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv15_8e96 via DHCP..."
    dhclient -v onv15_8e96 &
else
    echo "Assigning static IP 192.168.6.17/24 to onv15_8e96..."
    ip addr add 192.168.6.17/24 dev onv15_8e96
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv15_8e96/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv15_8e96/arp_announce

echo "Creating macvlan interface onv16_321b..."
ip link add onv16_321b link $PHYS_IFACE address 02:a1:ef:84:32:1b type macvlan mode bridge
ip link set onv16_321b up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv16_321b via DHCP..."
    dhclient -v onv16_321b &
else
    echo "Assigning static IP 192.168.6.18/24 to onv16_321b..."
    ip addr add 192.168.6.18/24 dev onv16_321b
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv16_321b/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv16_321b/arp_announce

echo "Creating macvlan interface onv17_dcb2..."
ip link add onv17_dcb2 link $PHYS_IFACE address 02:1f:4a:4d:dc:b2 type macvlan mode bridge
ip link set onv17_dcb2 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv17_dcb2 via DHCP..."
    dhclient -v onv17_dcb2 &
else
    echo "Assigning static IP 192.168.6.19/24 to onv17_dcb2..."
    ip addr add 192.168.6.19/24 dev onv17_dcb2
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv17_dcb2/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv17_dcb2/arp_announce

echo "Creating macvlan interface onv18_8ae4..."
ip link add onv18_8ae4 link $PHYS_IFACE address 02:6c:df:c2:8a:e4 type macvlan mode bridge
ip link set onv18_8ae4 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv18_8ae4 via DHCP..."
    dhclient -v onv18_8ae4 &
else
    echo "Assigning static IP 192.168.6.20/24 to onv18_8ae4..."
    ip addr add 192.168.6.20/24 dev onv18_8ae4
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv18_8ae4/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv18_8ae4/arp_announce

echo "Creating macvlan interface onv19_9313..."
ip link add onv19_9313 link $PHYS_IFACE address 02:78:5d:1d:93:13 type macvlan mode bridge
ip link set onv19_9313 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv19_9313 via DHCP..."
    dhclient -v onv19_9313 &
else
    echo "Assigning static IP 192.168.6.21/24 to onv19_9313..."
    ip addr add 192.168.6.21/24 dev onv19_9313
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv19_9313/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv19_9313/arp_announce

echo "Creating macvlan interface onv20_6c12..."
ip link add onv20_6c12 link $PHYS_IFACE address 02:72:0e:1c:6c:12 type macvlan mode bridge
ip link set onv20_6c12 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv20_6c12 via DHCP..."
    dhclient -v onv20_6c12 &
else
    echo "Assigning static IP 192.168.6.22/24 to onv20_6c12..."
    ip addr add 192.168.6.22/24 dev onv20_6c12
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv20_6c12/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv20_6c12/arp_announce

echo "Creating macvlan interface onv21_ad20..."
ip link add onv21_ad20 link $PHYS_IFACE address 02:aa:e1:92:ad:20 type macvlan mode bridge
ip link set onv21_ad20 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv21_ad20 via DHCP..."
    dhclient -v onv21_ad20 &
else
    echo "Assigning static IP 192.168.6.23/24 to onv21_ad20..."
    ip addr add 192.168.6.23/24 dev onv21_ad20
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv21_ad20/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv21_ad20/arp_announce

echo "Creating macvlan interface onv22_f7cb..."
ip link add onv22_f7cb link $PHYS_IFACE address 02:e6:59:ae:f7:cb type macvlan mode bridge
ip link set onv22_f7cb up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv22_f7cb via DHCP..."
    dhclient -v onv22_f7cb &
else
    echo "Assigning static IP 192.168.6.24/24 to onv22_f7cb..."
    ip addr add 192.168.6.24/24 dev onv22_f7cb
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv22_f7cb/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv22_f7cb/arp_announce

echo "Creating macvlan interface onv23_940e..."
ip link add onv23_940e link $PHYS_IFACE address 02:4a:b7:ec:94:0e type macvlan mode bridge
ip link set onv23_940e up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv23_940e via DHCP..."
    dhclient -v onv23_940e &
else
    echo "Assigning static IP 192.168.6.25/24 to onv23_940e..."
    ip addr add 192.168.6.25/24 dev onv23_940e
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv23_940e/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv23_940e/arp_announce

echo "Creating macvlan interface onv24_7e17..."
ip link add onv24_7e17 link $PHYS_IFACE address 02:1c:0c:6f:7e:17 type macvlan mode bridge
ip link set onv24_7e17 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv24_7e17 via DHCP..."
    dhclient -v onv24_7e17 &
else
    echo "Assigning static IP 192.168.6.26/24 to onv24_7e17..."
    ip addr add 192.168.6.26/24 dev onv24_7e17
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv24_7e17/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv24_7e17/arp_announce

echo "Creating macvlan interface onv25_115b..."
ip link add onv25_115b link $PHYS_IFACE address 02:f7:53:82:11:5b type macvlan mode bridge
ip link set onv25_115b up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv25_115b via DHCP..."
    dhclient -v onv25_115b &
else
    echo "Assigning static IP 192.168.6.27/24 to onv25_115b..."
    ip addr add 192.168.6.27/24 dev onv25_115b
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv25_115b/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv25_115b/arp_announce

echo "Creating macvlan interface onv26_a614..."
ip link add onv26_a614 link $PHYS_IFACE address 02:a4:c8:2a:a6:14 type macvlan mode bridge
ip link set onv26_a614 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv26_a614 via DHCP..."
    dhclient -v onv26_a614 &
else
    echo "Assigning static IP 192.168.6.28/24 to onv26_a614..."
    ip addr add 192.168.6.28/24 dev onv26_a614
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv26_a614/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv26_a614/arp_announce

echo "Creating macvlan interface onv27_1edb..."
ip link add onv27_1edb link $PHYS_IFACE address 02:53:98:1d:1e:db type macvlan mode bridge
ip link set onv27_1edb up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv27_1edb via DHCP..."
    dhclient -v onv27_1edb &
else
    echo "Assigning static IP 192.168.6.29/24 to onv27_1edb..."
    ip addr add 192.168.6.29/24 dev onv27_1edb
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv27_1edb/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv27_1edb/arp_announce

echo "Creating macvlan interface onv28_336f..."
ip link add onv28_336f link $PHYS_IFACE address 02:d7:88:0d:33:6f type macvlan mode bridge
ip link set onv28_336f up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv28_336f via DHCP..."
    dhclient -v onv28_336f &
else
    echo "Assigning static IP 192.168.6.30/24 to onv28_336f..."
    ip addr add 192.168.6.30/24 dev onv28_336f
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv28_336f/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv28_336f/arp_announce

echo "Creating macvlan interface onv29_ec72..."
ip link add onv29_ec72 link $PHYS_IFACE address 02:c3:5b:fb:ec:72 type macvlan mode bridge
ip link set onv29_ec72 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv29_ec72 via DHCP..."
    dhclient -v onv29_ec72 &
else
    echo "Assigning static IP 192.168.6.31/24 to onv29_ec72..."
    ip addr add 192.168.6.31/24 dev onv29_ec72
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv29_ec72/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv29_ec72/arp_announce

echo "Creating macvlan interface onv30_bc3a..."
ip link add onv30_bc3a link $PHYS_IFACE address 02:29:3d:11:bc:3a type macvlan mode bridge
ip link set onv30_bc3a up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv30_bc3a via DHCP..."
    dhclient -v onv30_bc3a &
else
    echo "Assigning static IP 192.168.6.32/24 to onv30_bc3a..."
    ip addr add 192.168.6.32/24 dev onv30_bc3a
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv30_bc3a/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv30_bc3a/arp_announce

echo "Creating macvlan interface onv31_54b3..."
ip link add onv31_54b3 link $PHYS_IFACE address 02:0f:dc:bc:54:b3 type macvlan mode bridge
ip link set onv31_54b3 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv31_54b3 via DHCP..."
    dhclient -v onv31_54b3 &
else
    echo "Assigning static IP 192.168.6.33/24 to onv31_54b3..."
    ip addr add 192.168.6.33/24 dev onv31_54b3
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv31_54b3/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv31_54b3/arp_announce

echo "Creating macvlan interface onv32_5b68..."
ip link add onv32_5b68 link $PHYS_IFACE address 02:d0:19:ba:5b:68 type macvlan mode bridge
ip link set onv32_5b68 up
if [ "$USE_DHCP" = true ]; then
    echo "Requesting IP address for onv32_5b68 via DHCP..."
    dhclient -v onv32_5b68 &
else
    echo "Assigning static IP 192.168.6.34/24 to onv32_5b68..."
    ip addr add 192.168.6.34/24 dev onv32_5b68
fi

# Configure ARP to prevent issues with multiple interfaces
echo "Configuring ARP settings..."
echo 1 > /proc/sys/net/ipv4/conf/onv32_5b68/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv32_5b68/arp_announce

# Wait for IP assignment to complete and display IP addresses
sleep 3
echo "Virtual interface IP addresses:"
ip -4 addr show | grep -A 2 "onv" | grep -v "valid_lft"

echo "Static IP assignment is the default. To use DHCP instead, run: sudo $0 --dhcp"
</file>

<file path="setup-network-combined.sh">
#!/bin/bash

# Combined network setup script for multiple ONVIF virtual interfaces
# Generated for NVRs: 192.168.6.201, 192.168.6.202, 192.168.6.204
# Generated on: 2025-04-17T14:25:39.766Z

# Get the physical interface name (look for the interface with the host IP)
HOST_IP=$(hostname -I | awk '{print $1}')
PHYS_IFACE=$(ip -o addr show | grep "$HOST_IP" | grep -v macvlan | awk '{print $2}' | cut -d':' -f1)
if [ -z "$PHYS_IFACE" ]; then
    echo "Error: Could not determine physical interface"
    exit 1
fi
echo "Using physical interface: $PHYS_IFACE"
# Configure ARP settings for physical interface
echo "Configuring ARP settings for physical interface $PHYS_IFACE..."
echo 1 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_announce

# Create a mapping file for MAC to interface name and IP
cat > mac_to_interface.txt << EOF
02:28:5c:53:db:b4 onv1_dbb4 192.168.6.3
02:ca:fe:ba:62:8d onv2_628d 192.168.6.4
02:b0:82:62:fa:d9 onv3_fad9 192.168.6.5
02:09:84:94:24:75 onv4_2475 192.168.6.6
02:20:5c:60:50:93 onv5_5093 192.168.6.7
02:6f:cb:19:cb:b4 onv6_cbb4 192.168.6.8
02:8e:81:a6:21:cb onv7_21cb 192.168.6.9
02:0b:70:bd:69:e3 onv8_69e3 192.168.6.10
02:7e:32:58:29:12 onv9_2912 192.168.6.11
02:cd:47:13:1b:73 onv10_1b73 192.168.6.12
02:af:df:dd:a6:fc onv11_a6fc 192.168.6.13
02:0e:71:51:f9:b6 onv12_f9b6 192.168.6.14
02:dd:ac:2e:c6:b4 onv13_c6b4 192.168.6.15
02:59:a5:04:df:d2 onv14_dfd2 192.168.6.16
02:fd:fc:0e:8e:96 onv15_8e96 192.168.6.17
02:a1:ef:84:32:1b onv16_321b 192.168.6.18
02:1f:4a:4d:dc:b2 onv17_dcb2 192.168.6.19
02:6c:df:c2:8a:e4 onv18_8ae4 192.168.6.20
02:78:5d:1d:93:13 onv19_9313 192.168.6.21
02:72:0e:1c:6c:12 onv20_6c12 192.168.6.22
02:aa:e1:92:ad:20 onv21_ad20 192.168.6.23
02:e6:59:ae:f7:cb onv22_f7cb 192.168.6.24
02:4a:b7:ec:94:0e onv23_940e 192.168.6.25
02:1c:0c:6f:7e:17 onv24_7e17 192.168.6.26
02:f7:53:82:11:5b onv25_115b 192.168.6.27
02:a4:c8:2a:a6:14 onv26_a614 192.168.6.28
02:53:98:1d:1e:db onv27_1edb 192.168.6.29
02:d7:88:0d:33:6f onv28_336f 192.168.6.30
02:c3:5b:fb:ec:72 onv29_ec72 192.168.6.31
02:29:3d:11:bc:3a onv30_bc3a 192.168.6.32
02:0f:dc:bc:54:b3 onv31_54b3 192.168.6.33
02:d0:19:ba:5b:68 onv32_5b68 192.168.6.34
02:cc:00:d2:a6:c3 onv33_a6c3 192.168.6.35
02:c9:54:34:84:df onv34_84df 192.168.6.36
02:90:67:6b:60:43 onv35_6043 192.168.6.37
02:6f:ea:dc:25:89 onv36_2589 192.168.6.38
02:27:2b:64:d0:20 onv37_d020 192.168.6.39
02:92:d2:00:e6:ae onv38_e6ae 192.168.6.40
02:37:e5:a8:a6:04 onv39_a604 192.168.6.41
02:bc:83:1a:dc:a0 onv40_dca0 192.168.6.42
02:eb:6c:a6:68:8a onv41_688a 192.168.6.43
02:39:b8:15:6a:af onv42_6aaf 192.168.6.44
02:c8:5b:d2:94:9e onv43_949e 192.168.6.45
02:ff:43:d3:a5:6d onv44_a56d 192.168.6.46
02:50:e1:ff:17:7e onv45_177e 192.168.6.47
02:6e:97:6b:39:e3 onv46_39e3 192.168.6.48
02:f8:26:39:03:d0 onv47_03d0 192.168.6.49
02:80:c4:d4:58:00 onv48_5800 192.168.6.50
02:6c:7c:51:4a:6c onv49_4a6c 192.168.6.51
02:b5:d3:59:6d:bd onv50_6dbd 192.168.6.52
02:4c:f8:89:fa:84 onv51_fa84 192.168.6.53
02:82:f7:19:d6:f1 onv52_d6f1 192.168.6.54
02:7e:89:ae:44:e8 onv53_44e8 192.168.6.55
02:a0:63:ad:b1:b3 onv54_b1b3 192.168.6.56
02:e1:6c:9f:03:bc onv55_03bc 192.168.6.57
02:8e:6d:14:07:3c onv56_073c 192.168.6.58
02:b0:6e:26:a2:e4 onv57_a2e4 192.168.6.59
02:46:2f:98:d7:54 onv58_d754 192.168.6.60
02:3a:1e:84:f3:c2 onv59_f3c2 192.168.6.61
02:a3:bc:f6:98:a9 onv60_98a9 192.168.6.62
02:24:14:61:07:0d onv61_070d 192.168.6.63
02:a3:ae:c0:be:3c onv62_be3c 192.168.6.64
02:b0:46:fe:30:9d onv63_309d 192.168.6.65
02:b6:10:34:57:93 onv64_5793 192.168.6.66
02:bb:98:b9:82:19 onv65_8219 192.168.6.67
02:24:71:07:ae:ac onv66_aeac 192.168.6.68
02:90:98:73:cd:28 onv67_cd28 192.168.6.69
02:6a:9d:c1:d5:73 onv68_d573 192.168.6.70
02:e2:45:72:05:71 onv69_0571 192.168.6.71
02:50:e8:40:c0:87 onv70_c087 192.168.6.72
02:98:a9:71:83:b6 onv71_83b6 192.168.6.73
02:3b:8a:2e:56:ea onv72_56ea 192.168.6.74
02:c1:b2:86:21:71 onv73_2171 192.168.6.75
02:02:f6:54:16:69 onv74_1669 192.168.6.76
02:bd:6c:9e:96:16 onv75_9616 192.168.6.77
02:0f:b3:45:69:5c onv76_695c 192.168.6.78
02:8a:8f:f6:b8:34 onv77_b834 192.168.6.79
02:fb:78:8e:91:ee onv78_91ee 192.168.6.80
02:0d:ba:c1:63:b2 onv79_63b2 192.168.6.81
02:91:59:0f:42:45 onv80_4245 192.168.6.82
EOF

# Remove any existing interfaces first
ip link show onv1_dbb4 > /dev/null 2>&1 && ip link delete onv1_dbb4
ip link show onv2_628d > /dev/null 2>&1 && ip link delete onv2_628d
ip link show onv3_fad9 > /dev/null 2>&1 && ip link delete onv3_fad9
ip link show onv4_2475 > /dev/null 2>&1 && ip link delete onv4_2475
ip link show onv5_5093 > /dev/null 2>&1 && ip link delete onv5_5093
ip link show onv6_cbb4 > /dev/null 2>&1 && ip link delete onv6_cbb4
ip link show onv7_21cb > /dev/null 2>&1 && ip link delete onv7_21cb
ip link show onv8_69e3 > /dev/null 2>&1 && ip link delete onv8_69e3
ip link show onv9_2912 > /dev/null 2>&1 && ip link delete onv9_2912
ip link show onv10_1b73 > /dev/null 2>&1 && ip link delete onv10_1b73
ip link show onv11_a6fc > /dev/null 2>&1 && ip link delete onv11_a6fc
ip link show onv12_f9b6 > /dev/null 2>&1 && ip link delete onv12_f9b6
ip link show onv13_c6b4 > /dev/null 2>&1 && ip link delete onv13_c6b4
ip link show onv14_dfd2 > /dev/null 2>&1 && ip link delete onv14_dfd2
ip link show onv15_8e96 > /dev/null 2>&1 && ip link delete onv15_8e96
ip link show onv16_321b > /dev/null 2>&1 && ip link delete onv16_321b
ip link show onv17_dcb2 > /dev/null 2>&1 && ip link delete onv17_dcb2
ip link show onv18_8ae4 > /dev/null 2>&1 && ip link delete onv18_8ae4
ip link show onv19_9313 > /dev/null 2>&1 && ip link delete onv19_9313
ip link show onv20_6c12 > /dev/null 2>&1 && ip link delete onv20_6c12
ip link show onv21_ad20 > /dev/null 2>&1 && ip link delete onv21_ad20
ip link show onv22_f7cb > /dev/null 2>&1 && ip link delete onv22_f7cb
ip link show onv23_940e > /dev/null 2>&1 && ip link delete onv23_940e
ip link show onv24_7e17 > /dev/null 2>&1 && ip link delete onv24_7e17
ip link show onv25_115b > /dev/null 2>&1 && ip link delete onv25_115b
ip link show onv26_a614 > /dev/null 2>&1 && ip link delete onv26_a614
ip link show onv27_1edb > /dev/null 2>&1 && ip link delete onv27_1edb
ip link show onv28_336f > /dev/null 2>&1 && ip link delete onv28_336f
ip link show onv29_ec72 > /dev/null 2>&1 && ip link delete onv29_ec72
ip link show onv30_bc3a > /dev/null 2>&1 && ip link delete onv30_bc3a
ip link show onv31_54b3 > /dev/null 2>&1 && ip link delete onv31_54b3
ip link show onv32_5b68 > /dev/null 2>&1 && ip link delete onv32_5b68
ip link show onv33_a6c3 > /dev/null 2>&1 && ip link delete onv33_a6c3
ip link show onv34_84df > /dev/null 2>&1 && ip link delete onv34_84df
ip link show onv35_6043 > /dev/null 2>&1 && ip link delete onv35_6043
ip link show onv36_2589 > /dev/null 2>&1 && ip link delete onv36_2589
ip link show onv37_d020 > /dev/null 2>&1 && ip link delete onv37_d020
ip link show onv38_e6ae > /dev/null 2>&1 && ip link delete onv38_e6ae
ip link show onv39_a604 > /dev/null 2>&1 && ip link delete onv39_a604
ip link show onv40_dca0 > /dev/null 2>&1 && ip link delete onv40_dca0
ip link show onv41_688a > /dev/null 2>&1 && ip link delete onv41_688a
ip link show onv42_6aaf > /dev/null 2>&1 && ip link delete onv42_6aaf
ip link show onv43_949e > /dev/null 2>&1 && ip link delete onv43_949e
ip link show onv44_a56d > /dev/null 2>&1 && ip link delete onv44_a56d
ip link show onv45_177e > /dev/null 2>&1 && ip link delete onv45_177e
ip link show onv46_39e3 > /dev/null 2>&1 && ip link delete onv46_39e3
ip link show onv47_03d0 > /dev/null 2>&1 && ip link delete onv47_03d0
ip link show onv48_5800 > /dev/null 2>&1 && ip link delete onv48_5800
ip link show onv49_4a6c > /dev/null 2>&1 && ip link delete onv49_4a6c
ip link show onv50_6dbd > /dev/null 2>&1 && ip link delete onv50_6dbd
ip link show onv51_fa84 > /dev/null 2>&1 && ip link delete onv51_fa84
ip link show onv52_d6f1 > /dev/null 2>&1 && ip link delete onv52_d6f1
ip link show onv53_44e8 > /dev/null 2>&1 && ip link delete onv53_44e8
ip link show onv54_b1b3 > /dev/null 2>&1 && ip link delete onv54_b1b3
ip link show onv55_03bc > /dev/null 2>&1 && ip link delete onv55_03bc
ip link show onv56_073c > /dev/null 2>&1 && ip link delete onv56_073c
ip link show onv57_a2e4 > /dev/null 2>&1 && ip link delete onv57_a2e4
ip link show onv58_d754 > /dev/null 2>&1 && ip link delete onv58_d754
ip link show onv59_f3c2 > /dev/null 2>&1 && ip link delete onv59_f3c2
ip link show onv60_98a9 > /dev/null 2>&1 && ip link delete onv60_98a9
ip link show onv61_070d > /dev/null 2>&1 && ip link delete onv61_070d
ip link show onv62_be3c > /dev/null 2>&1 && ip link delete onv62_be3c
ip link show onv63_309d > /dev/null 2>&1 && ip link delete onv63_309d
ip link show onv64_5793 > /dev/null 2>&1 && ip link delete onv64_5793
ip link show onv65_8219 > /dev/null 2>&1 && ip link delete onv65_8219
ip link show onv66_aeac > /dev/null 2>&1 && ip link delete onv66_aeac
ip link show onv67_cd28 > /dev/null 2>&1 && ip link delete onv67_cd28
ip link show onv68_d573 > /dev/null 2>&1 && ip link delete onv68_d573
ip link show onv69_0571 > /dev/null 2>&1 && ip link delete onv69_0571
ip link show onv70_c087 > /dev/null 2>&1 && ip link delete onv70_c087
ip link show onv71_83b6 > /dev/null 2>&1 && ip link delete onv71_83b6
ip link show onv72_56ea > /dev/null 2>&1 && ip link delete onv72_56ea
ip link show onv73_2171 > /dev/null 2>&1 && ip link delete onv73_2171
ip link show onv74_1669 > /dev/null 2>&1 && ip link delete onv74_1669
ip link show onv75_9616 > /dev/null 2>&1 && ip link delete onv75_9616
ip link show onv76_695c > /dev/null 2>&1 && ip link delete onv76_695c
ip link show onv77_b834 > /dev/null 2>&1 && ip link delete onv77_b834
ip link show onv78_91ee > /dev/null 2>&1 && ip link delete onv78_91ee
ip link show onv79_63b2 > /dev/null 2>&1 && ip link delete onv79_63b2
ip link show onv80_4245 > /dev/null 2>&1 && ip link delete onv80_4245

# Create new virtual interfaces
# Helper function to verify interface creation and IP assignment
verify_interface() {
    local iface=$1
    local ip=$2
    local max_attempts=30
    local delay=0.5
    local attempt=1

    echo "Verifying interface $iface with IP $ip..."

    # First verify the interface exists
    while [ $attempt -le $max_attempts ]; do
        if ip link show $iface &>/dev/null; then
            echo "  Interface $iface exists. Checking IP address..."
            break
        fi
        echo "  Waiting for interface $iface to be created (attempt $attempt/$max_attempts)"
        sleep $delay
        attempt=$((attempt+1))
    done

    if ! ip link show $iface &>/dev/null; then
        echo "  ERROR: Interface $iface could not be created after $max_attempts attempts!"
        return 1
    fi

    # Now verify IP address is assigned
    attempt=1
    while [ $attempt -le $max_attempts ]; do
        if ip addr show $iface | grep -q "$ip"; then
            echo "  Success: Interface $iface has IP address $ip"
            return 0
        fi
        echo "  Waiting for IP $ip to be assigned to $iface (attempt $attempt/$max_attempts)"
        sleep $delay
        attempt=$((attempt+1))
    done

    echo "  ERROR: IP address $ip could not be assigned to $iface after $max_attempts attempts!"
    return 1
}

echo "Creating interface 1/80: onv1_dbb4"
ip link add onv1_dbb4 link $PHYS_IFACE address 02:28:5c:53:db:b4 type macvlan mode bridge
ip link set onv1_dbb4 up
echo "Assigning static IP 192.168.6.3/24 to onv1_dbb4..."
ip addr add 192.168.6.3/24 dev onv1_dbb4
echo 1 > /proc/sys/net/ipv4/conf/onv1_dbb4/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv1_dbb4/arp_announce

verify_interface onv1_dbb4 192.168.6.3
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv1_dbb4 or IP 192.168.6.3 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 2/80: onv2_628d"
ip link add onv2_628d link $PHYS_IFACE address 02:ca:fe:ba:62:8d type macvlan mode bridge
ip link set onv2_628d up
echo "Assigning static IP 192.168.6.4/24 to onv2_628d..."
ip addr add 192.168.6.4/24 dev onv2_628d
echo 1 > /proc/sys/net/ipv4/conf/onv2_628d/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv2_628d/arp_announce

verify_interface onv2_628d 192.168.6.4
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv2_628d or IP 192.168.6.4 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 3/80: onv3_fad9"
ip link add onv3_fad9 link $PHYS_IFACE address 02:b0:82:62:fa:d9 type macvlan mode bridge
ip link set onv3_fad9 up
echo "Assigning static IP 192.168.6.5/24 to onv3_fad9..."
ip addr add 192.168.6.5/24 dev onv3_fad9
echo 1 > /proc/sys/net/ipv4/conf/onv3_fad9/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv3_fad9/arp_announce

verify_interface onv3_fad9 192.168.6.5
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv3_fad9 or IP 192.168.6.5 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 4/80: onv4_2475"
ip link add onv4_2475 link $PHYS_IFACE address 02:09:84:94:24:75 type macvlan mode bridge
ip link set onv4_2475 up
echo "Assigning static IP 192.168.6.6/24 to onv4_2475..."
ip addr add 192.168.6.6/24 dev onv4_2475
echo 1 > /proc/sys/net/ipv4/conf/onv4_2475/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv4_2475/arp_announce

verify_interface onv4_2475 192.168.6.6
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv4_2475 or IP 192.168.6.6 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 5/80: onv5_5093"
ip link add onv5_5093 link $PHYS_IFACE address 02:20:5c:60:50:93 type macvlan mode bridge
ip link set onv5_5093 up
echo "Assigning static IP 192.168.6.7/24 to onv5_5093..."
ip addr add 192.168.6.7/24 dev onv5_5093
echo 1 > /proc/sys/net/ipv4/conf/onv5_5093/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv5_5093/arp_announce

verify_interface onv5_5093 192.168.6.7
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv5_5093 or IP 192.168.6.7 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 6/80: onv6_cbb4"
ip link add onv6_cbb4 link $PHYS_IFACE address 02:6f:cb:19:cb:b4 type macvlan mode bridge
ip link set onv6_cbb4 up
echo "Assigning static IP 192.168.6.8/24 to onv6_cbb4..."
ip addr add 192.168.6.8/24 dev onv6_cbb4
echo 1 > /proc/sys/net/ipv4/conf/onv6_cbb4/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv6_cbb4/arp_announce

verify_interface onv6_cbb4 192.168.6.8
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv6_cbb4 or IP 192.168.6.8 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 7/80: onv7_21cb"
ip link add onv7_21cb link $PHYS_IFACE address 02:8e:81:a6:21:cb type macvlan mode bridge
ip link set onv7_21cb up
echo "Assigning static IP 192.168.6.9/24 to onv7_21cb..."
ip addr add 192.168.6.9/24 dev onv7_21cb
echo 1 > /proc/sys/net/ipv4/conf/onv7_21cb/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv7_21cb/arp_announce

verify_interface onv7_21cb 192.168.6.9
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv7_21cb or IP 192.168.6.9 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 8/80: onv8_69e3"
ip link add onv8_69e3 link $PHYS_IFACE address 02:0b:70:bd:69:e3 type macvlan mode bridge
ip link set onv8_69e3 up
echo "Assigning static IP 192.168.6.10/24 to onv8_69e3..."
ip addr add 192.168.6.10/24 dev onv8_69e3
echo 1 > /proc/sys/net/ipv4/conf/onv8_69e3/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv8_69e3/arp_announce

verify_interface onv8_69e3 192.168.6.10
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv8_69e3 or IP 192.168.6.10 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 9/80: onv9_2912"
ip link add onv9_2912 link $PHYS_IFACE address 02:7e:32:58:29:12 type macvlan mode bridge
ip link set onv9_2912 up
echo "Assigning static IP 192.168.6.11/24 to onv9_2912..."
ip addr add 192.168.6.11/24 dev onv9_2912
echo 1 > /proc/sys/net/ipv4/conf/onv9_2912/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv9_2912/arp_announce

verify_interface onv9_2912 192.168.6.11
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv9_2912 or IP 192.168.6.11 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 10/80: onv10_1b73"
ip link add onv10_1b73 link $PHYS_IFACE address 02:cd:47:13:1b:73 type macvlan mode bridge
ip link set onv10_1b73 up
echo "Assigning static IP 192.168.6.12/24 to onv10_1b73..."
ip addr add 192.168.6.12/24 dev onv10_1b73
echo 1 > /proc/sys/net/ipv4/conf/onv10_1b73/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv10_1b73/arp_announce

verify_interface onv10_1b73 192.168.6.12
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv10_1b73 or IP 192.168.6.12 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 11/80: onv11_a6fc"
ip link add onv11_a6fc link $PHYS_IFACE address 02:af:df:dd:a6:fc type macvlan mode bridge
ip link set onv11_a6fc up
echo "Assigning static IP 192.168.6.13/24 to onv11_a6fc..."
ip addr add 192.168.6.13/24 dev onv11_a6fc
echo 1 > /proc/sys/net/ipv4/conf/onv11_a6fc/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv11_a6fc/arp_announce

verify_interface onv11_a6fc 192.168.6.13
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv11_a6fc or IP 192.168.6.13 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 12/80: onv12_f9b6"
ip link add onv12_f9b6 link $PHYS_IFACE address 02:0e:71:51:f9:b6 type macvlan mode bridge
ip link set onv12_f9b6 up
echo "Assigning static IP 192.168.6.14/24 to onv12_f9b6..."
ip addr add 192.168.6.14/24 dev onv12_f9b6
echo 1 > /proc/sys/net/ipv4/conf/onv12_f9b6/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv12_f9b6/arp_announce

verify_interface onv12_f9b6 192.168.6.14
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv12_f9b6 or IP 192.168.6.14 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 13/80: onv13_c6b4"
ip link add onv13_c6b4 link $PHYS_IFACE address 02:dd:ac:2e:c6:b4 type macvlan mode bridge
ip link set onv13_c6b4 up
echo "Assigning static IP 192.168.6.15/24 to onv13_c6b4..."
ip addr add 192.168.6.15/24 dev onv13_c6b4
echo 1 > /proc/sys/net/ipv4/conf/onv13_c6b4/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv13_c6b4/arp_announce

verify_interface onv13_c6b4 192.168.6.15
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv13_c6b4 or IP 192.168.6.15 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 14/80: onv14_dfd2"
ip link add onv14_dfd2 link $PHYS_IFACE address 02:59:a5:04:df:d2 type macvlan mode bridge
ip link set onv14_dfd2 up
echo "Assigning static IP 192.168.6.16/24 to onv14_dfd2..."
ip addr add 192.168.6.16/24 dev onv14_dfd2
echo 1 > /proc/sys/net/ipv4/conf/onv14_dfd2/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv14_dfd2/arp_announce

verify_interface onv14_dfd2 192.168.6.16
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv14_dfd2 or IP 192.168.6.16 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 15/80: onv15_8e96"
ip link add onv15_8e96 link $PHYS_IFACE address 02:fd:fc:0e:8e:96 type macvlan mode bridge
ip link set onv15_8e96 up
echo "Assigning static IP 192.168.6.17/24 to onv15_8e96..."
ip addr add 192.168.6.17/24 dev onv15_8e96
echo 1 > /proc/sys/net/ipv4/conf/onv15_8e96/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv15_8e96/arp_announce

verify_interface onv15_8e96 192.168.6.17
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv15_8e96 or IP 192.168.6.17 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 16/80: onv16_321b"
ip link add onv16_321b link $PHYS_IFACE address 02:a1:ef:84:32:1b type macvlan mode bridge
ip link set onv16_321b up
echo "Assigning static IP 192.168.6.18/24 to onv16_321b..."
ip addr add 192.168.6.18/24 dev onv16_321b
echo 1 > /proc/sys/net/ipv4/conf/onv16_321b/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv16_321b/arp_announce

verify_interface onv16_321b 192.168.6.18
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv16_321b or IP 192.168.6.18 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 17/80: onv17_dcb2"
ip link add onv17_dcb2 link $PHYS_IFACE address 02:1f:4a:4d:dc:b2 type macvlan mode bridge
ip link set onv17_dcb2 up
echo "Assigning static IP 192.168.6.19/24 to onv17_dcb2..."
ip addr add 192.168.6.19/24 dev onv17_dcb2
echo 1 > /proc/sys/net/ipv4/conf/onv17_dcb2/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv17_dcb2/arp_announce

verify_interface onv17_dcb2 192.168.6.19
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv17_dcb2 or IP 192.168.6.19 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 18/80: onv18_8ae4"
ip link add onv18_8ae4 link $PHYS_IFACE address 02:6c:df:c2:8a:e4 type macvlan mode bridge
ip link set onv18_8ae4 up
echo "Assigning static IP 192.168.6.20/24 to onv18_8ae4..."
ip addr add 192.168.6.20/24 dev onv18_8ae4
echo 1 > /proc/sys/net/ipv4/conf/onv18_8ae4/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv18_8ae4/arp_announce

verify_interface onv18_8ae4 192.168.6.20
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv18_8ae4 or IP 192.168.6.20 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 19/80: onv19_9313"
ip link add onv19_9313 link $PHYS_IFACE address 02:78:5d:1d:93:13 type macvlan mode bridge
ip link set onv19_9313 up
echo "Assigning static IP 192.168.6.21/24 to onv19_9313..."
ip addr add 192.168.6.21/24 dev onv19_9313
echo 1 > /proc/sys/net/ipv4/conf/onv19_9313/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv19_9313/arp_announce

verify_interface onv19_9313 192.168.6.21
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv19_9313 or IP 192.168.6.21 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 20/80: onv20_6c12"
ip link add onv20_6c12 link $PHYS_IFACE address 02:72:0e:1c:6c:12 type macvlan mode bridge
ip link set onv20_6c12 up
echo "Assigning static IP 192.168.6.22/24 to onv20_6c12..."
ip addr add 192.168.6.22/24 dev onv20_6c12
echo 1 > /proc/sys/net/ipv4/conf/onv20_6c12/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv20_6c12/arp_announce

verify_interface onv20_6c12 192.168.6.22
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv20_6c12 or IP 192.168.6.22 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 21/80: onv21_ad20"
ip link add onv21_ad20 link $PHYS_IFACE address 02:aa:e1:92:ad:20 type macvlan mode bridge
ip link set onv21_ad20 up
echo "Assigning static IP 192.168.6.23/24 to onv21_ad20..."
ip addr add 192.168.6.23/24 dev onv21_ad20
echo 1 > /proc/sys/net/ipv4/conf/onv21_ad20/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv21_ad20/arp_announce

verify_interface onv21_ad20 192.168.6.23
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv21_ad20 or IP 192.168.6.23 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 22/80: onv22_f7cb"
ip link add onv22_f7cb link $PHYS_IFACE address 02:e6:59:ae:f7:cb type macvlan mode bridge
ip link set onv22_f7cb up
echo "Assigning static IP 192.168.6.24/24 to onv22_f7cb..."
ip addr add 192.168.6.24/24 dev onv22_f7cb
echo 1 > /proc/sys/net/ipv4/conf/onv22_f7cb/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv22_f7cb/arp_announce

verify_interface onv22_f7cb 192.168.6.24
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv22_f7cb or IP 192.168.6.24 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 23/80: onv23_940e"
ip link add onv23_940e link $PHYS_IFACE address 02:4a:b7:ec:94:0e type macvlan mode bridge
ip link set onv23_940e up
echo "Assigning static IP 192.168.6.25/24 to onv23_940e..."
ip addr add 192.168.6.25/24 dev onv23_940e
echo 1 > /proc/sys/net/ipv4/conf/onv23_940e/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv23_940e/arp_announce

verify_interface onv23_940e 192.168.6.25
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv23_940e or IP 192.168.6.25 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 24/80: onv24_7e17"
ip link add onv24_7e17 link $PHYS_IFACE address 02:1c:0c:6f:7e:17 type macvlan mode bridge
ip link set onv24_7e17 up
echo "Assigning static IP 192.168.6.26/24 to onv24_7e17..."
ip addr add 192.168.6.26/24 dev onv24_7e17
echo 1 > /proc/sys/net/ipv4/conf/onv24_7e17/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv24_7e17/arp_announce

verify_interface onv24_7e17 192.168.6.26
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv24_7e17 or IP 192.168.6.26 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 25/80: onv25_115b"
ip link add onv25_115b link $PHYS_IFACE address 02:f7:53:82:11:5b type macvlan mode bridge
ip link set onv25_115b up
echo "Assigning static IP 192.168.6.27/24 to onv25_115b..."
ip addr add 192.168.6.27/24 dev onv25_115b
echo 1 > /proc/sys/net/ipv4/conf/onv25_115b/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv25_115b/arp_announce

verify_interface onv25_115b 192.168.6.27
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv25_115b or IP 192.168.6.27 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 26/80: onv26_a614"
ip link add onv26_a614 link $PHYS_IFACE address 02:a4:c8:2a:a6:14 type macvlan mode bridge
ip link set onv26_a614 up
echo "Assigning static IP 192.168.6.28/24 to onv26_a614..."
ip addr add 192.168.6.28/24 dev onv26_a614
echo 1 > /proc/sys/net/ipv4/conf/onv26_a614/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv26_a614/arp_announce

verify_interface onv26_a614 192.168.6.28
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv26_a614 or IP 192.168.6.28 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 27/80: onv27_1edb"
ip link add onv27_1edb link $PHYS_IFACE address 02:53:98:1d:1e:db type macvlan mode bridge
ip link set onv27_1edb up
echo "Assigning static IP 192.168.6.29/24 to onv27_1edb..."
ip addr add 192.168.6.29/24 dev onv27_1edb
echo 1 > /proc/sys/net/ipv4/conf/onv27_1edb/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv27_1edb/arp_announce

verify_interface onv27_1edb 192.168.6.29
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv27_1edb or IP 192.168.6.29 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 28/80: onv28_336f"
ip link add onv28_336f link $PHYS_IFACE address 02:d7:88:0d:33:6f type macvlan mode bridge
ip link set onv28_336f up
echo "Assigning static IP 192.168.6.30/24 to onv28_336f..."
ip addr add 192.168.6.30/24 dev onv28_336f
echo 1 > /proc/sys/net/ipv4/conf/onv28_336f/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv28_336f/arp_announce

verify_interface onv28_336f 192.168.6.30
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv28_336f or IP 192.168.6.30 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 29/80: onv29_ec72"
ip link add onv29_ec72 link $PHYS_IFACE address 02:c3:5b:fb:ec:72 type macvlan mode bridge
ip link set onv29_ec72 up
echo "Assigning static IP 192.168.6.31/24 to onv29_ec72..."
ip addr add 192.168.6.31/24 dev onv29_ec72
echo 1 > /proc/sys/net/ipv4/conf/onv29_ec72/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv29_ec72/arp_announce

verify_interface onv29_ec72 192.168.6.31
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv29_ec72 or IP 192.168.6.31 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 30/80: onv30_bc3a"
ip link add onv30_bc3a link $PHYS_IFACE address 02:29:3d:11:bc:3a type macvlan mode bridge
ip link set onv30_bc3a up
echo "Assigning static IP 192.168.6.32/24 to onv30_bc3a..."
ip addr add 192.168.6.32/24 dev onv30_bc3a
echo 1 > /proc/sys/net/ipv4/conf/onv30_bc3a/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv30_bc3a/arp_announce

verify_interface onv30_bc3a 192.168.6.32
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv30_bc3a or IP 192.168.6.32 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 31/80: onv31_54b3"
ip link add onv31_54b3 link $PHYS_IFACE address 02:0f:dc:bc:54:b3 type macvlan mode bridge
ip link set onv31_54b3 up
echo "Assigning static IP 192.168.6.33/24 to onv31_54b3..."
ip addr add 192.168.6.33/24 dev onv31_54b3
echo 1 > /proc/sys/net/ipv4/conf/onv31_54b3/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv31_54b3/arp_announce

verify_interface onv31_54b3 192.168.6.33
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv31_54b3 or IP 192.168.6.33 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 32/80: onv32_5b68"
ip link add onv32_5b68 link $PHYS_IFACE address 02:d0:19:ba:5b:68 type macvlan mode bridge
ip link set onv32_5b68 up
echo "Assigning static IP 192.168.6.34/24 to onv32_5b68..."
ip addr add 192.168.6.34/24 dev onv32_5b68
echo 1 > /proc/sys/net/ipv4/conf/onv32_5b68/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv32_5b68/arp_announce

verify_interface onv32_5b68 192.168.6.34
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv32_5b68 or IP 192.168.6.34 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 33/80: onv33_a6c3"
ip link add onv33_a6c3 link $PHYS_IFACE address 02:cc:00:d2:a6:c3 type macvlan mode bridge
ip link set onv33_a6c3 up
echo "Assigning static IP 192.168.6.35/24 to onv33_a6c3..."
ip addr add 192.168.6.35/24 dev onv33_a6c3
echo 1 > /proc/sys/net/ipv4/conf/onv33_a6c3/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv33_a6c3/arp_announce

verify_interface onv33_a6c3 192.168.6.35
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv33_a6c3 or IP 192.168.6.35 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 34/80: onv34_84df"
ip link add onv34_84df link $PHYS_IFACE address 02:c9:54:34:84:df type macvlan mode bridge
ip link set onv34_84df up
echo "Assigning static IP 192.168.6.36/24 to onv34_84df..."
ip addr add 192.168.6.36/24 dev onv34_84df
echo 1 > /proc/sys/net/ipv4/conf/onv34_84df/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv34_84df/arp_announce

verify_interface onv34_84df 192.168.6.36
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv34_84df or IP 192.168.6.36 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 35/80: onv35_6043"
ip link add onv35_6043 link $PHYS_IFACE address 02:90:67:6b:60:43 type macvlan mode bridge
ip link set onv35_6043 up
echo "Assigning static IP 192.168.6.37/24 to onv35_6043..."
ip addr add 192.168.6.37/24 dev onv35_6043
echo 1 > /proc/sys/net/ipv4/conf/onv35_6043/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv35_6043/arp_announce

verify_interface onv35_6043 192.168.6.37
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv35_6043 or IP 192.168.6.37 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 36/80: onv36_2589"
ip link add onv36_2589 link $PHYS_IFACE address 02:6f:ea:dc:25:89 type macvlan mode bridge
ip link set onv36_2589 up
echo "Assigning static IP 192.168.6.38/24 to onv36_2589..."
ip addr add 192.168.6.38/24 dev onv36_2589
echo 1 > /proc/sys/net/ipv4/conf/onv36_2589/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv36_2589/arp_announce

verify_interface onv36_2589 192.168.6.38
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv36_2589 or IP 192.168.6.38 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 37/80: onv37_d020"
ip link add onv37_d020 link $PHYS_IFACE address 02:27:2b:64:d0:20 type macvlan mode bridge
ip link set onv37_d020 up
echo "Assigning static IP 192.168.6.39/24 to onv37_d020..."
ip addr add 192.168.6.39/24 dev onv37_d020
echo 1 > /proc/sys/net/ipv4/conf/onv37_d020/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv37_d020/arp_announce

verify_interface onv37_d020 192.168.6.39
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv37_d020 or IP 192.168.6.39 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 38/80: onv38_e6ae"
ip link add onv38_e6ae link $PHYS_IFACE address 02:92:d2:00:e6:ae type macvlan mode bridge
ip link set onv38_e6ae up
echo "Assigning static IP 192.168.6.40/24 to onv38_e6ae..."
ip addr add 192.168.6.40/24 dev onv38_e6ae
echo 1 > /proc/sys/net/ipv4/conf/onv38_e6ae/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv38_e6ae/arp_announce

verify_interface onv38_e6ae 192.168.6.40
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv38_e6ae or IP 192.168.6.40 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 39/80: onv39_a604"
ip link add onv39_a604 link $PHYS_IFACE address 02:37:e5:a8:a6:04 type macvlan mode bridge
ip link set onv39_a604 up
echo "Assigning static IP 192.168.6.41/24 to onv39_a604..."
ip addr add 192.168.6.41/24 dev onv39_a604
echo 1 > /proc/sys/net/ipv4/conf/onv39_a604/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv39_a604/arp_announce

verify_interface onv39_a604 192.168.6.41
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv39_a604 or IP 192.168.6.41 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 40/80: onv40_dca0"
ip link add onv40_dca0 link $PHYS_IFACE address 02:bc:83:1a:dc:a0 type macvlan mode bridge
ip link set onv40_dca0 up
echo "Assigning static IP 192.168.6.42/24 to onv40_dca0..."
ip addr add 192.168.6.42/24 dev onv40_dca0
echo 1 > /proc/sys/net/ipv4/conf/onv40_dca0/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv40_dca0/arp_announce

verify_interface onv40_dca0 192.168.6.42
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv40_dca0 or IP 192.168.6.42 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 41/80: onv41_688a"
ip link add onv41_688a link $PHYS_IFACE address 02:eb:6c:a6:68:8a type macvlan mode bridge
ip link set onv41_688a up
echo "Assigning static IP 192.168.6.43/24 to onv41_688a..."
ip addr add 192.168.6.43/24 dev onv41_688a
echo 1 > /proc/sys/net/ipv4/conf/onv41_688a/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv41_688a/arp_announce

verify_interface onv41_688a 192.168.6.43
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv41_688a or IP 192.168.6.43 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 42/80: onv42_6aaf"
ip link add onv42_6aaf link $PHYS_IFACE address 02:39:b8:15:6a:af type macvlan mode bridge
ip link set onv42_6aaf up
echo "Assigning static IP 192.168.6.44/24 to onv42_6aaf..."
ip addr add 192.168.6.44/24 dev onv42_6aaf
echo 1 > /proc/sys/net/ipv4/conf/onv42_6aaf/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv42_6aaf/arp_announce

verify_interface onv42_6aaf 192.168.6.44
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv42_6aaf or IP 192.168.6.44 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 43/80: onv43_949e"
ip link add onv43_949e link $PHYS_IFACE address 02:c8:5b:d2:94:9e type macvlan mode bridge
ip link set onv43_949e up
echo "Assigning static IP 192.168.6.45/24 to onv43_949e..."
ip addr add 192.168.6.45/24 dev onv43_949e
echo 1 > /proc/sys/net/ipv4/conf/onv43_949e/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv43_949e/arp_announce

verify_interface onv43_949e 192.168.6.45
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv43_949e or IP 192.168.6.45 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 44/80: onv44_a56d"
ip link add onv44_a56d link $PHYS_IFACE address 02:ff:43:d3:a5:6d type macvlan mode bridge
ip link set onv44_a56d up
echo "Assigning static IP 192.168.6.46/24 to onv44_a56d..."
ip addr add 192.168.6.46/24 dev onv44_a56d
echo 1 > /proc/sys/net/ipv4/conf/onv44_a56d/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv44_a56d/arp_announce

verify_interface onv44_a56d 192.168.6.46
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv44_a56d or IP 192.168.6.46 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 45/80: onv45_177e"
ip link add onv45_177e link $PHYS_IFACE address 02:50:e1:ff:17:7e type macvlan mode bridge
ip link set onv45_177e up
echo "Assigning static IP 192.168.6.47/24 to onv45_177e..."
ip addr add 192.168.6.47/24 dev onv45_177e
echo 1 > /proc/sys/net/ipv4/conf/onv45_177e/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv45_177e/arp_announce

verify_interface onv45_177e 192.168.6.47
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv45_177e or IP 192.168.6.47 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 46/80: onv46_39e3"
ip link add onv46_39e3 link $PHYS_IFACE address 02:6e:97:6b:39:e3 type macvlan mode bridge
ip link set onv46_39e3 up
echo "Assigning static IP 192.168.6.48/24 to onv46_39e3..."
ip addr add 192.168.6.48/24 dev onv46_39e3
echo 1 > /proc/sys/net/ipv4/conf/onv46_39e3/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv46_39e3/arp_announce

verify_interface onv46_39e3 192.168.6.48
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv46_39e3 or IP 192.168.6.48 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 47/80: onv47_03d0"
ip link add onv47_03d0 link $PHYS_IFACE address 02:f8:26:39:03:d0 type macvlan mode bridge
ip link set onv47_03d0 up
echo "Assigning static IP 192.168.6.49/24 to onv47_03d0..."
ip addr add 192.168.6.49/24 dev onv47_03d0
echo 1 > /proc/sys/net/ipv4/conf/onv47_03d0/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv47_03d0/arp_announce

verify_interface onv47_03d0 192.168.6.49
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv47_03d0 or IP 192.168.6.49 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 48/80: onv48_5800"
ip link add onv48_5800 link $PHYS_IFACE address 02:80:c4:d4:58:00 type macvlan mode bridge
ip link set onv48_5800 up
echo "Assigning static IP 192.168.6.50/24 to onv48_5800..."
ip addr add 192.168.6.50/24 dev onv48_5800
echo 1 > /proc/sys/net/ipv4/conf/onv48_5800/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv48_5800/arp_announce

verify_interface onv48_5800 192.168.6.50
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv48_5800 or IP 192.168.6.50 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 49/80: onv49_4a6c"
ip link add onv49_4a6c link $PHYS_IFACE address 02:6c:7c:51:4a:6c type macvlan mode bridge
ip link set onv49_4a6c up
echo "Assigning static IP 192.168.6.51/24 to onv49_4a6c..."
ip addr add 192.168.6.51/24 dev onv49_4a6c
echo 1 > /proc/sys/net/ipv4/conf/onv49_4a6c/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv49_4a6c/arp_announce

verify_interface onv49_4a6c 192.168.6.51
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv49_4a6c or IP 192.168.6.51 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 50/80: onv50_6dbd"
ip link add onv50_6dbd link $PHYS_IFACE address 02:b5:d3:59:6d:bd type macvlan mode bridge
ip link set onv50_6dbd up
echo "Assigning static IP 192.168.6.52/24 to onv50_6dbd..."
ip addr add 192.168.6.52/24 dev onv50_6dbd
echo 1 > /proc/sys/net/ipv4/conf/onv50_6dbd/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv50_6dbd/arp_announce

verify_interface onv50_6dbd 192.168.6.52
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv50_6dbd or IP 192.168.6.52 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 51/80: onv51_fa84"
ip link add onv51_fa84 link $PHYS_IFACE address 02:4c:f8:89:fa:84 type macvlan mode bridge
ip link set onv51_fa84 up
echo "Assigning static IP 192.168.6.53/24 to onv51_fa84..."
ip addr add 192.168.6.53/24 dev onv51_fa84
echo 1 > /proc/sys/net/ipv4/conf/onv51_fa84/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv51_fa84/arp_announce

verify_interface onv51_fa84 192.168.6.53
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv51_fa84 or IP 192.168.6.53 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 52/80: onv52_d6f1"
ip link add onv52_d6f1 link $PHYS_IFACE address 02:82:f7:19:d6:f1 type macvlan mode bridge
ip link set onv52_d6f1 up
echo "Assigning static IP 192.168.6.54/24 to onv52_d6f1..."
ip addr add 192.168.6.54/24 dev onv52_d6f1
echo 1 > /proc/sys/net/ipv4/conf/onv52_d6f1/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv52_d6f1/arp_announce

verify_interface onv52_d6f1 192.168.6.54
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv52_d6f1 or IP 192.168.6.54 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 53/80: onv53_44e8"
ip link add onv53_44e8 link $PHYS_IFACE address 02:7e:89:ae:44:e8 type macvlan mode bridge
ip link set onv53_44e8 up
echo "Assigning static IP 192.168.6.55/24 to onv53_44e8..."
ip addr add 192.168.6.55/24 dev onv53_44e8
echo 1 > /proc/sys/net/ipv4/conf/onv53_44e8/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv53_44e8/arp_announce

verify_interface onv53_44e8 192.168.6.55
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv53_44e8 or IP 192.168.6.55 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 54/80: onv54_b1b3"
ip link add onv54_b1b3 link $PHYS_IFACE address 02:a0:63:ad:b1:b3 type macvlan mode bridge
ip link set onv54_b1b3 up
echo "Assigning static IP 192.168.6.56/24 to onv54_b1b3..."
ip addr add 192.168.6.56/24 dev onv54_b1b3
echo 1 > /proc/sys/net/ipv4/conf/onv54_b1b3/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv54_b1b3/arp_announce

verify_interface onv54_b1b3 192.168.6.56
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv54_b1b3 or IP 192.168.6.56 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 55/80: onv55_03bc"
ip link add onv55_03bc link $PHYS_IFACE address 02:e1:6c:9f:03:bc type macvlan mode bridge
ip link set onv55_03bc up
echo "Assigning static IP 192.168.6.57/24 to onv55_03bc..."
ip addr add 192.168.6.57/24 dev onv55_03bc
echo 1 > /proc/sys/net/ipv4/conf/onv55_03bc/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv55_03bc/arp_announce

verify_interface onv55_03bc 192.168.6.57
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv55_03bc or IP 192.168.6.57 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 56/80: onv56_073c"
ip link add onv56_073c link $PHYS_IFACE address 02:8e:6d:14:07:3c type macvlan mode bridge
ip link set onv56_073c up
echo "Assigning static IP 192.168.6.58/24 to onv56_073c..."
ip addr add 192.168.6.58/24 dev onv56_073c
echo 1 > /proc/sys/net/ipv4/conf/onv56_073c/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv56_073c/arp_announce

verify_interface onv56_073c 192.168.6.58
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv56_073c or IP 192.168.6.58 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 57/80: onv57_a2e4"
ip link add onv57_a2e4 link $PHYS_IFACE address 02:b0:6e:26:a2:e4 type macvlan mode bridge
ip link set onv57_a2e4 up
echo "Assigning static IP 192.168.6.59/24 to onv57_a2e4..."
ip addr add 192.168.6.59/24 dev onv57_a2e4
echo 1 > /proc/sys/net/ipv4/conf/onv57_a2e4/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv57_a2e4/arp_announce

verify_interface onv57_a2e4 192.168.6.59
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv57_a2e4 or IP 192.168.6.59 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 58/80: onv58_d754"
ip link add onv58_d754 link $PHYS_IFACE address 02:46:2f:98:d7:54 type macvlan mode bridge
ip link set onv58_d754 up
echo "Assigning static IP 192.168.6.60/24 to onv58_d754..."
ip addr add 192.168.6.60/24 dev onv58_d754
echo 1 > /proc/sys/net/ipv4/conf/onv58_d754/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv58_d754/arp_announce

verify_interface onv58_d754 192.168.6.60
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv58_d754 or IP 192.168.6.60 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 59/80: onv59_f3c2"
ip link add onv59_f3c2 link $PHYS_IFACE address 02:3a:1e:84:f3:c2 type macvlan mode bridge
ip link set onv59_f3c2 up
echo "Assigning static IP 192.168.6.61/24 to onv59_f3c2..."
ip addr add 192.168.6.61/24 dev onv59_f3c2
echo 1 > /proc/sys/net/ipv4/conf/onv59_f3c2/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv59_f3c2/arp_announce

verify_interface onv59_f3c2 192.168.6.61
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv59_f3c2 or IP 192.168.6.61 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 60/80: onv60_98a9"
ip link add onv60_98a9 link $PHYS_IFACE address 02:a3:bc:f6:98:a9 type macvlan mode bridge
ip link set onv60_98a9 up
echo "Assigning static IP 192.168.6.62/24 to onv60_98a9..."
ip addr add 192.168.6.62/24 dev onv60_98a9
echo 1 > /proc/sys/net/ipv4/conf/onv60_98a9/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv60_98a9/arp_announce

verify_interface onv60_98a9 192.168.6.62
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv60_98a9 or IP 192.168.6.62 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 61/80: onv61_070d"
ip link add onv61_070d link $PHYS_IFACE address 02:24:14:61:07:0d type macvlan mode bridge
ip link set onv61_070d up
echo "Assigning static IP 192.168.6.63/24 to onv61_070d..."
ip addr add 192.168.6.63/24 dev onv61_070d
echo 1 > /proc/sys/net/ipv4/conf/onv61_070d/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv61_070d/arp_announce

verify_interface onv61_070d 192.168.6.63
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv61_070d or IP 192.168.6.63 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 62/80: onv62_be3c"
ip link add onv62_be3c link $PHYS_IFACE address 02:a3:ae:c0:be:3c type macvlan mode bridge
ip link set onv62_be3c up
echo "Assigning static IP 192.168.6.64/24 to onv62_be3c..."
ip addr add 192.168.6.64/24 dev onv62_be3c
echo 1 > /proc/sys/net/ipv4/conf/onv62_be3c/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv62_be3c/arp_announce

verify_interface onv62_be3c 192.168.6.64
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv62_be3c or IP 192.168.6.64 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 63/80: onv63_309d"
ip link add onv63_309d link $PHYS_IFACE address 02:b0:46:fe:30:9d type macvlan mode bridge
ip link set onv63_309d up
echo "Assigning static IP 192.168.6.65/24 to onv63_309d..."
ip addr add 192.168.6.65/24 dev onv63_309d
echo 1 > /proc/sys/net/ipv4/conf/onv63_309d/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv63_309d/arp_announce

verify_interface onv63_309d 192.168.6.65
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv63_309d or IP 192.168.6.65 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 64/80: onv64_5793"
ip link add onv64_5793 link $PHYS_IFACE address 02:b6:10:34:57:93 type macvlan mode bridge
ip link set onv64_5793 up
echo "Assigning static IP 192.168.6.66/24 to onv64_5793..."
ip addr add 192.168.6.66/24 dev onv64_5793
echo 1 > /proc/sys/net/ipv4/conf/onv64_5793/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv64_5793/arp_announce

verify_interface onv64_5793 192.168.6.66
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv64_5793 or IP 192.168.6.66 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 65/80: onv65_8219"
ip link add onv65_8219 link $PHYS_IFACE address 02:bb:98:b9:82:19 type macvlan mode bridge
ip link set onv65_8219 up
echo "Assigning static IP 192.168.6.67/24 to onv65_8219..."
ip addr add 192.168.6.67/24 dev onv65_8219
echo 1 > /proc/sys/net/ipv4/conf/onv65_8219/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv65_8219/arp_announce

verify_interface onv65_8219 192.168.6.67
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv65_8219 or IP 192.168.6.67 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 66/80: onv66_aeac"
ip link add onv66_aeac link $PHYS_IFACE address 02:24:71:07:ae:ac type macvlan mode bridge
ip link set onv66_aeac up
echo "Assigning static IP 192.168.6.68/24 to onv66_aeac..."
ip addr add 192.168.6.68/24 dev onv66_aeac
echo 1 > /proc/sys/net/ipv4/conf/onv66_aeac/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv66_aeac/arp_announce

verify_interface onv66_aeac 192.168.6.68
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv66_aeac or IP 192.168.6.68 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 67/80: onv67_cd28"
ip link add onv67_cd28 link $PHYS_IFACE address 02:90:98:73:cd:28 type macvlan mode bridge
ip link set onv67_cd28 up
echo "Assigning static IP 192.168.6.69/24 to onv67_cd28..."
ip addr add 192.168.6.69/24 dev onv67_cd28
echo 1 > /proc/sys/net/ipv4/conf/onv67_cd28/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv67_cd28/arp_announce

verify_interface onv67_cd28 192.168.6.69
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv67_cd28 or IP 192.168.6.69 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 68/80: onv68_d573"
ip link add onv68_d573 link $PHYS_IFACE address 02:6a:9d:c1:d5:73 type macvlan mode bridge
ip link set onv68_d573 up
echo "Assigning static IP 192.168.6.70/24 to onv68_d573..."
ip addr add 192.168.6.70/24 dev onv68_d573
echo 1 > /proc/sys/net/ipv4/conf/onv68_d573/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv68_d573/arp_announce

verify_interface onv68_d573 192.168.6.70
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv68_d573 or IP 192.168.6.70 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 69/80: onv69_0571"
ip link add onv69_0571 link $PHYS_IFACE address 02:e2:45:72:05:71 type macvlan mode bridge
ip link set onv69_0571 up
echo "Assigning static IP 192.168.6.71/24 to onv69_0571..."
ip addr add 192.168.6.71/24 dev onv69_0571
echo 1 > /proc/sys/net/ipv4/conf/onv69_0571/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv69_0571/arp_announce

verify_interface onv69_0571 192.168.6.71
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv69_0571 or IP 192.168.6.71 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 70/80: onv70_c087"
ip link add onv70_c087 link $PHYS_IFACE address 02:50:e8:40:c0:87 type macvlan mode bridge
ip link set onv70_c087 up
echo "Assigning static IP 192.168.6.72/24 to onv70_c087..."
ip addr add 192.168.6.72/24 dev onv70_c087
echo 1 > /proc/sys/net/ipv4/conf/onv70_c087/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv70_c087/arp_announce

verify_interface onv70_c087 192.168.6.72
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv70_c087 or IP 192.168.6.72 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 71/80: onv71_83b6"
ip link add onv71_83b6 link $PHYS_IFACE address 02:98:a9:71:83:b6 type macvlan mode bridge
ip link set onv71_83b6 up
echo "Assigning static IP 192.168.6.73/24 to onv71_83b6..."
ip addr add 192.168.6.73/24 dev onv71_83b6
echo 1 > /proc/sys/net/ipv4/conf/onv71_83b6/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv71_83b6/arp_announce

verify_interface onv71_83b6 192.168.6.73
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv71_83b6 or IP 192.168.6.73 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 72/80: onv72_56ea"
ip link add onv72_56ea link $PHYS_IFACE address 02:3b:8a:2e:56:ea type macvlan mode bridge
ip link set onv72_56ea up
echo "Assigning static IP 192.168.6.74/24 to onv72_56ea..."
ip addr add 192.168.6.74/24 dev onv72_56ea
echo 1 > /proc/sys/net/ipv4/conf/onv72_56ea/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv72_56ea/arp_announce

verify_interface onv72_56ea 192.168.6.74
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv72_56ea or IP 192.168.6.74 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 73/80: onv73_2171"
ip link add onv73_2171 link $PHYS_IFACE address 02:c1:b2:86:21:71 type macvlan mode bridge
ip link set onv73_2171 up
echo "Assigning static IP 192.168.6.75/24 to onv73_2171..."
ip addr add 192.168.6.75/24 dev onv73_2171
echo 1 > /proc/sys/net/ipv4/conf/onv73_2171/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv73_2171/arp_announce

verify_interface onv73_2171 192.168.6.75
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv73_2171 or IP 192.168.6.75 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 74/80: onv74_1669"
ip link add onv74_1669 link $PHYS_IFACE address 02:02:f6:54:16:69 type macvlan mode bridge
ip link set onv74_1669 up
echo "Assigning static IP 192.168.6.76/24 to onv74_1669..."
ip addr add 192.168.6.76/24 dev onv74_1669
echo 1 > /proc/sys/net/ipv4/conf/onv74_1669/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv74_1669/arp_announce

verify_interface onv74_1669 192.168.6.76
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv74_1669 or IP 192.168.6.76 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 75/80: onv75_9616"
ip link add onv75_9616 link $PHYS_IFACE address 02:bd:6c:9e:96:16 type macvlan mode bridge
ip link set onv75_9616 up
echo "Assigning static IP 192.168.6.77/24 to onv75_9616..."
ip addr add 192.168.6.77/24 dev onv75_9616
echo 1 > /proc/sys/net/ipv4/conf/onv75_9616/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv75_9616/arp_announce

verify_interface onv75_9616 192.168.6.77
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv75_9616 or IP 192.168.6.77 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 76/80: onv76_695c"
ip link add onv76_695c link $PHYS_IFACE address 02:0f:b3:45:69:5c type macvlan mode bridge
ip link set onv76_695c up
echo "Assigning static IP 192.168.6.78/24 to onv76_695c..."
ip addr add 192.168.6.78/24 dev onv76_695c
echo 1 > /proc/sys/net/ipv4/conf/onv76_695c/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv76_695c/arp_announce

verify_interface onv76_695c 192.168.6.78
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv76_695c or IP 192.168.6.78 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 77/80: onv77_b834"
ip link add onv77_b834 link $PHYS_IFACE address 02:8a:8f:f6:b8:34 type macvlan mode bridge
ip link set onv77_b834 up
echo "Assigning static IP 192.168.6.79/24 to onv77_b834..."
ip addr add 192.168.6.79/24 dev onv77_b834
echo 1 > /proc/sys/net/ipv4/conf/onv77_b834/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv77_b834/arp_announce

verify_interface onv77_b834 192.168.6.79
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv77_b834 or IP 192.168.6.79 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 78/80: onv78_91ee"
ip link add onv78_91ee link $PHYS_IFACE address 02:fb:78:8e:91:ee type macvlan mode bridge
ip link set onv78_91ee up
echo "Assigning static IP 192.168.6.80/24 to onv78_91ee..."
ip addr add 192.168.6.80/24 dev onv78_91ee
echo 1 > /proc/sys/net/ipv4/conf/onv78_91ee/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv78_91ee/arp_announce

verify_interface onv78_91ee 192.168.6.80
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv78_91ee or IP 192.168.6.80 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 79/80: onv79_63b2"
ip link add onv79_63b2 link $PHYS_IFACE address 02:0d:ba:c1:63:b2 type macvlan mode bridge
ip link set onv79_63b2 up
echo "Assigning static IP 192.168.6.81/24 to onv79_63b2..."
ip addr add 192.168.6.81/24 dev onv79_63b2
echo 1 > /proc/sys/net/ipv4/conf/onv79_63b2/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv79_63b2/arp_announce

verify_interface onv79_63b2 192.168.6.81
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv79_63b2 or IP 192.168.6.81 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Creating interface 80/80: onv80_4245"
ip link add onv80_4245 link $PHYS_IFACE address 02:91:59:0f:42:45 type macvlan mode bridge
ip link set onv80_4245 up
echo "Assigning static IP 192.168.6.82/24 to onv80_4245..."
ip addr add 192.168.6.82/24 dev onv80_4245
echo 1 > /proc/sys/net/ipv4/conf/onv80_4245/arp_ignore
echo 2 > /proc/sys/net/ipv4/conf/onv80_4245/arp_announce

verify_interface onv80_4245 192.168.6.82
if [ $? -ne 0 ]; then
    echo "WARNING: Interface onv80_4245 or IP 192.168.6.82 verification failed. Manual check recommended."
fi

sleep 0.1

echo "Network interface setup complete."
echo "Virtual interface IP addresses:"
ip -4 addr show | grep -A 2 "onv" | grep -v "valid_lft"
</file>

<file path="main.js">
const tcpProxy = require('node-tcp-proxy');
const onvifServer = require('./src/onvif-server');
const configBuilder = require('./src/config-builder');
const package = require('./package.json');
const argparse = require('argparse');
const readline = require('readline');
const stream = require('stream');
const yaml = require('yaml');
const fs = require('fs');
const simpleLogger = require('simple-node-logger');

const parser = new argparse.ArgumentParser({
    description: 'Virtual Onvif Server'
});

parser.add_argument('-v', '--version', { action: 'store_true', help: 'show the version information' });
parser.add_argument('-cc', '--create-config', { action: 'store_true', help: 'create a new config' });
parser.add_argument('-d', '--debug', { action: 'store_true', help: 'show onvif requests' });
parser.add_argument('config', { help: 'config filename to use', nargs: '?'});

let args = parser.parse_args();

if (args) {
    const logger = simpleLogger.createSimpleLogger();
    if (args.debug)
        logger.setLevel('trace');

    if (args.version) {
        logger.info('Version: ' + package.version);
        return;
    }

    if (args.create_config) {
        let mutableStdout = new stream.Writable({
            write: function(chunk, encoding, callback) {
                if (!this.muted || chunk.toString().includes('\n'))
                    process.stdout.write(chunk, encoding);
                callback();
            }
        });

        const rl = readline.createInterface({
            input: process.stdin,
            output: mutableStdout,
            terminal: true
        });

        mutableStdout.muted = false;
        rl.question('Onvif Server: ', (hostname) => {
            rl.question('Onvif Username: ', (username) => {
                mutableStdout.muted = true;
                process.stdout.write('Onvif Password: ');
                rl.question('', (password) => {
                    console.log('Generating config ...');
                    configBuilder.createConfig(hostname, username, password).then((config) => {
                        if (config) {
                            console.log('# ==================== CONFIG START ====================');
                            console.log(yaml.stringify(config));
                            console.log('# ===================== CONFIG END =====================');
                        } else
                        console.log('Failed to create config!');
                    });
                    rl.close();
                });
            });
        });

    } else if (args.config) {
        let configData;
        try {
            configData = fs.readFileSync(args.config, 'utf8');
        } catch (error) {
            if (error.code === 'ENOENT') {
                logger.error('File not found: ' + args.config);
                return -1;
            }
            throw error;
        }

        let config;
        try {
            config = yaml.parse(configData);
        } catch (error) {
            logger.error('Failed to read config, invalid yaml syntax.')
            return -1;
        }

        let proxies = {};
        // let discoveryStarted = false; // Discovery completely disabled

        for (let onvifConfig of config.onvif) {
            let server = onvifServer.createServer(onvifConfig, logger);
            if (server.getHostname()) {
                logger.info(`Starting virtual onvif server for ${onvifConfig.name} on ${server.getHostname()}:${onvifConfig.ports.server} ...`);
                server.startServer();
                // Discovery call removed
                // if (!discoveryStarted) {
                //     server.startDiscovery();
                //     discoveryStarted = true;
                // }
                if (args.debug)
                    server.enableDebugOutput();
                logger.info('  Started!');
                logger.info('');

                if (!proxies[onvifConfig.target.hostname])
                    proxies[onvifConfig.target.hostname] = {}
                
                if (onvifConfig.ports.rtsp && onvifConfig.target.ports.rtsp)
                    proxies[onvifConfig.target.hostname][onvifConfig.ports.rtsp] = onvifConfig.target.ports.rtsp;
                if (onvifConfig.ports.snapshot && onvifConfig.target.ports.snapshot)
                    proxies[onvifConfig.target.hostname][onvifConfig.ports.snapshot] = onvifConfig.target.ports.snapshot;
            } else {
                logger.error(`Failed to find IP address for MAC address ${onvifConfig.mac}`)
                return -1;
            }
        }
        
        for (let destinationAddress in proxies) {
            for (let sourcePort in proxies[destinationAddress]) {
                logger.info(`Starting tcp proxy from port ${sourcePort} to ${destinationAddress}:${proxies[destinationAddress][sourcePort]} ...`);
                tcpProxy.createProxy(sourcePort, destinationAddress, proxies[destinationAddress][sourcePort]);
                logger.info('  Started!');
                logger.info('');
            }
        }

    } else {
        logger.error('Please specifiy a config filename!');
        return -1;
    }

    return 0;
}
</file>

<file path="src/config-builder.js">
const soap = require('soap');
const uuid = require('node-uuid');
const fs = require('fs');
const yaml = require('yaml');
const path = require('path');
const crypto = require('crypto');

/**
 * Generates a unique MAC address for a camera
 * @param {string} nvrIp - The IP address of the NVR
 * @param {string} cameraId - Unique identifier for the camera
 * @returns {string} A MAC address in the format 02:XX:XX:XX:XX:XX
 */
function generateMacAddress(nvrIp, cameraId) {
    // Remove any port information from the IP
    const ipOnly = nvrIp.includes(':') ? nvrIp.substring(0, nvrIp.indexOf(':')) : nvrIp;
    
    // Create a hash from the IP and camera ID
    const hash = crypto.createHash('md5').update(`${ipOnly}-${cameraId}`).digest('hex');
    
    // Format as a MAC address (locally administered)
    // 02 prefix indicates a locally administered unicast MAC address
    return `02:${hash.substring(0, 2)}:${hash.substring(2, 4)}:${hash.substring(4, 6)}:${hash.substring(6, 8)}:${hash.substring(8, 10)}`;
}

/**
 * Generates a shell script to set up virtual network interfaces
 * @param {Object} config - The ONVIF configuration object
 * @param {string} nvrIp - The IP address of the NVR
 * @returns {string} Shell script content
 */
/**
 * Generates a short interface name from a MAC address
 * @param {string} mac - MAC address
 * @param {number} index - Camera index for uniqueness
 * @returns {string} Short interface name (max 15 chars)
 */
function generateShortInterfaceName(mac, index) {
    // Extract last 4 chars of MAC (without colons)
    const shortMac = mac.replace(/:/g, '').slice(-4);
    // Create a name like "onv1_1234" (10 chars)
    return `onv${index}_${shortMac}`;
}

/**
 * Generates a static IP address for a virtual interface
 * @param {number} index - Camera index for uniqueness
 * @returns {string} Static IP address in the range 192.168.6.2 - 192.168.6.200
 */
function generateStaticIp(index) {
    // Use 2 + index as the last octet, ensuring we stay within the allowed range
    const lastOctet = 2 + index;
    if (lastOctet > 200) {
        console.warn(`Warning: IP address 192.168.6.${lastOctet} is outside the allowed range`);
    }
    return `192.168.6.${lastOctet}`;
}

function generateNetworkScript(config, nvrIp) {
    // Get the physical interface name once at the beginning
    let script = `#!/bin/bash\n\n` +
                `# Network setup script for ONVIF virtual interfaces\n` +
                `# Generated for NVR: ${nvrIp}\n` +
                `# Generated on: ${new Date().toISOString()}\n\n` +
                
                `# Get the physical interface name (look for the interface with the host IP)\n` +
                `HOST_IP=$(hostname -I | awk '{print $1}')\n` +
                `PHYS_IFACE=$(ip -o addr show | grep "$HOST_IP" | grep -v macvlan | awk '{print $2}' | cut -d':' -f1)\n` +
                `if [ -z "$PHYS_IFACE" ]; then\n` +
                `    echo "Error: Could not determine physical interface"\n` +
                `    exit 1\n` +
                `fi\n` +
                `echo "Using physical interface: $PHYS_IFACE"\n` +
                `# Configure ARP settings for physical interface\n` +
                `echo "Configuring ARP settings for physical interface $PHYS_IFACE..."\n` +
                `echo 1 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_ignore\n` +
                `echo 2 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_announce\n\n` +
                
                `# Parse command line arguments\n` +
                `USE_DHCP=false # Default to static IPs\n` +
                `while [[ "$#" -gt 0 ]]; do\n` +
                `    case $1 in\n` +
                `        --dhcp) USE_DHCP=true ;;\n` +
                `        *) echo "Unknown parameter: $1"; exit 1 ;;\n` +
                `    esac\n` +
                `    shift\n` +
                `done\n\n` +
                
                `# Check if dhclient is installed when using DHCP\n` +
                `if [ "$USE_DHCP" = true ] && ! command -v dhclient &> /dev/null; then\n` +
                `    echo "dhclient not found. Please install it with:"\n` +
                `    echo "  sudo apt-get install isc-dhcp-client    (for Debian/Ubuntu)"\n` +
                `    echo "  sudo yum install dhcp-client            (for CentOS/RHEL)"\n` +
                `    echo "Or use --static to assign static IPs instead."\n` +
                `    exit 1\n` +
                `fi\n\n`;
    
    script += `# Create a mapping file for MAC to interface name and IP\n`;
    script += `cat > mac_to_interface.txt << EOF\n`;
    
    // Add MAC to interface mapping
    let index = 1;
    for (const camera of config.onvif) {
        const macAddress = camera.mac;
        const interfaceName = generateShortInterfaceName(macAddress, index);
        const staticIp = generateStaticIp(index);
        script += `${macAddress} ${interfaceName} ${staticIp}\n`;
        index++;
    }
    script += `EOF\n\n`;
    
    script += `# Remove any existing interfaces first\n`;
    
    // Add commands to remove existing interfaces
    index = 1;
    for (const camera of config.onvif) {
        const macAddress = camera.mac;
        const interfaceName = generateShortInterfaceName(macAddress, index);
        script += `ip link show ${interfaceName} > /dev/null 2>&1 && ip link delete ${interfaceName}\n`;
        index++;
    }
    
    script += `\n# Create new virtual interfaces\n`;
    
    // Add commands to create new interfaces
    index = 1;
    for (const camera of config.onvif) {
        const macAddress = camera.mac;
        const interfaceName = generateShortInterfaceName(macAddress, index);
        const staticIp = generateStaticIp(index);
        
        // Create macvlan interface as specified in the README
        script += `echo "Creating macvlan interface ${interfaceName}..."\n`;
        script += `ip link add ${interfaceName} link $PHYS_IFACE address ${macAddress} type macvlan mode bridge\n`;
        script += `ip link set ${interfaceName} up\n`;
        
        // Add conditional IP assignment based on mode
        script += `if [ "$USE_DHCP" = true ]; then\n`;
        script += `    echo "Requesting IP address for ${interfaceName} via DHCP..."\n`;
        script += `    dhclient -v ${interfaceName} &\n`;
        script += `else\n`;
        script += `    echo "Assigning static IP ${staticIp}/24 to ${interfaceName}..."\n`;
        script += `    ip addr add ${staticIp}/24 dev ${interfaceName}\n`;
        script += `fi\n\n`;
        
        // Add ARP configuration as mentioned in the README troubleshooting section
        script += `# Configure ARP to prevent issues with multiple interfaces\n`;
        script += `echo "Configuring ARP settings..."\n`;
        script += `echo 1 > /proc/sys/net/ipv4/conf/${interfaceName}/arp_ignore\n`;
        script += `echo 2 > /proc/sys/net/ipv4/conf/${interfaceName}/arp_announce\n\n`;
        
        index++;
    }
    
    script += `# Wait for IP assignment to complete and display IP addresses\n`;
    script += `sleep 3\n`;
    script += `echo "Virtual interface IP addresses:"\n`;
    script += `ip -4 addr show | grep -A 2 "onv" | grep -v "valid_lft"\n`;
    
    script += `\necho "Static IP assignment is the default. To use DHCP instead, run: sudo $0 --dhcp"\n`;
    
    return script;
}

function extractPath(url) {
    // Add a check for null/undefined url
    if (!url) return '';
    const protocolSeparatorIndex = url.indexOf('//');
    if (protocolSeparatorIndex === -1) return url; // Handle cases without protocol? Or assume http/rtsp?
    const pathStartIndex = url.indexOf('/', protocolSeparatorIndex + 2);
    if (pathStartIndex === -1) return '/'; // Root path if nothing else
    return url.substr(pathStartIndex);
}

async function createConfig(hostname, username, password) {
    let options = {
        forceSoap12Headers: true
    };

    let securityOptions = {
        hasNonce: true,
        passwordType: 'PasswordDigest'
    };

    let client = await soap.createClientAsync('./wsdl/media_service.wsdl', options);
    // Ensure endpoint uses http, construct carefully
    const endpoint = `http://${hostname.includes(':') ? hostname.substring(0, hostname.indexOf(':')) : hostname}/onvif/device_service`;
    client.setEndpoint(endpoint); // Use calculated endpoint
    client.setSecurity(new soap.WSSecurity(username, password, securityOptions));

    let hostport = 80; // Default HTTP port
    let targetHostname = hostname;
    if (hostname.includes(':')) {
        const parts = hostname.split(':');
        targetHostname = parts[0];
        // Attempt to parse port, default if invalid
        const parsedPort = parseInt(parts[1], 10);
        hostport = !isNaN(parsedPort) ? parsedPort : 80;
    }

    let cameras = {};

    try {
        let profilesResponse = await client.GetProfilesAsync({});
        // Check if Profiles exist and is an array
        let profiles = profilesResponse && profilesResponse[0] && Array.isArray(profilesResponse[0].Profiles) ? profilesResponse[0].Profiles : [];

        for (let profile of profiles) {
            // Ensure profile structure is somewhat valid before proceeding
            if (!profile || !profile.VideoSourceConfiguration || !profile.VideoSourceConfiguration.SourceToken || !profile.attributes || !profile.attributes.token) {
                console.warn('Skipping incomplete profile:', JSON.stringify(profile));
                continue;
            }

            let videoSource = profile.VideoSourceConfiguration.SourceToken;

            if (!cameras[videoSource])
                cameras[videoSource] = [];

            let snapshotUri = null;
            try {
                let snapshotUriResponse = await client.GetSnapshotUriAsync({
                    ProfileToken: profile.attributes.token
                });
                 // Check response structure before accessing Uri
                snapshotUri = snapshotUriResponse && snapshotUriResponse[0] && snapshotUriResponse[0].MediaUri && snapshotUriResponse[0].MediaUri.Uri
                                ? snapshotUriResponse[0].MediaUri.Uri
                                : null; // Default to null if structure is wrong
            } catch (snapErr) {
                console.warn(`Could not get Snapshot URI for profile ${profile.attributes.token}:`, snapErr.message || snapErr);
                // Keep snapshotUri as null
            }


            let streamUri = null;
            try {
                let streamUriResponse = await client.GetStreamUriAsync({
                    StreamSetup: {
                        Stream: 'RTP-Unicast',
                        Transport: {
                            Protocol: 'RTSP'
                        }
                    },
                    ProfileToken: profile.attributes.token
                });
                 // Check response structure before accessing Uri
                streamUri = streamUriResponse && streamUriResponse[0] && streamUriResponse[0].MediaUri && streamUriResponse[0].MediaUri.Uri
                            ? streamUriResponse[0].MediaUri.Uri
                            : null; // Default to null if structure is wrong
            } catch (streamErr) {
                console.warn(`Could not get Stream URI for profile ${profile.attributes.token}:`, streamErr.message || streamErr);
                 // Keep streamUri as null
            }


            // Assign URIs to profile *only if they were successfully fetched*
            if (streamUri) profile.streamUri = streamUri;
            if (snapshotUri) profile.snapshotUri = snapshotUri;

            cameras[videoSource].push(profile);
        }
    } catch (err) {
        if (err.root && err.root.Envelope && err.root.Envelope.Body && err.root.Envelope.Body.Fault && err.root.Envelope.Body.Fault.Reason && err.root.Envelope.Body.Fault.Reason.Text && err.root.Envelope.Body.Fault.Reason.Text['$value'])
            throw new Error(`ONVIF Error: ${err.root.Envelope.Body.Fault.Reason.Text['$value']}`); // Throw standard Error object
        // Throw standard Error object for other cases too
        throw new Error(`ONVIF Communication Error: ${err.message || err}`);
    }

    let config = {
        onvif: []
    };

    let serverPort = 8081;
    for (let camera in cameras) {
        if (!cameras[camera] || cameras[camera].length === 0) {
            console.warn(`Skipping camera source ${camera} due to no valid profiles.`);
            continue;
        }

        let mainStream = cameras[camera][0];
        let subStream = cameras[camera].length > 1 ? cameras[camera][1] : cameras[camera][0]; // Fallback to main if only one exists

        let swapStreams = false;
        // Use optional chaining and default values (e.g., 0) for comparison
        const mainQuality = mainStream?.VideoEncoderConfiguration?.Quality ?? 0;
        const subQuality = subStream?.VideoEncoderConfiguration?.Quality ?? 0;
        const mainWidth = mainStream?.VideoEncoderConfiguration?.Resolution?.Width ?? 0;
        const subWidth = subStream?.VideoEncoderConfiguration?.Resolution?.Width ?? 0;

        if (subQuality > mainQuality) {
            swapStreams = true;
        } else if (subQuality === mainQuality) {
            if (subWidth > mainWidth) {
                swapStreams = true;
            }
        }

        if (swapStreams) {
            let tempStream = subStream;
            subStream = mainStream;
            mainStream = tempStream;
        }

        // Use optional chaining and default values (0 or '') when building config
        let cameraConfig = {
            mac: generateMacAddress(targetHostname, `${camera}-${serverPort}`), // Generate unique MAC
            ports: {
                server: serverPort,
                rtsp: 8554,
                snapshot: 8580
            },
            // Use profile name if available, otherwise fallback
            name: mainStream?.VideoSourceConfiguration?.Name ?? `Camera_${camera}_Main`,
            uuid: uuid.v4(),
            highQuality: {
                // Use extractPath only if streamUri/snapshotUri exist
                rtsp: mainStream?.streamUri ? extractPath(mainStream.streamUri) : '',
                snapshot: mainStream?.snapshotUri ? extractPath(mainStream.snapshotUri) : '',
                width: mainStream?.VideoEncoderConfiguration?.Resolution?.Width ?? 0,
                height: mainStream?.VideoEncoderConfiguration?.Resolution?.Height ?? 0,
                framerate: mainStream?.VideoEncoderConfiguration?.RateControl?.FrameRateLimit ?? 0,
                bitrate: mainStream?.VideoEncoderConfiguration?.RateControl?.BitrateLimit ?? 0,
                quality: 4.0 // Keep fixed quality indicator
            },
            lowQuality: {
                // Use extractPath only if streamUri/snapshotUri exist
                rtsp: subStream?.streamUri ? extractPath(subStream.streamUri) : '',
                snapshot: subStream?.snapshotUri ? extractPath(subStream.snapshotUri) : '',
                width: subStream?.VideoEncoderConfiguration?.Resolution?.Width ?? 0,
                height: subStream?.VideoEncoderConfiguration?.Resolution?.Height ?? 0,
                framerate: subStream?.VideoEncoderConfiguration?.RateControl?.FrameRateLimit ?? 0,
                bitrate: subStream?.VideoEncoderConfiguration?.RateControl?.BitrateLimit ?? 0,
                quality: 1.0 // Keep fixed quality indicator
            },
            target: {
                hostname: targetHostname, // Use parsed hostname
                ports: {
                    rtsp: 554, // Standard RTSP port
                    snapshot: hostport // Use port from input hostname or default 80
                }
            }
        };

        config.onvif.push(cameraConfig);
        serverPort++;
    }

    return config;
}

/**
 * Merges multiple ONVIF configs into a single config
 * @param {Array} configs - Array of config objects to merge
 * @returns {Object} Merged config
 */
function mergeConfigs(configs) {
    // Start with an empty config
    let mergedConfig = {
        onvif: []
    };
    
    // Track MAC addresses to avoid duplicates
    const macAddresses = new Set();
    
    // Add onvif entries from all configs, avoiding duplicates
    for (const config of configs) {
        if (config && config.onvif && Array.isArray(config.onvif)) {
            for (const camera of config.onvif) {
                // Skip if this MAC address is already in the merged config
                if (camera.mac && !macAddresses.has(camera.mac)) {
                    macAddresses.add(camera.mac);
                    mergedConfig.onvif.push(camera);
                } else {
                    console.log(`Skipping duplicate camera with MAC: ${camera.mac}`);
                }
            }
        }
    }
    
    console.log(`Merged ${mergedConfig.onvif.length} unique cameras into combined config`);
    return mergedConfig;
}

/**
 * Generates a combined network setup script for multiple NVRs
 * @param {Array} configs - Array of config objects
 * @param {Array} ipAddresses - Array of IP addresses corresponding to configs
 * @returns {string} Combined shell script
 */
function generateCombinedNetworkScript(configs, ipAddresses) {
    let script = `#!/bin/bash\n\n`;
    script += `# Combined network setup script for multiple ONVIF virtual interfaces\n`;
    script += `# Generated for NVRs: ${ipAddresses.join(', ')}\n`;
    script += `# Generated on: ${new Date().toISOString()}\n\n`;
    
    // Remove argument parsing and DHCP check for combined script - always static
    // script += `# Parse command line arguments\n`;
    // script += `USE_DHCP=false # Default to static IPs\n`;
    // script += `while [[ "$#" -gt 0 ]]; do\n`;
    // script += `    case $1 in\n`;
    // script += `        --dhcp) USE_DHCP=true ;;\n`;
    // script += `        *) echo "Unknown parameter: $1"; exit 1 ;;\n`;
    // script += `    esac\n`;
    // script += `    shift\n`;
    // script += `done\n\n`;
    
    // script += `# Check if dhclient is installed when using DHCP\n`;
    // script += `if [ "$USE_DHCP" = true ] && ! command -v dhclient &> /dev/null; then\n`;
    // script += `    echo "dhclient not found. Please install it with:"\n`;
    // script += `    echo "  sudo apt-get install isc-dhcp-client    (for Debian/Ubuntu)"\n`;
    // script += `    echo "  sudo yum install dhcp-client            (for CentOS/RHEL)"\n`;
    // script += `    echo "Or use --static to assign static IPs instead."\n`;
    // script += `    exit 1\n`;
    // script += `fi\n\n`;
    
    // Get the physical interface name once at the beginning
    // NOTE: This duplicates the initial script setup - ensure consistency if changed above
    script = `#!/bin/bash\n\n` +
             `# Combined network setup script for multiple ONVIF virtual interfaces\n` +
             `# Generated for NVRs: ${ipAddresses.join(', ')}\n` +
             `# Generated on: ${new Date().toISOString()}\n\n` +
             
             `# Get the physical interface name (look for the interface with the host IP)\n` +
             `HOST_IP=$(hostname -I | awk '{print $1}')\n` +
             `PHYS_IFACE=$(ip -o addr show | grep "$HOST_IP" | grep -v macvlan | awk '{print $2}' | cut -d':' -f1)\n` +
             `if [ -z "$PHYS_IFACE" ]; then\n` +
             `    echo "Error: Could not determine physical interface"\n` +
             `    exit 1\n` +
             `fi\n` +
             `echo "Using physical interface: $PHYS_IFACE"\n` +
             `# Configure ARP settings for physical interface\n` +
             `echo "Configuring ARP settings for physical interface $PHYS_IFACE..."\n` +
             `echo 1 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_ignore\n` +
             `echo 2 > /proc/sys/net/ipv4/conf/$PHYS_IFACE/arp_announce\n\n`;
             
             // Remove argument parsing - combined script is always static
             //`# Parse command line arguments\n` +
             //`USE_DHCP=true\n` + // This was incorrect, should have been false if kept
             //`while [[ "$#" -gt 0 ]]; do\n` +
             //`    case $1 in\n` +
             //`        --static) USE_DHCP=false ;;\n` + // This logic was for the single script
             //`        *) echo "Unknown parameter: $1"; exit 1 ;;\n` +
             //`    esac\n` +
             //`    shift\n` +
             //`done\n\n`;
    
    script += `# Create a mapping file for MAC to interface name and IP\n`;
    script += `cat > mac_to_interface.txt << EOF\n`;
    
    // Add MAC to interface mapping
    let globalIndex = 1;
    for (const config of configs) {
        if (config && config.onvif && Array.isArray(config.onvif)) {
            for (const camera of config.onvif) {
                const macAddress = camera.mac;
                const interfaceName = generateShortInterfaceName(macAddress, globalIndex);
                const staticIp = generateStaticIp(globalIndex);
                script += `${macAddress} ${interfaceName} ${staticIp}\n`;
                globalIndex++;
            }
        }
    }
    script += `EOF\n\n`;
    
    script += `# Remove any existing interfaces first\n`;
    
    // Add commands to remove existing interfaces from all configs
    globalIndex = 1;
    for (const config of configs) {
        if (config && config.onvif && Array.isArray(config.onvif)) {
            for (const camera of config.onvif) {
                const macAddress = camera.mac;
                const interfaceName = generateShortInterfaceName(macAddress, globalIndex);
                script += `ip link show ${interfaceName} > /dev/null 2>&1 && ip link delete ${interfaceName}\n`;
                globalIndex++;
            }
        }
    }
    
    script += `\n# Create new virtual interfaces\n`;
    
    // Add helper function for interface verification
    script += `# Helper function to verify interface creation and IP assignment\n`;
    script += `verify_interface() {\n`;
    script += `    local iface=$1\n`;
    script += `    local ip=$2\n`;
    script += `    local max_attempts=30\n`;
    script += `    local delay=0.5\n`;
    script += `    local attempt=1\n\n`;
    
    script += `    echo "Verifying interface $iface with IP $ip..."\n\n`;
    
    script += `    # First verify the interface exists\n`;
    script += `    while [ $attempt -le $max_attempts ]; do\n`;
    script += `        if ip link show $iface &>/dev/null; then\n`;
    script += `            echo "  Interface $iface exists. Checking IP address..."\n`;
    script += `            break\n`;
    script += `        fi\n`;
    script += `        echo "  Waiting for interface $iface to be created (attempt $attempt/$max_attempts)"\n`;
    script += `        sleep $delay\n`;
    script += `        attempt=$((attempt+1))\n`;
    script += `    done\n\n`;
    
    script += `    if ! ip link show $iface &>/dev/null; then\n`;
    script += `        echo "  ERROR: Interface $iface could not be created after $max_attempts attempts!"\n`;
    script += `        return 1\n`;
    script += `    fi\n\n`;
    
    script += `    # Now verify IP address is assigned\n`;
    script += `    attempt=1\n`;
    script += `    while [ $attempt -le $max_attempts ]; do\n`;
    script += `        if ip addr show $iface | grep -q "$ip"; then\n`;
    script += `            echo "  Success: Interface $iface has IP address $ip"\n`;
    script += `            return 0\n`;
    script += `        fi\n`;
    script += `        echo "  Waiting for IP $ip to be assigned to $iface (attempt $attempt/$max_attempts)"\n`;
    script += `        sleep $delay\n`;
    script += `        attempt=$((attempt+1))\n`;
    script += `    done\n\n`;
    
    script += `    echo "  ERROR: IP address $ip could not be assigned to $iface after $max_attempts attempts!"\n`;
    script += `    return 1\n`;
    script += `}\n\n`;
    
    // Add commands to create new interfaces from all configs
    globalIndex = 1;
    for (const config of configs) {
        if (config && config.onvif && Array.isArray(config.onvif)) {
            for (const camera of config.onvif) {
                const macAddress = camera.mac;
                const interfaceName = generateShortInterfaceName(macAddress, globalIndex);
                const staticIp = generateStaticIp(globalIndex);
                
                // Create macvlan interface as specified in the README
                script += `echo "Creating interface ${globalIndex}/${configs.reduce((count, c) => count + (c?.onvif?.length || 0), 0)}: ${interfaceName}"\n`;
                script += `ip link add ${interfaceName} link $PHYS_IFACE address ${macAddress} type macvlan mode bridge\n`;
                script += `ip link set ${interfaceName} up\n`;
                
                script += `echo "Assigning static IP ${staticIp}/24 to ${interfaceName}..."\n`;
                script += `ip addr add ${staticIp}/24 dev ${interfaceName}\n`;
                
                // Add ARP configuration
                script += `echo 1 > /proc/sys/net/ipv4/conf/${interfaceName}/arp_ignore\n`;
                script += `echo 2 > /proc/sys/net/ipv4/conf/${interfaceName}/arp_announce\n\n`;
                
                // Verify interface creation and IP assignment
                script += `verify_interface ${interfaceName} ${staticIp}\n`;
                script += `if [ $? -ne 0 ]; then\n`;
                script += `    echo "WARNING: Interface ${interfaceName} or IP ${staticIp} verification failed. Manual check recommended."\n`;
                script += `fi\n\n`;
                
                // Add a small delay between interface creations to prevent race conditions
                script += `sleep 0.1\n\n`;
                
                globalIndex++;
            }
        }
    }
    
    script += `echo "Network interface setup complete."\n`;
    script += `echo "Virtual interface IP addresses:"\n`;
    script += `ip -4 addr show | grep -A 2 "onv" | grep -v "valid_lft"\n`;
    
    // Remove echo about switching modes
    // script += `\necho "Static IP assignment is the default. To use DHCP instead, run: sudo $0 --dhcp"\n`;
    
    return script;
}

/**
 * Loads existing config from a file if it exists
 * @param {string} filename - Path to the config file
 * @returns {Object|null} Loaded config or null if file doesn't exist
 */
function loadExistingConfig(filename) {
    try {
        if (fs.existsSync(filename)) {
            const configData = fs.readFileSync(filename, 'utf8');
            return yaml.parse(configData);
        }
    } catch (err) {
        console.warn(`Could not load existing config from ${filename}:`, err.message);
    }
    return null;
}

/**
 * Creates a test config with just one camera from an NVR
 * @param {string} hostname - The hostname or IP of the NVR
 * @param {string} username - The username for the NVR
 * @param {string} password - The password for the NVR
 * @returns {Object|null} Test config with one camera or null if failed
 */
async function createTestConfig(hostname, username, password) {
    let config = null;
    try {
        // Get the full config first
        const fullConfig = await createConfig(hostname, username, password);
        
        if (fullConfig && fullConfig.onvif && fullConfig.onvif.length > 0) {
            // Create a new config with just the first camera
            config = {
                onvif: [fullConfig.onvif[0]]
            };
            
            // Extract IP address without port for filename
            const ipAddress = hostname.includes(':')
                ? hostname.substring(0, hostname.indexOf(':'))
                : hostname;
            
            // Create filenames
            const testConfigFilename = `config-test-${ipAddress}.yaml`;
            const testScriptFilename = `setup-network-test-${ipAddress}.sh`;
            
            // Save test config to YAML file
            fs.writeFileSync(testConfigFilename, yaml.stringify(config), 'utf8');
            console.log(`Test config with one camera saved to ${testConfigFilename}`);
            
            // Generate and save test network setup script
            const networkScript = generateNetworkScript(config, ipAddress);
            fs.writeFileSync(testScriptFilename, networkScript, 'utf8');
            fs.chmodSync(testScriptFilename, '0755'); // Make executable
            console.log(`Test network setup script saved to ${testScriptFilename}`);
        } else {
            console.error("Could not create test config: No cameras found in the full config");
        }
    } catch (err) {
        console.error("Error creating test config:", err);
    }
    
    return config;
};

async function createConfigWrapper(hostname, username, password) { // Renamed to avoid conflict with internal createConfig
    let config = null; // Initialize config to null
    try {
        config = await createConfig(hostname, username, password);
        
        if (config) {
            // Extract IP address without port for filename
            const ipAddress = hostname.includes(':')
                ? hostname.substring(0, hostname.indexOf(':'))
                : hostname;
            
            // Create filenames
            const individualConfigFilename = `config-${ipAddress}.yaml`;
            const combinedConfigFilename = `config-combined.yaml`;
            const individualScriptFilename = `setup-network-${ipAddress}.sh`;
            const combinedScriptFilename = `setup-network-combined.sh`;
            
            // Save individual config to YAML file
            fs.writeFileSync(individualConfigFilename, yaml.stringify(config), 'utf8');
            console.log(`Individual config saved to ${individualConfigFilename}`);
            
            // Generate and save individual network setup script
            const networkScript = generateNetworkScript(config, ipAddress);
            fs.writeFileSync(individualScriptFilename, networkScript, 'utf8');
            fs.chmodSync(individualScriptFilename, '0755'); // Make executable
            console.log(`Individual network setup script saved to ${individualScriptFilename}`);
            
            // Create or update combined config
            let combinedConfig;
            const existingCombinedConfig = loadExistingConfig(combinedConfigFilename);
            
            if (existingCombinedConfig) {
                // Merge with existing config
                combinedConfig = mergeConfigs([existingCombinedConfig, config]);
                console.log(`Merged new config with existing combined config`);
            } else {
                // Start a new combined config
                combinedConfig = config;
                console.log(`Created new combined config`);
            }
            
            // Save combined config
            fs.writeFileSync(combinedConfigFilename, yaml.stringify(combinedConfig), 'utf8');
            console.log(`Combined config saved to ${combinedConfigFilename}`);
            
            // Create combined network script
            // First, find all individual config files
            const configFiles = fs.readdirSync('.').filter(file =>
                file.startsWith('config-') &&
                file.endsWith('.yaml') &&
                file !== combinedConfigFilename
            );
            
            const configs = [];
            const ipAddresses = [];
            
            // Load all individual configs
            for (const file of configFiles) {
                const config = loadExistingConfig(file);
                if (config) {
                    configs.push(config);
                    // Extract IP from filename (format: config-192.168.0.219.yaml)
                    const ipMatch = file.match(/config-(.+)\.yaml/);
                    if (ipMatch && ipMatch[1]) {
                        ipAddresses.push(ipMatch[1]);
                    }
                }
            }
            
            // Generate combined network script
            const combinedScript = generateCombinedNetworkScript(configs, ipAddresses);
            fs.writeFileSync(combinedScriptFilename, combinedScript, 'utf8');
            fs.chmodSync(combinedScriptFilename, '0755'); // Make executable
            console.log(`Combined network setup script saved to ${combinedScriptFilename}`);
        }
    } catch (err) {
        console.error("Error during initial config creation attempt:");
        console.error(err); // Log the full error object/message

        // Check if the error message contains the time check failure string
        if (err && typeof err.message === 'string' && err.message.includes('time check failed')) {
            console.log('Time check failed, attempting retry with adjusted time...');

            // Temporarily adjust time (Note: This is a workaround and might have side effects)
            var originalGetUTCHours = Date.prototype.getUTCHours;
            var utcHours = (new Date()).getUTCHours();
            Date.prototype.getUTCHours = function() {
                // Adjust by +1 hour, consider wrapping around 23->0 if needed, though unlikely to be the exact fix boundary
                 return (utcHours + 1) % 24;
            };

            try {
                config = await createConfig(hostname, username, password);
                console.log("Retry attempt successful.");
                
                if (config) {
                    // Extract IP address without port for filename
                    const ipAddress = hostname.includes(':')
                        ? hostname.substring(0, hostname.indexOf(':'))
                        : hostname;
                    
                    // Create filenames
                    const individualConfigFilename = `config-${ipAddress}.yaml`;
                    const combinedConfigFilename = `config-combined.yaml`;
                    const individualScriptFilename = `setup-network-${ipAddress}.sh`;
                    const combinedScriptFilename = `setup-network-combined.sh`;
                    
                    // Save individual config to YAML file
                    fs.writeFileSync(individualConfigFilename, yaml.stringify(config), 'utf8');
                    console.log(`Individual config saved to ${individualConfigFilename}`);
                    
                    // Generate and save individual network setup script
                    const networkScript = generateNetworkScript(config, ipAddress);
                    fs.writeFileSync(individualScriptFilename, networkScript, 'utf8');
                    fs.chmodSync(individualScriptFilename, '0755'); // Make executable
                    console.log(`Individual network setup script saved to ${individualScriptFilename}`);
                    
                    // Create or update combined config
                    let combinedConfig;
                    const existingCombinedConfig = loadExistingConfig(combinedConfigFilename);
                    
                    if (existingCombinedConfig) {
                        // Merge with existing config
                        combinedConfig = mergeConfigs([existingCombinedConfig, config]);
                        console.log(`Merged new config with existing combined config`);
                    } else {
                        // Start a new combined config
                        combinedConfig = config;
                        console.log(`Created new combined config`);
                    }
                    
                    // Save combined config
                    fs.writeFileSync(combinedConfigFilename, yaml.stringify(combinedConfig), 'utf8');
                    console.log(`Combined config saved to ${combinedConfigFilename}`);
                    
                    // Create combined network script
                    // First, find all individual config files
                    const configFiles = fs.readdirSync('.').filter(file =>
                        file.startsWith('config-') &&
                        file.endsWith('.yaml') &&
                        file !== combinedConfigFilename
                    );
                    
                    const configs = [];
                    const ipAddresses = [];
                    
                    // Load all individual configs
                    for (const file of configFiles) {
                        const config = loadExistingConfig(file);
                        if (config) {
                            configs.push(config);
                            // Extract IP from filename (format: config-192.168.0.219.yaml)
                            const ipMatch = file.match(/config-(.+)\.yaml/);
                            if (ipMatch && ipMatch[1]) {
                                ipAddresses.push(ipMatch[1]);
                            }
                        }
                    }
                    
                    // Generate combined network script
                    const combinedScript = generateCombinedNetworkScript(configs, ipAddresses);
                    fs.writeFileSync(combinedScriptFilename, combinedScript, 'utf8');
                    fs.chmodSync(combinedScriptFilename, '0755'); // Make executable
                    console.log(`Combined network setup script saved to ${combinedScriptFilename}`);
                }
            } catch (retryErr) {
                console.error("Error during retry attempt:");
                console.error(retryErr); // Log the error from the retry
            } finally {
                 // IMPORTANT: Restore original function
                Date.prototype.getUTCHours = originalGetUTCHours;
            }
        } else {
             // Log that it's not the time check error we were looking for
             console.error("Caught error was not the 'time check failed' error, no retry performed for this reason.");
        }
    }

    return config; // Return config (which might be null if all attempts failed)
}

// Export necessary functions
exports.createConfig = createConfigWrapper; // Use the wrapper that creates files
exports.createTestConfig = createTestConfig;
exports.generateNetworkScript = generateNetworkScript;
exports.generateCombinedNetworkScript = generateCombinedNetworkScript;
exports.generateStaticIp = generateStaticIp; // Add this export
</file>

<file path="src/onvif-server.js">
const soap = require('soap');
const http = require('http');
const dgram = require('dgram');
const xml2js = require('xml2js');
const uuid = require('node-uuid');
const url = require('url');
const fs = require('fs');
const os = require('os');

Date.prototype.stdTimezoneOffset = function() {
    let jan = new Date(this.getFullYear(), 0, 1);
    let jul = new Date(this.getFullYear(), 6, 1);
    return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
};

Date.prototype.isDstObserved = function() {
    return this.getTimezoneOffset() < this.stdTimezoneOffset();
};

// Define the OnvifServer class
class OnvifServer {
    // Accept ipAddress directly in the constructor
    constructor(config, logger, ipAddress) {
        this.config = config;
        this.logger = logger;

        // Assign the pre-calculated IP address
        this.config.hostname = ipAddress;

        this.videoSource = {
            attributes: {
                token: 'video_src_token'
            },
            Framerate: this.config.highQuality.framerate,
            Resolution: { Width: this.config.highQuality.width, Height: this.config.highQuality.height }
        };
    
        this.profiles = [
            {
                Name: 'MainStream',
                attributes: {
                    token: 'main_stream'
                },
                VideoSourceConfiguration: {
                    Name: 'VideoSource',
                    UseCount: 2,
                    attributes: {
                        token: 'video_src_config_token'
                    },
                    SourceToken: 'video_src_token',
                    Bounds: { attributes: { x: 0, y: 0, width: this.config.highQuality.width, height: this.config.highQuality.height } }
                },
                VideoEncoderConfiguration: {
                    attributes: {
                        token: 'encoder_hq_config_token'
                    },
                    Name: 'CardinalHqCameraConfiguration',
                    UseCount: 1,
                    Encoding: 'H264',
                    Resolution: {
                        Width: this.config.highQuality.width,
                        Height: this.config.highQuality.height
                    },
                    Quality: this.config.highQuality.quality,
                    RateControl: {
                        FrameRateLimit: this.config.highQuality.framerate,
                        EncodingInterval: 1,
                        BitrateLimit: this.config.highQuality.bitrate
                    },
                    H264: {
                        GovLength: this.config.highQuality.framerate,
                        H264Profile: 'Main'
                    },
                    SessionTimeout: 'PT1000S'
                }
            }
        ];

        if (this.config.lowQuality) {
            this.profiles.push(
                {
                    Name: 'SubStream',
                    attributes: {
                        token: 'sub_stream'
                    },
                    VideoSourceConfiguration: {
                        Name: 'VideoSource',
                        UseCount: 2,
                        attributes: {
                            token: 'video_src_config_token'
                        },
                        SourceToken: 'video_src_token',
                        Bounds: { attributes: { x: 0, y: 0, width: this.config.highQuality.width, height: this.config.highQuality.height } }
                    },
                    VideoEncoderConfiguration: {
                        attributes: {
                            token: 'encoder_lq_config_token'
                        },
                        Name: 'CardinalLqCameraConfiguration',
                        UseCount: 1,
                        Encoding: 'H264',
                        Resolution: {
                            Width: this.config.lowQuality.width,
                            Height: this.config.lowQuality.height
                        },
                        Quality: this.config.lowQuality.quality,
                        RateControl: {
                            FrameRateLimit: this.config.lowQuality.framerate,
                            EncodingInterval: 1,
                            BitrateLimit: this.config.lowQuality.bitrate
                        },
                        H264: {
                            GovLength: this.config.lowQuality.framerate,
                            H264Profile: 'Main'
                        },
                        SessionTimeout: 'PT1000S'
                    }
                }
            );
        }
        
        this.onvif = {
            DeviceService: {
                Device: {
                    GetSystemDateAndTime: (args) => {
                        let now = new Date();
            
                        let offset = now.getTimezoneOffset();
                        let abs_offset = Math.abs(offset);
                        let hrs_offset = Math.floor(abs_offset / 60);
                        let mins_offset = (abs_offset % 60);
                        let tz = 'UTC' + (offset < 0 ? '-' : '+') + hrs_offset + (mins_offset === 0 ? '' : ':' + mins_offset);
            
                        return {
                            SystemDateAndTime: {
                                DateTimeType: 'NTP',
                                DaylightSavings: now.isDstObserved(),
                                TimeZone: {
                                    TZ: tz
                                },
                                UTCDateTime: {
                                    Time: { Hour: now.getUTCHours(), Minute: now.getUTCMinutes(), Second: now.getUTCSeconds() },
                                    Date: { Year: now.getUTCFullYear(), Month: now.getUTCMonth() + 1, Day: now.getUTCDate() }
                                },
                                LocalDateTime: {
                                    Time: { Hour: now.getHours(), Minute: now.getMinutes(), Second: now.getSeconds() },
                                    Date: { Year: now.getFullYear(), Month: now.getMonth() + 1, Day: now.getDate() }
                                },
                                Extension: {}
                            }
                        };
                    },
        
                    GetCapabilities: (args) => {
                        let response = {
                            Capabilities: {}
                        };
                
                        if (args.Category === undefined || args.Category == 'All' || args.Category == 'Device') {
                            response.Capabilities['Device'] = {
                                XAddr: `http://${this.config.hostname}:${this.config.ports.server}/onvif/device_service`,
                                Network: {
                                    IPFilter: false,
                                    ZeroConfiguration: false,
                                    IPVersion6: false,
                                    DynDNS: false,
                                    Extension: {
                                        Dot11Configuration: false,
                                        Extension: {}
                                    }
                                },
                                System: {
                                    DiscoveryResolve: false,
                                    DiscoveryBye: false,
                                    RemoteDiscovery: false,
                                    SystemBackup: false,
                                    SystemLogging: false,
                                    FirmwareUpgrade: false,
                                    SupportedVersions: {
                                        Major: 2,
                                        Minor: 5
                                    },
                                    Extension: {
                                        HttpFirmwareUpgrade: false,
                                        HttpSystemBackup: false,
                                        HttpSystemLogging: false,
                                        HttpSupportInformation: false,
                                        Extension: {}
                                    }
                                },
                                IO: {
                                    InputConnectors: 0,
                                    RelayOutputs: 1,
                                    Extension: {
                                        Auxiliary: false,
                                        AuxiliaryCommands: '',
                                        Extension: {}
                                    }
                                },
                                Security: {
                                    'TLS1.1': false,
                                    'TLS1.2': false,
                                    OnboardKeyGeneration: false,
                                    AccessPolicyConfig: false,
                                    'X.509Token': false,
                                    SAMLToken: false,
                                    KerberosToken: false,
                                    RELToken: false,
                                    Extension: {
                                        'TLS1.0': false,
                                        Extension: {
                                            Dot1X: false,
                                            RemoteUserHandling: false
                                        }
                                    }
                                },
                                Extension: {}
                            };
                        }
                        if (args.Category === undefined || args.Category == 'All' || args.Category == 'Media') {
                            response.Capabilities['Media'] = {
                                XAddr: `http://${this.config.hostname}:${this.config.ports.server}/onvif/media_service`,
                                StreamingCapabilities: {
                                    RTPMulticast: false,
                                    RTP_TCP: true,
                                    RTP_RTSP_TCP: true,
                                    Extension: {}
                                },
                                Extension: {
                                    ProfileCapabilities: {
                                        MaximumNumberOfProfiles: this.profiles.length
                                    }
                                }
                            };
                        }

                        return response;
                    },
        
                    GetServices: (args) => {
                        return {
                            Service : [
                                {
                                    Namespace : 'http://www.onvif.org/ver10/device/wsdl',
                                    XAddr : `http://${this.config.hostname}:${this.config.ports.server}/onvif/device_service`,
                                    Version : { 
                                        Major : 2,
                                        Minor : 5,
                                    }
                                },
                                { 
                                    Namespace : 'http://www.onvif.org/ver10/media/wsdl',
                                    XAddr : `http://${this.config.hostname}:${this.config.ports.server}/onvif/media_service`,
                                    Version : { 
                                        Major : 2,
                                        Minor : 5,
                                    }
                                }
                            ]
                        };
                    },
                
                    GetDeviceInformation: (args) => {
                        return {
                            Manufacturer: 'Onvif',
                            Model: 'Cardinal',
                            FirmwareVersion: '1.0.0',
                            SerialNumber: `${this.config.name.replace(' ', '_')}-0000`,
                            HardwareId: `${this.config.name.replace(' ', '_')}-1001`
                        };
                    }
                }
            },
        
            MediaService: {
                Media: {
                    GetProfiles: (args) => {
                        return {
                            Profiles: this.profiles
                        };
                    },
        
                    GetVideoSources: (args) => {
                        return {
                            VideoSources: [
                                this.videoSource
                            ]
                        };
                    },
        
                    GetSnapshotUri: (args) => {
                        let uri = `http://${this.config.hostname}:${this.config.ports.server}/snapshot.png`;
                        if (args.ProfileToken == 'sub_stream' && this.config.lowQuality && this.config.lowQuality.snapshot)
                            uri = `http://${this.config.hostname}:${this.config.ports.snapshot}${this.config.lowQuality.snapshot}`;
                        else if (this.config.highQuality.snapshot)
                            uri = `http://${this.config.hostname}:${this.config.ports.snapshot}${this.config.highQuality.snapshot}`;

                        return {
                            MediaUri : {
                                Uri: uri,
                                InvalidAfterConnect : false,
                                InvalidAfterReboot : false,
                                Timeout : 'PT30S'
                            }
                        };
                    },
                
                    GetStreamUri: (args) => {
                        let path = this.config.highQuality.rtsp;
                        if (args.ProfileToken == 'sub_stream' && this.config.lowQuality)
                            path = this.config.lowQuality.rtsp;

                        return {
                            MediaUri: {
                                Uri: `rtsp://${this.config.hostname}:${this.config.ports.rtsp}${path}`,
                                InvalidAfterConnect: false,
                                InvalidAfterReboot: false,
                                Timeout: 'PT30S'
                            }
                        };
                    }
                }
            }
        };
    }

    listen(request, response) {
        let action = url.parse(request.url, true).pathname;
        if (action == '/snapshot.png') {
            let image = fs.readFileSync('./resources/snapshot.png');
            response.writeHead(200, {'Content-Type': 'image/png' });
            response.end(image, 'binary');
        } else {
            response.writeHead(404, {'Content-Type': 'text/plain'});
            response.write('404 Not Found\n');
            response.end();
        }
    }

    startServer() {
        this.server = http.createServer(this.listen);
        this.server.listen(this.config.ports.server, this.config.hostname);

        this.deviceService = soap.listen(this.server, {
            path: '/onvif/device_service', 
            services: this.onvif,
            xml: fs.readFileSync('./wsdl/device_service.wsdl', 'utf8'),
            uri: './wsdl/device_service.wsdl', // Provide base URI context
            forceSoap12Headers: true
        });

        this.mediaService = soap.listen(this.server, {
            path: '/onvif/media_service', 
            services: this.onvif,
            xml: fs.readFileSync('./wsdl/media_service.wsdl', 'utf8'),
            uri: './wsdl/media_service.wsdl', // Provide base URI context
            forceSoap12Headers: true
        });
    }

    enableDebugOutput() {
        this.deviceService.on('request', (request, methodName) => {
            this.logger.debug('DeviceService: ' + methodName);
        });
        
        this.mediaService.on('request', (request, methodName) => {
            this.logger.debug('MediaService: ' + methodName);
        });
    }

    startDiscovery() {
        this.discoveryMessageNo = 0;
        this.discoverySocket = dgram.createSocket({ type: 'udp4', reuseAddr: true });

        this.discoverySocket.on('error', (err) => {
            console.error('Discovery socket error:', err);
            try {
                this.discoverySocket.close();
            } catch (closeErr) {
                console.error('Error closing discovery socket:', closeErr);
            }
        });
        
        this.discoverySocket.on('message', (message, remote) => {
            xml2js.parseString(message.toString(), { tagNameProcessors: [xml2js['processors'].stripPrefix] }, (err, result) => {
                let probeUuid = result['Envelope']['Header'][0]['MessageID'][0];
                let probeType = '';
                try {
                    probeType = result['Envelope']['Body'][0]['Probe'][0]['Types'][0];
                } catch (err) {
                    probeType = '';
                }

                if (typeof probeType === 'object')
                    probeType = probeType._;
            
                if (probeType === '' || probeType.indexOf('NetworkVideoTransmitter') > -1) {
                    let response = 
                       `<?xml version="1.0" encoding="UTF-8"?>
                        <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope" xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing" xmlns:d="http://schemas.xmlsoap.org/ws/2005/04/discovery" xmlns:dn="http://www.onvif.org/ver10/network/wsdl">
                            <SOAP-ENV:Header>
                                <wsa:MessageID>uuid:${uuid.v1()}</wsa:MessageID>
                                <wsa:RelatesTo>${probeUuid}</wsa:RelatesTo>
                                <wsa:To SOAP-ENV:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2004/08/addressing/role/anonymous</wsa:To>
                                <wsa:Action SOAP-ENV:mustUnderstand="true">http://schemas.xmlsoap.org/ws/2005/04/discovery/ProbeMatches</wsa:Action>
                                <d:AppSequence SOAP-ENV:mustUnderstand="true" MessageNumber="${this.discoveryMessageNo}" InstanceId="1234567890"/>
                            </SOAP-ENV:Header>
                            <SOAP-ENV:Body>
                                <d:ProbeMatches>
                                    <d:ProbeMatch>
                                        <wsa:EndpointReference>
                                            <wsa:Address>urn:uuid:${this.config.uuid}</wsa:Address>
                                        </wsa:EndpointReference>
                                        <d:Types>dn:NetworkVideoTransmitter</d:Types>
                                        <d:Scopes>
                                            onvif://www.onvif.org/type/video_encoder
                                            onvif://www.onvif.org/type/ptz
                                            onvif://www.onvif.org/hardware/Onvif
                                            onvif://www.onvif.org/name/Cardinal
                                            onvif://www.onvif.org/location/
                                        </d:Scopes>
                                        <d:XAddrs>http://${this.config.hostname}:${this.config.ports.server}/onvif/device_service</d:XAddrs>
                                        <d:MetadataVersion>1</d:MetadataVersion>
                                    </d:ProbeMatch>
                                </d:ProbeMatches>
                            </SOAP-ENV:Body>
                        </SOAP-ENV:Envelope>`;

                    this.discoveryMessageNo++;
                    let responseBuffer = Buffer.from(response);
                    return dgram.createSocket('udp4').send(responseBuffer, 0, responseBuffer.length, remote.port, remote.address);
                }
            });
        });
        
        this.discoverySocket.bind(3702, () => {
            return this.discoverySocket.addMembership('239.255.255.250', this.config.hostname);
        });
    }
}

// Factory function to create OnvifServer instances
function createServer(config, logger, ipAddress) {
    return new OnvifServer(config, logger, ipAddress);
}

// Export both the class and the factory function
module.exports = {
    OnvifServer: OnvifServer,
    createServer: createServer
};
</file>

<file path="README.md">
# ONVIF Camera Proxy

A Node.js server that acts as a virtual ONVIF camera, proxying streams from IP cameras to make them compatible with Network Video Recorders (NVRs) like UniFi Protect.

## Overview

This project implements a virtual ONVIF server that simulates ONVIF protocol support for cameras that may not natively have it. It creates virtual network interfaces (using macvlan) with unique MAC addresses to represent each camera, making them appear as separate network devices to your NVR.

### Key Features

- Support for multiple NVRs with unique configurations
- Dynamic proxy port assignment to avoid conflicts
- Automatic configuration and network script generation
- Support for both high and low-quality video streams
- Static IP assignment for reliable camera access

## Requirements

- Linux operating system with macvlan support
- Root access for network interface creation
- Node.js runtime environment
- IP cameras with RTSP streams

## Quick Start

1. Clone this repository:
   ```bash
   git clone https://github.com/molesza/onvif-camera-proxy.git
   cd onvif-camera-proxy
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Create a configuration for your NVR:
   ```bash
   node main.js --create-config
   ```

4. Set up the network interfaces (requires root):
   ```bash
   sudo ./setup-network-combined.sh
   ```

5. Start the server:
   ```bash
   node main.js config-combined.yaml --debug
   ```

6. Add the virtual cameras to your NVR using the static IPs assigned in the logs.

## Documentation

For detailed setup instructions, troubleshooting, and advanced usage, see the [Setup Guide](SETUP-GUIDE.md).

## How It Works

```mermaid
graph LR
    A[IP Camera] -- RTSP Stream --> B[ONVIF Proxy Server]
    B -- Virtual ONVIF Camera --> C[NVR/UniFi Protect]
    C -- RTSP Request --> B
    B -- Proxied Request --> A
```

1. **Configuration**: The server discovers your camera's capabilities (resolution, streams, etc.)
2. **Network Setup**: Creates virtual interfaces with unique MAC addresses
3. **Protocol Translation**: Implements ONVIF Device and Media services
4. **Stream Proxying**: Forwards RTSP and snapshot requests to the actual camera

## System Architecture

- **Virtual Network Interfaces**: Each camera gets its own virtual network interface with static IP
- **SOAP Services**: Implements ONVIF Device and Media service endpoints
- **TCP Proxying**: Forwards RTSP and HTTP traffic between NVR and cameras
- **Dynamic Port Assignment**: Automatically assigns unique proxy ports per NVR

## Common Issues

- **Network interfaces don't persist**: Run `setup-network-combined.sh` after each system reboot
- **EADDRNOTAVAIL error**: Ensure you've run the network setup script before starting the server
- **Camera discovery issues**: Try manual addition with the static IPs shown in the logs

## Contributing

Contributions are welcome! Feel free to open issues or pull requests.

## License

This project is licensed under the MIT License - see the LICENSE file for details.
</file>

</files>
